<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>双括号初始化</title>
      <link href="/Java/Java/%E5%8F%8C%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/Java/Java/%E5%8F%8C%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol><li>双括号初始化</li><li>在new出类的同时，使用双括号，并对该对象进行初始化</li></ol><h3 id="二-_详细">二. 详细</h3><ol><li><p>例子</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final Set&lt;String&gt; VALID_CODES = new HashSet&lt;String&gt;() &#123; &#123; </span><br><span class="line">    add(&quot;XZ13s&quot;);</span><br><span class="line">    add(&quot;AB21/X&quot;);</span><br><span class="line">    add(&quot;YYLEX&quot;);</span><br><span class="line">    add(&quot;AR2D&quot;);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>类似于</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; validCodes = new HashSet&lt;String&gt;();</span><br><span class="line">validCodes.add(&quot;XZ13s&quot;);</span><br><span class="line">validCodes.add(&quot;AB21/X&quot;);</span><br><span class="line">validCodes.add(&quot;YYLEX&quot;);</span><br><span class="line">validCodes.add(&quot;AR2D&quot;);</span><br></pre></td></tr></table></figure></li><li><p>解析</p><ol><li>第一层括弧，实际是定义了一个内部匿名类</li><li>第二层括弧，实际上是一个实例初始化块</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的注解</title>
      <link href="/Java/Java/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
      <url>/Java/Java/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="0-_概念">0. 概念</h2><ol><li>元数据<br>数据的数据</li><li>注解也是描述数据</li><li><p>java中常见的注解</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @Override，表明重写父类方法</span><br><span class="line">2. @Deprecated，表示方法是不被建议使用的</span><br><span class="line">3. @SuppressWarnings</span><br></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>增加代码的可读性</li><li>用来简化程序中的配置</li></ol></li></ol><h2 id="1-_详细">1. 详细</h2><ol><li><p>格式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(注解保存的类型)</span><br><span class="line">@Target(注解作用的对象)</span><br><span class="line">public @interface InterfaceName &#123;</span><br><span class="line">String value() default &quot;abc&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>@Documented</code><br> 用于表明注释，会被加入到 <code>javadoc</code> 中</li><li><code>@Inherited</code><br> 表明允许子类继承父类中的注解</li><li><p><code>@Target</code><br>  用于描述该注解用于什么地方</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. ElemenetType.CONSTRUCTOR      构造器声明</span><br><span class="line">2. ElemenetType.FIELD            域声明（包括 enum 实例）</span><br><span class="line">3. ElemenetType.LOCAL_VARIABLE   局部变量声明</span><br><span class="line">4. ElemenetType.METHOD           方法声明</span><br><span class="line">5. ElemenetType.PACKAGE          包声明</span><br><span class="line">6. ElemenetType.PARAMETER        参数声明</span><br><span class="line">7. ElemenetType.TYPE             类，接口（包括注解类型）或enum声明</span><br><span class="line">8. ElementType.ANNOTATION_TYPE   注解</span><br></pre></td></tr></table></figure></li><li><p><code>@Retention</code><br> 用于描述在什么时候保存该注解信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. RetentionPolicy.SOURCE   注解将被编译器丢弃</span><br><span class="line">2. RetentionPolicy.CLASS    注解在class文件中可用，但会被VM丢弃</span><br><span class="line">3. RetentionPolicy.RUNTIME  JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</span><br></pre></td></tr></table></figure></li></ol></li><li><p>获取注解信息  </p><p> 注解类：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">/*</span><br><span class="line"> * 定义注解 Test</span><br><span class="line"> * 注解中含有两个元素 id 和 description</span><br><span class="line"> * description 元素 有默认值 &quot;hello anntation&quot;</span><br><span class="line"> */</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">public int id();</span><br><span class="line">public String description() default &quot;hello annotation&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;  </span><br><span class="line">@Test(id = 1, description = &quot;hello methodA&quot;)  </span><br><span class="line">public void methodA() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@Test(id = 2)  </span><br><span class="line">public void methodB() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@Test(id = 3, description = &quot;last method&quot;)  </span><br><span class="line">public void methodC() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">Method[] methods = TestMain.class.getDeclaredMethods();  </span><br><span class="line">for (Method method : methods) &#123;  </span><br><span class="line">boolean hasAnnotation = method.isAnnotationPresent(Test.class);  </span><br><span class="line">if (hasAnnotation) &#123;  </span><br><span class="line">Test annotation = method.getAnnotation(Test.class);  </span><br><span class="line">System.out.println(&quot;Test( method = &quot; + method.getName() + &quot; , id = &quot; + annotation.id() </span><br><span class="line">+ &quot; , description = &quot; + annotation.description() + &quot; )&quot;);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的enum类型</title>
      <link href="/Java/Java/Java%E4%B8%AD%E7%9A%84enum%E7%B1%BB%E5%9E%8B/"/>
      <url>/Java/Java/Java%E4%B8%AD%E7%9A%84enum%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol><li>enum，全称为enumeration，在JDK 1.5中引入，存放在java.lang包中</li><li>枚举类的所有实例必须在类的第一行列出，否则这个枚举类不会产生对象</li><li>枚举类相对于常量接口和常量类的优势：<ol><li>枚举类不能被继承和扩展</li><li>枚举类的常量地址一样，所以可以用==，直接比较，无需用equal的方法，能够得到性能上的优化</li><li>类型统一</li><li>枚举类不能new出来</li></ol></li><li><code>enum</code> 的本质就是一个 <code>java.lang.Eunm&lt;E&gt;</code> 类的子类</li></ol><h3 id="二-_几种常量定义的方式">二. 几种常量定义的方式</h3><ol><li><p>常量接口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ConstInterfaceA &#123;  </span><br><span class="line">public static final String CONST_A = &quot;aa&quot;;  </span><br><span class="line">public static final String CONST_C = &quot;ac&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConstClassA &#123;  </span><br><span class="line">public static final String CONST_A = &quot;aa&quot;;  </span><br><span class="line">public static final String CONST_C = &quot;ac&quot;;  </span><br><span class="line"></span><br><span class="line">// 避免常量接口的继承</span><br><span class="line">private ConstClassA() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类</p><ol><li><p>普通形式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Weekday &#123;</span><br><span class="line">MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义属性名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum Entertainment &#123;</span><br><span class="line">SING(&quot;唱歌&quot;, &quot;sing&quot;), GAME(&quot;游戏&quot;, &quot;game&quot;), OTHER(&quot;其它&quot;, &quot;other&quot;);</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private String value;</span><br><span class="line"></span><br><span class="line">Entertainment(String name, String value) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注：</span><br><span class="line">1. 在括号中用多少个字段，就需要有多少个属性</span><br><span class="line">2. 并且一定需要一个带字段的构造函数</span><br><span class="line">3. 只需要 get 方法，没必要有 set 方法</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="三-_编译器对枚举类的处理">三. 编译器对枚举类的处理</h3><ol><li><p>枚举类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;    </span><br><span class="line">RED,BLUE,BLACK,YELLOW,GREEN    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的枚举类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final enum com.simpletour.Color &#123;    </span><br><span class="line">  </span><br><span class="line">// 所有的枚举值都是类静态常量    </span><br><span class="line">public static final enum com.simpletour.Color RED;    </span><br><span class="line">public static final enum com.simpletour.Color BLUE;    </span><br><span class="line">public static final enum com.simpletour.Color BLACK;    </span><br><span class="line">public static final enum com.simpletour.Color YELLOW;    </span><br><span class="line">public static final enum com.simpletour.Color GREEN;    </span><br><span class="line"></span><br><span class="line">// 保存所有的Values值</span><br><span class="line">private static final synthetic com.simpletour.Color[] ENUM$VALUES;    </span><br><span class="line">  </span><br><span class="line">// 初始化过程，对枚举类的所有枚举值对象进行第一次初始化    </span><br><span class="line">static &#123;    </span><br><span class="line">new com.simpletour.Color    </span><br><span class="line">dup    </span><br><span class="line">ldc &lt;String &quot;RED&quot;&gt;                                                // 把枚举值字符串&quot;RED&quot;压入操作数栈    </span><br><span class="line">iconst_0                                                          // 把整型值0压入操作数栈    </span><br><span class="line">invokespecial com.simpletour.Color(java.lang.String, int)         // 调用Color类的私有构造器创建Color对象RED    </span><br><span class="line">putstatic com.simpletour.Color.RED : com.simpletour.Color         // 将枚举对象赋给Color的静态常量RED。    </span><br><span class="line">.........                                                         // 其它枚举对象与上同    </span><br><span class="line">return    </span><br><span class="line">&#125;;    </span><br><span class="line">  </span><br><span class="line">// 私有构造器，外部不可能动态创建一个枚举类对象</span><br><span class="line">private Color(java.lang.String arg0, int arg1)&#123;    </span><br><span class="line">// 调用父类Enum的受保护构造器创建一个枚举对象    </span><br><span class="line">invokespecial java.lang.Enum(java.lang.String, int);   </span><br><span class="line">&#125;;    </span><br><span class="line"> </span><br><span class="line">public static com.simpletour.Color[] values();    </span><br><span class="line">// 实现Enum类的抽象方法      </span><br><span class="line">public static com.simpletour.Color valueOf(java.lang.String arg0);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四-_通过Enum实现单例">四. 通过Enum实现单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">INSTANCE;// 唯一实例</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;使用enum实现单例模式&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Singleton sole = Singleton.INSTANCE;</span><br><span class="line">sole.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Enum </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java异常处理</title>
      <link href="/Java/Java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/Java/Java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="0-_概念">0. 概念</h3><ul><li>Checked Exception<br>必须被显式捕获，是指所有继承自 <code>Exception</code> 并且不是 <code>RuntimeException</code> 的异常n。编译器会对此作检查，必须捕获或者抛出异常。用于以下语义环境:<ul><li>该异常发生后是可以被恢复的</li><li>程序依赖于不可靠的外部条件，该条件可能出错，如IO异常</li><li>该异常发生后并不会导致程序处理错误，进行一些处理后可以继续后续操作</li></ul></li><li>Unchecked Exception<br>可以不必捕获或抛出，继承自 <code>java.lang.RuntimeException</code> 类，虽然 <code>java.lang.RuntimeException</code> 也是继承自 <code>java.lang.Exception</code>。同时也说明一个事 <code>Unchecked Exception</code> 也是可以被捕获的。</li></ul><h3 id="1-_异常类的层级关系">1. 异常类的层级关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line">|--Error</span><br><span class="line">|--Exception</span><br><span class="line">      |-- IOException</span><br><span class="line">      |        |-- EOFException</span><br><span class="line">      |        |-- FileNotFoundException</span><br><span class="line">      |        |-- MalformedURLException</span><br><span class="line">      |        |-- UnknownHostException</span><br><span class="line">      |</span><br><span class="line">      |-- ClassNotFoundException</span><br><span class="line">      |-- CloneNotSupportedException</span><br><span class="line">      |-- RuntimeException</span><br><span class="line">               |-- ArithmeticException</span><br><span class="line">               |-- ClassCastException</span><br><span class="line">               |-- IllegalArgumentException</span><br><span class="line">               |-- IllegalStateException</span><br><span class="line">               |-- IndexOutOfBoundsException</span><br><span class="line">               |-- NoSuchElementException</span><br><span class="line">               |-- NullPointerException</span><br></pre></td></tr></table></figure><h3 id="2-_异常处理中的注意事项">2. 异常处理中的注意事项</h3><ul><li>不要忽略Checked Exception，一般有如下处理方式:<ul><li>处理异常，进行修复以让程序继续执行</li><li>重新抛出异常</li><li>将异常转换为用户可以理解的自定义异常再抛出，这时应该注意不要丢失原始异常信息</li><li>不要捕获异常</li></ul></li><li>不要捕获所有的异常，即捕获Exception，不能分别处理不同的异常</li><li>使用finally块释放资源，会有如下三种情况，会进入到finally块<ul><li>try块中代码正常执行完毕</li><li>在try块中抛出异常</li><li>在try块中执行return，break，continue</li></ul></li><li>异常不能影响对象的状态，因为异常，所以如果此时，不恢复状态的话，可能会使接下来的系统产生异常，有三个方法可以达到这个目的:<ul><li>将可能产生异常的代码和改变对象状态的代码分开，先执行可能产生异常的代码，如果产生异常，就不执行改变对象状态的代码</li><li>对不容易分离产生异常的代码和改变对象状态的代码的方法时，定义一个recover方法，在异常产生后调用recover方法修复被改变的类变量，恢复方法调用前的类状态</li><li>在方法中使用对象的拷贝，这样当异常发生后，被影响的只是拷贝，对象本身不会受到影响</li></ul></li><li>不要丢失异常</li><li>不要使用同时使用异常机制和返回值同时来进行异常处理<ul><li>不易理解，维护麻烦</li></ul></li><li>不要让try块过于庞大<ul><li>不易于阅读</li><li>使用try捕获异常是以程序执行效率为代价的，将不需要捕获异常的代码包含在try块中，影响了代码执行的效率</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-Stream</title>
      <link href="/Java/Java/Java-Stream/"/>
      <url>/Java/Java/Java-Stream/</url>
      <content type="html"><![CDATA[<h3 id="0-_流的分类">0. 流的分类</h3><ol><li>按处理的数据单位进行分类<br>字节流、字符流。字节流主要是指 <code>InputStream</code> 和 <code>OutputStream</code> 及其子类；字符流，主要是指 <code>Reader</code> 和 <code>Writer</code> 及其子类。</li><li>按数据流的方向进行分类<br>输入流、输出流。输入流是指 <code>InputStream</code> 和 <code>Reader</code> 及其子类；输出流是指 <code>OutputStream</code> 和 <code>Writer</code> 及其子类。</li><li>按功能进行分类<br>节点流、处理流。节点流是直接从一个数据源读取数据。例如： <code>FileInputStream</code> 和 <code>FileOutputStream</code>；处理流，针对现有的一个流进行包装，从而提供针对该流更多的功能。例如： <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>；</li></ol><h3 id="1-_流的继承体系">1. 流的继承体系</h3><ul><li><code>InputStream</code> 与 <code>OutputStream</code><br> 数据的单位是<strong>单字节</strong>，其中深色为节点流，浅色为处理流</li></ul><center><img src="./pics/Java-InputStream.png" alt="InputStream"></center><br><center><img src="./pics/Java-OutputStream.png" alt="OutputStream"></center><pre><code>-<span class="ruby"> <span class="string">`FileInputStream / FileOutputStream`</span> 主要用于处理文件</span>-<span class="ruby"> <span class="string">`PipedInputStream / PipedOutputStream`</span> 管道，不能在同一个线程中使用，会造成死锁</span>-<span class="ruby"> <span class="string">`ByteArrayInputStream / ByteArrayOutputStream`</span> 字节数组，常常用于缓存数组，在其关掉流后，数据仍然存在。并且能够自动拓容</span>-<span class="ruby"> <span class="string">`ObjectInputStream / ObjectOutputStream`</span> 对于 <span class="constant">Java</span> 对象的序列化与反序列化，其中对象的 <span class="string">`transient`</span> 和 <span class="string">`static`</span> 类型成员变量不会被读取和写入</span>-<span class="ruby"> <span class="string">`FilterInputStream / FilterOutputStream`</span> 用于输入流和输出流提供包装</span>-<span class="ruby"> <span class="string">`DataInputStream / DataOutputStream`</span> 能够实现与机器无关方式众底层输入流中读取基本 <span class="constant">Java</span> 数据类型</span>-<span class="ruby"> <span class="string">`BufferedInputStream / BufferedOutputStream`</span> 默认缓存是<span class="number">8</span>M，能够减少磁盘访问次数，提高文件读取/写入性能。</span>-<span class="ruby"> <span class="string">`SequenceInputStream`</span> 用于将多个流进行合并</span>-<span class="ruby"> <span class="string">`PushbackInputStream`</span> 允许试探性地从流里取数据，然后再将读取的数据返还回去。</span></code></pre><ul><li><p><code>Reader</code> 和 <code>Writer</code><br> 数据的单位是<strong>2字节</strong>，深色为节点流，浅色为处理流</p><p> <img src="/pics/Java-Reader.png" alt="Reader"><br> <img src="/pics/Java-Writer.png" alt="Writer"></p><p>  <code>Reader</code>、<code>Writer</code> 与 <code>InputStream</code>、<code>OutputStream</code> 相对应，只是其处理的数据单位不同。</p></li></ul><h3 id="2-_处理流整理">2. 处理流整理</h3><ol><li>InputStream:<br><code>FilterInputStream</code>、<code>LineNumberInputStream</code>、<code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushbackInputStream</code>、<code>SequenceInputStream</code>、<code>ObjectInputStream</code></li><li>OutputStream<br><code>FilterOutputStream</code>、<code>DataOutputStream</code>、<code>BufferedOutputStream</code>、<code>PrintStream</code>、<code>ObjectOutputStream</code></li><li>Reader<br><code>BufferedReader</code>、<code>LineNumberReader</code>、<code>InputStreamReader</code>、<code>FilterReader</code>、<code>PushbackReader</code></li><li>Writer<br><code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>FilterWriter</code></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java引用</title>
      <link href="/Java/Java/Java%E5%BC%95%E7%94%A8/"/>
      <url>/Java/Java/Java%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>当 <code>JVM</code> 的内存不足时，会发生 <code>GC</code>，而对象的 <code>GC</code> 依赖该对象是否存在引用。引用的分类如下:</p><ul><li><code>StrongReference</code><br>强引用，即使内存不足，<code>JVM</code> 也不会回收强引用的对象，只出报出 <code>OOM</code> 异常</li><li><code>SoftReference</code><br> 软引用，在内存充足的情况不会回收该对象；当因内存不足将要抛出 <code>OOM</code> 异常时，就会回收此类对象<ul><li>将 <code>SoftReference</code> 对象的 <code>referent</code> 域设置为 <code>null</code>，从而使该对象不再引用 <code>heap</code> 对象</li><li><code>SoftReference</code> 将引用的内存堆上的对象生命标记为 <code>finalizable</code></li><li>当内存堆上的对象 <code>finalize()</code> 方法被运行而且该对象占用的内存被释放</li></ul></li><li><code>WeakReference</code><br> 弱引用，在 <code>GC</code> 过程中，一旦被发现将会被删除<ul><li>将 <code>WeakReference</code> 对象的 <code>referent</code> 域设置成为 <code>null</code>，从而使该对象不再引用heap对象。</li><li><code>WeakReference</code> 引用过的内存堆上的对象生命标记为 <code>finalizable</code>。</li><li>当内存堆上的对象 <code>finalize()</code> 方法被运行而且该对象占用的内存被释放</li></ul></li><li><code>PhantomReference</code><br> 虚引用，与正常的对象行为一致， 仅仅是当该对象被清除时，通过 <code>ReferenceQueue</code> 得到其被清除的通知而已，通常用于清除资源。其清除过程：<ul><li><code>PhantomReference</code> 引用过的 <code>heap</code> 对象声明为 <code>finalizable</code></li><li>虚引用在堆对象释放之前就添加到了它的 <code>ReferenceQueue</code> 里面，这种情况使得我们可以在堆对象被回收之前采取操作</li></ul></li></ul><p><code>WeakReference</code>、<code>SoftReference</code>、<code>PhantomReference</code> 如果存在相关联的 <code>ReferenceQueue</code>，其引用的对象的内存被释放后，<code>Reference</code> 对象将被加入到 <code>ReferenceQueue</code> 里面。注意是 <code>Reference</code> 对象，而非被引用的对象，被引用的对象已经被删除。</p><h3 id="1-_利用_ReferenceQueue_实现_SoftHashMap">1. 利用 <code>ReferenceQueue</code> 实现 <code>SoftHashMap</code></h3><p><code>ReferenceQueue</code> 通常用于存储已经被 <code>GC</code> 掉的对象的引用对象(<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>)。在 <code>Java</code> 体系中存在一个 <code>WeakHashMap</code>，但是 <code>WeakHashMap</code> 是以 <code>key</code> 为基准去做的 <code>WeakReference</code>，当我们了解到 <code>WeakReference</code> 后，我觉得 <code>WeakReference</code> 并不是一个最优的方案，考虑到实际情况，一个以 <code>Value</code> 为基础的 <code>SoftReference</code> 将是一个更加符合实际情况的、有效的 <code>HashMap</code>。接下来，说一下思路:</p><ol><li>一个最佳实践，并不是当内存不足时，将 <code>HashMap</code> 中的所有数据都进行删除，而会根据 <code>LRU</code> 的思想，保留一定数量的最近经常使用的对象(强引用)</li><li>所有影响 <code>HashMap</code> 大小的操作，需要从 <code>ReferenceQueue</code> 检查并清除已经被GC的数据</li><li>用 <code>SoftReference</code> 去引用 <code>value</code></li></ol><p>网上有一个人专门针对该思路进行了整理: <a href="http://www.javaspecialists.eu/archive/Issue015.html，在" target="_blank" rel="noopener">http://www.javaspecialists.eu/archive/Issue015.html，在</a> <code>Shiro</code> 源码中找到了一个对应的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">public class SoftHashMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">    private static final int DEFAULT_RETENTION_SIZE = 100;</span><br><span class="line">    private final Map&lt;K, SoftValue&lt;V, K&gt;&gt; map;</span><br><span class="line">    private final int RETENTION_SIZE;</span><br><span class="line">    private final Queue&lt;V&gt; strongReferences;</span><br><span class="line">    private final ReentrantLock strongReferencesLock;</span><br><span class="line">    private final ReferenceQueue&lt;? super V&gt; queue;</span><br><span class="line"></span><br><span class="line">    public SoftHashMap() &#123;</span><br><span class="line">        this(DEFAULT_RETENTION_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(int retentionSize) &#123;</span><br><span class="line">        super();</span><br><span class="line">        RETENTION_SIZE = Math.max(0, retentionSize);</span><br><span class="line">        queue = new ReferenceQueue&lt;V&gt;();</span><br><span class="line">        strongReferencesLock = new ReentrantLock();</span><br><span class="line">        map = new ConcurrentHashMap&lt;K, SoftValue&lt;V, K&gt;&gt;();</span><br><span class="line">        strongReferences = new ConcurrentLinkedQueue&lt;V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(Map&lt;K, V&gt; source) &#123;</span><br><span class="line">        this(DEFAULT_RETENTION_SIZE);</span><br><span class="line">        putAll(source);</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(Map&lt;K, V&gt; source, int retentionSize) &#123;</span><br><span class="line">        this(retentionSize);</span><br><span class="line">        putAll(source);</span><br><span class="line">    &#125;</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; value = map.get(key);</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        V result = value.get();</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            // 已经被GC掉了</span><br><span class="line">            // noinspection SuspiciousMethodCalls</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addToStrongReferences(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private void addToStrongReferences(V result) &#123;</span><br><span class="line">        strongReferencesLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            strongReferences.add(result);</span><br><span class="line">            trimStrongReferencesIfNecessary();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            strongReferencesLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void trimStrongReferencesIfNecessary() &#123;</span><br><span class="line">        while (strongReferences.size() &gt; RETENTION_SIZE) &#123;</span><br><span class="line">            strongReferences.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void processQueue() &#123;</span><br><span class="line">        SoftValue sv;</span><br><span class="line">        while ((sv = (SoftValue) queue.poll()) != null) &#123;</span><br><span class="line">            // noinspection SuspiciousMethodCalls</span><br><span class="line">            map.remove(sv.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        // noinspection SuspiciousMethodCalls</span><br><span class="line">        return values().contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        if (m == null || m.isEmpty()) &#123;</span><br><span class="line">            processQueue();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; entry : m.entrySet()) &#123;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        Collection&lt;K&gt; keys = map.keySet();</span><br><span class="line">        if (keys.isEmpty()) &#123;</span><br><span class="line">            // noinspection unchecked</span><br><span class="line">            return Collections.EMPTY_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;V&gt; values = new ArrayList&lt;V&gt;(keys.size());</span><br><span class="line">        for (K key : keys) &#123;</span><br><span class="line">            V v = get(key);</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                values.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; sv = new SoftValue&lt;V, K&gt;(value, key, queue);</span><br><span class="line">        SoftValue&lt;V, K&gt; previous = map.put(key, sv);</span><br><span class="line">        addToStrongReferences(value);</span><br><span class="line">        return previous != null ? previous.get() : null;</span><br><span class="line">    &#125;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; raw = map.remove(key);</span><br><span class="line">        return raw != null ? raw.get() : null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        strongReferencesLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            strongReferences.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            strongReferencesLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        processQueue();</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;</span><br><span class="line">    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        Collection&lt;K&gt; keys = map.keySet();</span><br><span class="line">        if (keys.isEmpty()) &#123;</span><br><span class="line">            //noinspection unchecked</span><br><span class="line">            return Collections.EMPTY_SET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; kvPairs = new HashMap&lt;K, V&gt;(keys.size());</span><br><span class="line">        for (K key : keys) &#123;</span><br><span class="line">            V v = get(key);</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                kvPairs.put(key, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return kvPairs.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SoftValue&lt;V, K&gt; extends SoftReference&lt;V&gt; &#123;</span><br><span class="line">        private final K key;</span><br><span class="line">        private SoftValue(V value, K key, ReferenceQueue&lt;? super V&gt; queue) &#123;</span><br><span class="line">            super(value, queue);</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_ReferenceQueue_源码分析">2. <code>ReferenceQueue</code> 源码分析</h3><p><code>ReferenceQueue</code> 的入队方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; /* Called only by Reference class */</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        // Check that since getting the lock this reference hasn&apos;t already been</span><br><span class="line">        // enqueued (and even then removed)</span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        if ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        assert queue == this;</span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        r.next = (head == null) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很明确，利用头插法建立的链表。注意在 <code>Reference</code> 中维护了 <code>queue</code> 和 <code>next</code> 字段，当入队后，<code>queue</code>字段为 <code>ENQUEUED</code>。其出队的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Reference&lt;? extends T&gt; reallyPoll() &#123;</span><br><span class="line">    Reference&lt;? extends T&gt; r = head;</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        head = (r.next == r) ?</span><br><span class="line">            null :</span><br><span class="line">            r.next; // Unchecked due to the next field having a raw type in Reference</span><br><span class="line">        r.queue = NULL;</span><br><span class="line">        r.next = r;</span><br><span class="line">        queueLength--;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队后 <code>Reference</code> 中的 <code>queue</code> 为 <code>NULL</code> 对象。</p><h3 id="3-_Reference_源码分析">3. <code>Reference</code> 源码分析</h3><center><img src="/pics/reference.png" alt=""></center><ul><li><code>PhantomReference</code>，注意其 <code>get</code> 一直都返回 <code>null</code></li><li><code>WeakReference</code> 与 <code>Reference</code> 一致</li><li><code>SoftReference</code> 会记录 <code>VM</code> 的 <code>GC</code> 的时间</li></ul><p>在 <code>Reference</code> 中，会存在四种状态:</p><ol><li>Active<ul><li><code>queue</code> 字段为传过来的 <code>ReferenceQueue</code> 或者为 <code>ReferenceQueue.NULL</code>；</li><li><code>next</code> 字段为 <code>null</code>;</li></ul></li><li>Pending<ul><li><code>queue</code> 引用的 <code>ReferenceQueue</code></li><li><code>next</code> 字段为 <code>ReferenceQueue</code> 的下一个 <code>Reference</code> 对象，或者自身</li></ul></li><li>Enqueued<ul><li><code>queue</code> 等于 <code>ReferenceQueue.ENQUEUED</code></li><li><code>next</code> 为 <code>ReferenceQueue</code> 的下一个 <code>Reference</code> 对象，或者自身</li></ul></li><li>Inactive<ul><li><code>queue</code> 为 <code>ReferenceQueue.NULL</code></li><li><code>next</code> 为<code>this</code></li></ul></li></ol><p>在 <code>Reference</code> 中存在一个静态块，创建了一个 <code>ReferenceHandler</code> 高优先级的线程。在一篇博客中有详细的解释: <a href="http://hongjiang.info/java-referencequeue/" target="_blank" rel="noopener">http://hongjiang.info/java-referencequeue/</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC-MCS队列锁</title>
      <link href="/Java/Java/JUC-MCS%E9%98%9F%E5%88%97%E9%94%81/"/>
      <url>/Java/Java/JUC-MCS%E9%98%9F%E5%88%97%E9%94%81/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>之前分析过 <code>CLH</code>，会发现其自旋检查状态时，会去检查一个非本地变量的状态。在 <code>SMP</code> 架构下没问题，而在 <code>NUMA</code> 结构下，去跨 <code>CPU</code> 模块去访问内存，会导致性能很低。而 <code>MCS</code> 队列锁将能够保证在 <code>NUMA</code> 架构下的性能。</p><h3 id="1-_源码">1. 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MCSLock implements Lock &#123;</span><br><span class="line">    private AtomicReference&lt;QNode&gt; tail = null;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line"></span><br><span class="line">    public MCSLock() &#123;</span><br><span class="line">        tail = new AtomicReference&lt;&gt;(null);</span><br><span class="line">        myNode = ThreadLocal.withInitial(QNode::new);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        QNode pred = tail.getAndSet(qnode);</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            qnode.locked = true;</span><br><span class="line">            pred.next = qnode;</span><br><span class="line">            while (qnode.locked);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        if (qnode.next == null) &#123;</span><br><span class="line">            if (tail.compareAndSet(qnode, null)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            while (qnode.next == null);</span><br><span class="line">        &#125;</span><br><span class="line">        qnode.next.locked = false;</span><br><span class="line">        qnode.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class QNode &#123;</span><br><span class="line">        private volatile boolean locked = false;</span><br><span class="line">        private volatile QNode next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路与 <code>CLH</code> 出入不大，唯一的区别，在于监听时，一个是监听非本地变量，一个监听本地变量。<strong>特别注意一点，在自旋中，<code>while</code> 中的变量一定得 <code>volatile</code>，否则会测试不过</strong>。注意其中这一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (qnode.next == null) &#123;</span><br><span class="line">    if (tail.compareAndSet(qnode, null))</span><br><span class="line">        return;</span><br><span class="line">    while (qnode.next == null) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>qnode.next == null</code> 则表明 <code>qnode</code> 是尾结点，如果通过 <code>tail.compareAndSet(qnode, null)</code> 设置成功，则表明将 <code>qnode</code> 的确为 <code>tail</code>，但是在多线程的环境下，可能在 <code>qnode.next == null</code> 成立，而在 <code>tail.compareAndSet(qnode, null)</code> 设置之前，又有一个线程 <code>lock</code>，将会导致设置失败。我认为 <code>while (qnode.next == null) {}</code> 的存在有点问题，因为如果在 <code>tail.compareAndSet(qnode, null)</code> 比较之后，在执行 <code>while (qnode.next == null) {}</code> 之前时，另一个加锁的线程同时释放了锁，那么此处将会等待下一个线程来获取锁时，才能被释放，如果该过程后，再没有线程去获取锁，那么此处将一直释放不掉锁，但是此过程，能够保证接下来的执行能够很顺利，而且仅仅是影响释放，不影响其正常的功能。</p><h3 id="2-_优缺点">2. 优缺点</h3><ul><li>优点<br>能够适应 <code>NUMA</code> 的 <code>CPU</code> 架构</li><li>缺点<ol><li>释放锁也需要通过自旋</li><li>可能存在释放不掉锁的时候，会影响性能</li></ol></li></ul><h3 id="3-_MCS_与_CLH_的区别">3. <code>MCS</code> 与 <code>CLH</code> 的区别</h3><ul><li>从代码实现来看，CLH比MCS要简单得多。</li><li>从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。</li><li>从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。</li><li>CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</li></ul><p>在 <code>http://coderbee.net/index.php/concurrent/20131115/577</code> 这篇博客中，还写了关于 <code>自旋锁</code>、<code>Ticket Lock</code> 的例子。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC-CLH队列锁</title>
      <link href="/Java/Java/JUC-CLH%E9%98%9F%E5%88%97%E9%94%81/"/>
      <url>/Java/Java/JUC-CLH%E9%98%9F%E5%88%97%E9%94%81/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>Craig, Landin, and Hagersten (CLH) 锁，基于链表的自旋锁。通过队列 <code>FIFO</code> 的特性，保证了锁的公平性、无饥饿性。</p><h3 id="1-_源码">1. 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CLHLock implements Lock &#123;</span><br><span class="line">    private final AtomicReference&lt;QNode&gt; tail;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myPred;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line">    public CLHLock() &#123;</span><br><span class="line">        tail = new AtomicReference&lt;QNode&gt;(new QNode());</span><br><span class="line">        myNode = new ThreadLocal&lt;QNode&gt;() &#123;</span><br><span class="line">            protected QNode initialValue() &#123;</span><br><span class="line">                return new QNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myPred = new ThreadLocal&lt;QNode&gt;() &#123;</span><br><span class="line">            protected QNode initialValue() &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        qnode.locked = true;</span><br><span class="line">        QNode pred = tail.getAndSet(qnode);</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        while (pred.locked) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        qnode.locked = false;</span><br><span class="line">        myNode.set(myPred.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class QNode &#123;</span><br><span class="line">        volatile boolean locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有三个属性字段:</p><ol><li><code>tail</code><br>一个 <code>AtomicReference</code>，用于在多线程环境下，保证其 <code>set</code> 和 <code>get</code> 的原子性</li><li><code>myPred</code><br><code>ThreadLocal</code> 变量</li><li><code>myNode</code><br><code>ThreadLocal</code> 变量</li></ol><p>因为 <code>myPred</code> 和 <code>myNode</code> 是 <code>ThreadLocal</code> 对象，则说明是线程独享的，那么线程间共享的变量就只有 <code>tail</code> 对象了；其实 <code>lock</code> 与 <code>unlock</code> 排除其它因素去看，单独去看这一块的代码，还是很简单的。<code>lock</code>方法，是将 <code>myNode</code> 的状态置为 <code>true</code>，表明已经被锁了，然后把 <code>myNode</code> 设置成最新的尾部，然后通过自旋的方式去检查去最新的一个尾部的状态; <code>unlock</code> 方法，则是修改 <code>myNode</code> 存储节点的状态为 <code>false</code>，表示已经释放该锁。我觉得上面这段代码中，最重要的一个代码是: <code>tail.getAndSet(qnode)</code>，因为通过上面的分析，我们也了解到 <code>tail</code> 是唯一一个多个线程间共享的变量。<code>getAndSet</code> 是一个原子操作，我们知道其内部是通过 <code>CAS</code> 进行设置的，在此过程，可能会存在其它的线程已经修改了这个变量。但是其实这并不是影响锁的功能，如果在 <code>set</code> 的过程中已经有其它的线程去修改了，那么成功 <code>set</code> 的线程必然会去等待它的前一个节点，所以我们根本不需要去管其它，每一个线程只需要关注其其返回值就好。</p><h3 id="2-_优缺点">2. 优缺点</h3><ol><li>优点<ol><li>空间复杂度低</li><li>公平</li><li>无饥饿</li><li>高性能</li></ol></li><li>缺点<ol><li>在自旋的过程，会去检查另一个 <code>Node</code> 的状态，另一个节点并不是一个本地变量，如果在 <code>NUMA</code> 的 <code>CPU</code> 架构下，读取内存数据的性能不佳，会影响该锁的性能</li></ol></li></ol><h3 id="3-_MPP_和_NUMA_的_CPU_架构">3. <code>MPP</code> 和 <code>NUMA</code> 的 <code>CPU</code> 架构</h3><ul><li>SMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是能够保证内存一致性，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。</li><li>NUMA(Non-Uniform Memory Access)非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JUC-CyclicBarrier</title>
      <link href="/Java/Java/JUC-CyclicBarrier/"/>
      <url>/Java/Java/JUC-CyclicBarrier/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点，并且能够循环使用。主要适用于: 需要等待所有的子任务都完成后，才执行主任务。</p><h3 id="1-_源码分析">1. 源码分析</h3><ol><li><p>属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private final Condition trip = lock.newCondition();</span><br><span class="line">private final int parties;</span><br><span class="line">private int count;</span><br><span class="line">private final Runnable barrierCommand;</span><br><span class="line">private Generation generation = new Generation();</span><br></pre></td></tr></table></figure><p> <code>parties</code> 和 <code>count</code> 分别表示一共有多少线程参与和还有多少线程正处于等待状态，注意此处的 <code>parties</code> 为 <code>final</code> 则表明虽然是 <code>Cyclic</code> 但是其参与者的个数是不能修改的<br> <code>barrierCommand</code> 当所有的线程都执行完成后执行的任务<br> <code>generation</code> 这是 <code>CyclicBarrier</code> 提出的一个概念，因为 <code>CyclicBarrier</code> 可以循环使用，在内部每一个过程被称为一代，而且将重置的过程，称为 <code>Break</code>，并且会有一个变量，表明是否被重置，这个变量在 <code>Generation</code> 里( <code>CyclicBarrier</code>的内部类 ):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">// 是否已经被触发或者已经被手动重置</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dowait 方法<br>代码太多，并且也不是很难，就不帖代码了，大家需要注意的是，多个线程看到的是同一个 <code>Barrier</code>，在 <code>CyclicBarrier</code> 中提出一个这样的概念： <code>all-or-none breakage model</code>，即要么全部成功，要么全部失败，即当一个线程失败后，其它的线程也将抛出异常，因为它们看到的是同一个状态变量</p></li><li><p>reset 方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void reset() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        nextGeneration();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 主要是注意 <code>reset</code> 方法中的调用顺序，先是调用 <code>breakBarrier</code>, 再调用 <code>nextGeneration</code>，因为在 <code>dowait</code> 方法中，很多的是 <code>Generation g = generation</code>, 是引用过去的，先调用 <code>breakBarrier</code> 会激活上一代的进程</p></li></ol><h3 id="2-_demo">2. demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    private static class WorkThread extends Thread &#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private CyclicBarrier barrier;</span><br><span class="line">        public WorkThread(int id, CyclicBarrier barrier) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            this.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;id = &quot; + id + &quot; start&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;id = &quot; + id + &quot; continue&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;</span><br><span class="line">        int nParties = 5;</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(nParties, () -&gt; System.out.println(&quot;All Finished!!!!&quot;));</span><br><span class="line">        for (int i = 0; i &lt; nParties; i++) &#123;</span><br><span class="line">            new WorkThread(i + 1, barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机小知识点</title>
      <link href="/Computer/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/Computer/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="可执行文件格式">可执行文件格式</h3><p>无论是Windows下的 <code>PE(Portable Executable)</code> 文件，还是Linux下的 <code>ELF(Executable Linkable Format)</code> 文件，都是<code>COFF(Common file format)</code> 文件格式的变种。可执行文件例如，Windows 下的 <code>*.exe</code>, Linux下的 <code>/bin/bash</code>。</p><h3 id="程序运行时的内存空间">程序运行时的内存空间</h3><p>主要分为BSS段、数据段、代码段、堆、栈</p><ul><li>BSS段<br><code>Block Started by Symbol</code>，用来存放程序中未初始化的全局变量的一块内存区域。通常这块区域，因为其数据未被初始化，即都为0，所以在文件中不占空间。</li><li>数据段<br><code>data segment</code>，用来存放程序中已初始化的全局变量的一块内存区域，数据段属于静态内存分配。</li><li>代码段<br><code>code segement/text segement</code>，用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。</li><li>堆<br><code>heap</code>，用于存放进程运行中被动态分配的内存段，在32位的电脑上可以达到4G内存，可动态由低地址向高地址进行扩张。</li><li>栈<br><code>stack</code>，又称为堆栈，是用户存放程序临时创建的局部变量，一般也可以在函数调用时，通过栈来传递参数，并且将结果也以栈的形式进行传递。由高地址向低地址进行扩张。</li></ul><h3 id="PE_中的节"><code>PE</code> 中的节</h3><ul><li><code>.text</code> 节<br><code>.text</code> 节基本上相当于二进制可执行文件的.text部分，它包含了完成程序任务的机器指令; 该节标记为只读，如果发生写操作，会造成 <code>segmentation fault</code>。在进程最初被加载到内存中开始，该节的大小就被固定。</li><li><code>.data</code> 节<br>用于存储初始化过的变量，如： <code>int a =0;</code> 该节的大小在运行时固定的。</li><li><code>.bss</code> 节<br>  栈下节（below stack section ,即.bss）用来存储为初始化的变量，如：int a; 该节的大小在运行时固定的。</li><li>堆节<br><code>heap section</code>，用来存储动态分配的变量，位置从内存的低地址向高地址增长。内存的分配和释放通过malloc() 和 free() 函数控制。</li><li>栈节<br><code>stack section</code>， 用来跟踪函数调用（可能是递归的），在大多数系统上从内存的高地址向低地址增长。同时，栈这种增长方式，导致了缓冲区溢出的可能性。</li><li>环境/参数节<br><code>environment/arguments section</code>，用来存储系统环境变量的一份复制文件，该节是可写的，因此在格式串（<code>format string</code>）和缓冲区溢出（<code>buffer overflow</code>）攻击中都可以使用该节。另外，命令行参数也保持在该区域中。</li></ul><h3 id="CPU工作模式">CPU工作模式</h3><p>CPU有三种模式:</p><ol><li>实模模式<ol><li>直接使用物理地址，32位地址线只使用了低20位，所以最大寻址为1M</li><li>支持多任务，不支持任务的切换</li><li>有中间向量表</li></ol></li><li>保护模式<ol><li>虚拟内存，32位地址线都能使用，最大寻址为4GB</li><li>多任务，支持优先级</li></ol></li><li>虚拟86模式<br> 虚拟86模式 ＝ 实模式 + 保护模式</li></ol><p>处理器从8086升级到80386，工作模式也从实模式升级到保护模式，虚拟86模式是为了兼容8086。其整个演变过程如下：<br>实模式 –&gt; 保护模式 –&gt; 虚拟86模式，不能直接从模式转换到虚拟86模式</p><h3 id="大端与小端">大端与小端</h3><ol><li>大端模式: 是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中;</li><li>小端模式: 是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中;</li></ol><p>因为在计算机内部是按8位，即一个字节来处理的，所以如果一个长度为32位，那么就需要来判断是否是大端或者小端了。网络传输一般采用大端序，也被称之为网络字节序，或网络序。例如数据: <code>0x12345678</code>， 其大端(左)和小端(右)表示如下:<br><img src="/pics/computer-大端.jpg" alt="">  <img src="/pics/computer-小端.jpg" alt=""></p><h3 id="产生死锁的四个必要条件：">产生死锁的四个必要条件：</h3><ul><li>互斥条件， 一个资源每次只能被一个进程使用。</li><li>请求与保持条件，一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件，进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件，若干进程之间形成一种头尾相相接的循环等待资源条件。</li></ul>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java小知识点</title>
      <link href="/Java/Java/Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/Java/Java/Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="1-_术语">1. 术语</h3><ul><li>JPA<br><code>Java Persistence API</code>， Java持久化API</li><li>JSR<br><code>Java Specification Requests</code>， Java 规范提案</li><li>JCP<br><code>Java Community Process</code></li><li>EJB<br>一个框架，将执行任务的类，放在服务器上</li><li>RMI<br><code>Remote Method Invocation</code>，远程方法调用</li><li>JNDI<br><code>Java Naming and Directory Interface</code>, Java命名和目录接口</li></ul><h3 id="2-_优化建议">2. 优化建议</h3><ul><li>在对大字符串进行 <code>spilt</code> 操作时，使用 <code>StringTokenizer</code> 的性能会更好</li><li>短路表达式，能提高效率</li><li>多使用 <code>native</code> 函数，如 <code>System.arraycopy</code></li></ul><h3 id="3-_String-format(format,_args)方法">3. String.format(format, args)方法</h3><p><code>%d</code> 包括了 <code>int, long, byte</code></p><h3 id="4-_String">4. String</h3><p>String 是不可变的，赋值会重新生成一个String对象。</p><p>1.直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。<br>2.new出来的字符串是存放在堆里<br>3.对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><pre><code><span class="number">1.</span> 右边是纯字符串常量，那么存放在栈里面。<span class="number">2.</span> 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa&quot;;</span><br><span class="line">String str2 = &quot;bbb&quot;;</span><br><span class="line">String str3 = &quot;aaabbb&quot;;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">String str5 = &quot;aaa&quot; + &quot;bbb&quot;;</span><br><span class="line">System.out.println(str3 == str4);          // false， 一个在常量池，另一个在栈上</span><br><span class="line">System.out.println(str3 == str4.intern()); // true，intern方法会将值放入常量池。两个字符串相加，会被转换成StringBuilder的append操作</span><br><span class="line">System.out.println(str3 == str5);          // true，字符串相加的时候，都是静态字符串的结果会添加到字符串池</span><br></pre></td></tr></table></figure><h3 id="5-_在引用传递中，只有对引用对象内部的修改才会影响原对象，如果直接将引用修改了，则对原对象没有影响。">5. 在引用传递中，只有对引用对象内部的修改才会影响原对象，如果直接将引用修改了，则对原对象没有影响。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void doSomething(Integer var) &#123;</span><br><span class="line">        var = new Integer(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer var1 = new Integer(1);</span><br><span class="line">        Integer var2 = var1;</span><br><span class="line">        doSomething(var2);</span><br><span class="line">        System.out.println(var1 == var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出 <code>true</code></p><h3 id="6-_带符号右移与无符号右移的区别">6. 带符号右移与无符号右移的区别</h3><ol><li><code>&gt;&gt;</code> , 有符号右移，正数，高位补0，负数，高位补1</li><li><code>&gt;&gt;&gt;</code> , 无符号右移，高位始终补0</li></ol><h3 id="7-_重载条件">7. 重载条件</h3><ol><li>参数的类型不同</li><li>参数的顺序不同</li><li>参数的个数不同</li></ol><h3 id="8-_Thread类中的run方法与start方法的区别">8. Thread类中的run方法与start方法的区别</h3><ol><li>start, 才会真正重新重新开启一个线程</li><li>run, 仅仅是执行runnble中的一个方法，并不会重新打开一个线程</li></ol><h3 id="9-_Java命名规范">9. Java命名规范</h3><ol><li>包的命名<br>全部小写, 由域名定义</li><li>类的命名<br>单词首字母大写</li><li>方法命名<br>首字母小写, 字母开头大写</li><li>常量命名<br>全部大写, 加下划线</li></ol><h3 id="10-_Java集合类中线程安全与不是线程安全的对象">10. Java集合类中线程安全与不是线程安全的对象</h3><p>前面是非线程安全，后面的是线程安全</p><ol><li>StringBuilder 和 StringBuffer</li><li>HashMap 和 HashTable</li><li>ArrayList 和 Vector</li></ol><h3 id="11-_Java中的参数类型">11. Java中的参数类型</h3><ol><li>继承关系</li></ol>&lt;center<img src="./pic/java-parameter-type.jpg" alt=""><ol start="2"><li><p>类型说明</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Type              : java语言中所有类型的公共父接口</span><br><span class="line">2. GenericArrayType  : 表示一种元素类型是参数化类型或者类型变量的数组类型，如: void method(ArrayList[] al)&#123;…&#125;</span><br><span class="line">3. ParameterizedType : 表示一种参数化的类型，比如Collection</span><br><span class="line">4. TypeVariable      : 是各种类型变量的公共父接口</span><br><span class="line">5. WildcardType      : 代表一种通配符类型表达式</span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><code>Type[] getActualTypeArguments()</code><br>这个函数仅仅是去掉最外层的&lt;&gt;后剩下的内容，就是返回值</li><li><code>Type getGenericComponentType()</code><br>这个方法仅仅脱去最右边的[]之后剩下的内容就作为这个方法的返回值</li></ul></li></ol><h3 id="12-_抽象类与接口的区别">12. 抽象类与接口的区别</h3><ol><li>语法上的区别<ol><li>抽象类里可以有构造方法，而接口内不能有构造方法。</li><li>抽象类中可以有普通成员变量，而接口中不能有普通成员变量。</li><li>抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法</li><li>抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法只能是<br>public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口内不能包含静态方法。</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定<br>义的变量只能是public  static类型，并且默认为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol></li><li>使用上的区别<ol><li>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约</li><li>抽象类在代码实现方面发挥作用</li></ol></li></ol><h3 id="13-_Java中的hashCode与equals">13. Java中的hashCode与equals</h3><p>在 <code>Object</code> 默认存在两个函数，<code>hashCode</code> 和 <code>equals</code>，这两个方法主要用于集合中比较两个对象是否相等，默认是比较对象的内存地址。<code>hashCode</code> 函数会根据当前对象的属性生成特定的哈希值。</p><ol><li>集合中如何比较两个对象？<ol><li>先比较HashCode值</li><li>如果HashCode相等，再调用equals方法，来判断</li></ol></li><li>为什么用HashCode，不直接用equals来比较？<br> 因为在集合中会存在一个table，来记录所有对象的HashCode，直接用HashCode来进行比较效率比较高，而使用equals比较，比较的操作比较多，较耗时</li></ol><h3 id="14-_ConcurrentHashMap与HashTable的区别">14. ConcurrentHashMap与HashTable的区别</h3><ul><li>并发控制的粒度不同。ConcurrentHashMap，对读操作，完全并发，对写操作，并发控制的粒度很细，支持行级锁。而HashTable，则是全表锁。</li><li>迭代器的一致性不同。ConcurrentHashMap是弱一致，而HashTable是强一致。ConcurrentHashMap的迭代弱一致，即在迭代过程，修改数据时，不同于HashTable的抛出异常的行为，它不会直接修改老数据，而是新创建一个数据，当遍历完成后，才将指针指向新的数据。这样即能够保证数据的正常遍历，又能够提高并发效率。但是HashTable具有强一致性，这种行为常被称为<code>fail-fast</code>(快速失败)迭代器，即当在遍历过程中，数据被修改，会产生异常。</li></ul><h3 id="15-_负载因子">15. 负载因子</h3><p>在HashMap中存在着一个称为“负载因子”的浮点数，“负载因子”表示的是，当达到当前容量的某一个比例时，就会扩容，该扩容的过程，被称为 <code>rehashing</code>。扩容后的容量，是当前容量的2倍。</p><h3 id="16-_内部类">16. 内部类</h3><p>内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这是内部类的惟一优点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 静态内部类 : 只能访问外部的静态类变量</span><br><span class="line">2. 私有内部类 :只能由外部类控制，不能在外部创建</span><br><span class="line">3. 公共内部类 : 都可以访问</span><br><span class="line">4. 方法内部类 : 只能在方法内访问，方法内部类的方法形参必须使用 `final` 定义</span><br></pre></td></tr></table></figure><h3 id="17-_super_与_extends_的区别">17. super 与 extends 的区别</h3><p><code>super</code> 向下造型，指明下界，表明所有父类及本身，那么此时可以向集合中添加所有子类对象，从我的角度去看，此时如果 <code>List&lt;? super A &gt;</code>就相当于 <code>List&lt;Object&gt;</code>，此时可以向里面添加任意的对象，但是取出来的对象也是 <code>Object</code> 需要强制转换；<code>extends</code>，向上选型，指明上界，表明所有子类及本身，则此时可以从集合中获取对象。在 <code>Java</code> 中，<code>List&lt;Number&gt;</code> 可以存储 <code>Integer</code> 或者 <code>Double</code> 对象，但是 <code>List&lt;Integer&gt;</code> 却不能存储 <code>Double</code> 对象，而 <code>List&lt;? extends Number&gt;</code> 表明所有继承自 <code>Number</code> 的子类及 <code>Number</code> 类，此时向 <code>List&lt;? extends Number&gt;</code> 添加数据，就会引起类型安全的问题，因为不能确定具体是那个类型啊。在Java中有一个 <code>PECS</code> 原则，即如果是生产者(即只能从集合里取数据，而不能向集合添加数据)，则使用 <code>extends</code>，如果是消费者(即只能向集合添加数据，而不能从里面取数据)，则使用 <code>super</code>; 其根本原因是因为Java在泛型方面不支持协变与逆变。</p><h3 id="18-_线程池">18. 线程池</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</td></tr><tr><td>newFixedThreadPool</td><td>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</td></tr><tr><td>newScheduledThreadPool</td><td>创建一个定长线程池，支持定时及周期性任务执行。</td></tr><tr><td>newSingleThreadExecutor</td><td>创建一个单线程的线程池，保证所有任务按照指定顺序执行。</td></tr></tbody></table><h3 id="19-_对象锁与类锁">19. 对象锁与类锁</h3><p>都是针对 <code>synchronized</code> 关键字而言的，对象锁，指以一个类的实例，作为互斥的对象；而类锁，是以类所对应的类对象作为互斥的对象，例<code>XXX.class</code></p><h3 id="20-_java_与_javax_的区别">20. java 与 javax 的区别</h3><p><code>java</code> 和 <code>javax</code> 都是 <code>Java</code> 的 <code>API(Application Programming Interface)</code> 包, <code>java</code> 是核心包，<code>javax</code> 的 <code>x</code> 是 <code>extension</code> 的意思,也就是扩展包</p><h3 id="21-_Finalize方法">21. Finalize方法</h3><ol><li>finalize 方法，是针对 <code>GC</code> 的一个补充。</li><li>finalize 方法只会执行一次</li><li>finalize 函数的执行过程如下:<ul><li>当对象不可达时，没有重写了finalize方法，直接将其回收。</li><li>当对象不可达时，重写了finalize方法，则将其放入到 <code>F-Queue</code> 队列(由低优先级线程执行该队列中的finalize方法)</li><li>当执行finalize方法完后，再次判断对象是否可达，不可达，则进行回收，否则对象“复活”</li></ul></li><li><code>gc</code> 过程的状态组<ul><li>终结状态<br><code>F = {unreachable, finalizable, finalized}</code></li><li>可达状态空间<br><code>R = {reachable, finalizer-reachable, unfinalized}</code><br>各状态含义:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- unfinalized</span><br><span class="line">  新建对象会先进入此状态</span><br><span class="line">- finalizable</span><br><span class="line">  当对象不可达，重写finalize方法时，并且已经放入到F-Queue中，等待finaize方法被执行</span><br><span class="line">- finalized</span><br><span class="line">  表示在F-Queue队列中对该对象执行过finalize方法</span><br><span class="line">- reachable</span><br><span class="line">  表示GC Roots引用可达</span><br><span class="line">- finalizer-reachable(f-reachable)</span><br><span class="line">  表示不是reachable，但可通过某个finalizable对象可达。即在finalize函数中，引用到某一个对象，此时该对象就为这个状态</span><br><span class="line">- unreachable</span><br><span class="line">  对象不可达，等待被GC</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="22-_引起OOM的几种情况">22. 引起OOM的几种情况</h3><ul><li>堆溢出<br><code>Java.lang.OutOfMemoryError: Java heap space</code>，这种是由于 <code>java</code> 堆内存不够，一个原因是真不够，另一个原因是程序中有死循环； 可以通过调整JVM的最大堆（-Xmx）；</li><li>栈溢出<br><code>java.lang.StackOverflowError</code>，需要查看是否存在深度递归，或者通过调整JVM的 <code>-Xss</code> 调整堆栈</li><li>永久区溢出<br><code>java.lang.OutOfMemoryError: PermGen space</code>，可能是由于动态代理产生了大量的 <code>class</code>，或者超过了设置的最大的永久空间</li><li>GC溢出<br><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>，是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略。</li><li>创建线程的溢出<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>，超过了最大的创建线程的个数。</li><li>创建大数组的溢出<br><code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>，分配的堆超过了堆的最大限制</li><li>swap 时的溢出<br><code>java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?</code>，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽。可能是交换区的设置太小，或者存在另一个线程正在消耗内存。</li><li>读数据时的溢出<br><code>java.lang.OutOfMemoryErr java.io.FileInputStream.readBytes(Native Method)</code></li></ul><h3 id="23-_isInstance，instanceof和isAssignableFrom的区别">23. isInstance，instanceof和isAssignableFrom的区别</h3><ul><li>instanceof<br>运算符，<code>a instanceof A</code>, <code>a</code> 是一个实例对象，而<code>A</code>是一个类，用于检查对象 <code>a</code> 是否是类 <code>A</code> 实例化。如果对象为null，则返回false。 eg: <code>obj instanceof String</code></li><li>isInstantce<br>是Class类的方法，<code>A.isInstance(B)</code>, 判断类 <code>B</code> 是否是 <code>A</code> 的父类；eg: <code>Object.class.isInstance(String.class)</code></li><li>isAssignableFrom<br>是Class类的方法，<code>A.isAssignableFrom(B)</code>, 用于判断 <code>B</code> 是否是 <code>A</code> 的子类； eg: <code>Object.class.isAssignableFrom(ArrayList.class)</code></li></ul><h3 id="24-_解决Hash冲突的方法">24. 解决Hash冲突的方法</h3><ol><li>开放地址法<ol><li>线性探测法<br>当发生冲突后，从该槽位置向后循环遍历hash表，直到找到表的下一个空槽</li><li>伪随机探测<br>将线性探测的步长从常数改为随机数，即令 <code>hash = (hash + RN) % m</code>, <code>RN</code> 是一个随机数</li></ol></li><li>拉链法<br>在冲突点上，建立链表</li><li>再散列<br>当发生冲突时，使用第二个，第三个哈希函数计算地址，直至无冲突。</li></ol><h3 id="25-_Runnable和Callable有什么不同">25. Runnable和Callable有什么不同</h3><p>Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常</p><h3 id="26-_什么是线程安全">26. 什么是线程安全</h3><p>多线程环境下，在访问共享资源时，能够保证其业务逻辑的正确性</p><h3 id="27-_Java中如何停止线程">27. Java中如何停止线程</h3><p>JDK1.0中的stop(), resume(), suspend() 因为存在死锁威胁而被弃用了，一般是通过标记变量来控制线程的退出</p><h3 id="28-_线程异常时会怎样？">28. 线程异常时会怎样？</h3><p>分成两类：可捕捉异常和非捕捉异常， 在Thread中如果存在可捕捉异常必须捕捉否则编译不过。而非捕捉异常，是通过 <code>Thread.UncaughtExceptionHandler</code> 进行处理的</p><h3 id="25-_Map">25. Map</h3><table><thead><tr><th>类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为null</td><td>不允许为null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为null</td><td>不允许为null</td><td>AbstractMap</td><td>锁分段技术</td></tr><tr><td>TreeMap</td><td>不允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>TreeMap</td><td>允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>J2ee小知识点</title>
      <link href="/J2ee/J2ee/J2ee%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/J2ee/J2ee/J2ee%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="过滤器和拦截器的区别">过滤器和拦截器的区别</h3><ul><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li></ul><h3 id="war包是否exploded的区别">war包是否exploded的区别</h3><ul><li>war<br>IDE，直接将项目打包成war包，再布置到容器中</li><li>war exploded<br>不生成war，直接生成war的解压目录，再布置到容器中</li></ul><h3 id="web-xml中的classpath的区别">web.xml中的classpath的区别</h3><ul><li>classpath  : 就是代表 <code>/WEB-INF /classes/</code> 这个路径</li><li>classpath* : 不仅仅包含 <code>/WEB-INF/classes</code> 这个路径，而且还包含所有jar下的路径</li></ul><h3 id="URL和URI区别">URL和URI区别</h3><ul><li><code>URI</code>，<code>Uniform Resource Identifier</code>，统一资源标识符</li><li><code>URL</code>，<code>Uniform Resource Locator</code>，统一资源定位器</li><li><code>URN</code>，<code>Uniform Resource Name</code>, 统一资源命名</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/getMoney</span><br><span class="line">URI: /getMoney</span><br><span class="line">URL: http://localhost:8080/getMoney</span><br></pre></td></tr></table></figure><h3 id="Eclipse_与_IDEA_中Tomcat如何工作？">Eclipse 与 IDEA 中Tomcat如何工作？</h3><p>在了解之前，我需要明白Tomcat的核心组件:</p><ol><li>Web容器， 处理静态页面</li><li>catalina，一个Servlet容器，处理Servlet</li><li>jsp容器，把jsp翻译成一般的Servlet</li></ol><p>而一般我们在Eclipse与IDEA中启动项目，其一般将tomcat拷贝多份，通过配置 <code>catalina.base</code> 从而指定不同的Tomcat的启动环境，而Tomcat是通过 <code>wtp.deploy</code> 指定部署目录，而IDEA是通过JMX去管理部署</p><h3 id="Tomcat如何做到Class隔离与共享">Tomcat如何做到Class隔离与共享</h3><p>要隔离，肯定得利用 ClassLoader。Tomcat并不是使用双亲委托模型，而是采取子优先的原则。每一个app之间是一种并行的关系，每一个app负责去加载内部类，从而达到app之间的隔离。而一些常用的jar包，比如 <code>javax.servlet.Servlet</code>，则不会由每一个app自己去加载，而是容器在启动时已经加载完成，如果与容器的版本号不一致，会导致提示 <code>jar not loaded</code>。</p><h3 id="黏性Session和非黏性Session">黏性Session和非黏性Session</h3><ul><li>黏性Session<br>此模式下同一会话中的请求都被派送到同一个tomcat实例上，这样我们就无须在多台服务器之间实现session共享了，这是其好处，不好的地方就是不能实现failureover了，一但用户访问的机器挂掉，那么其session就会丢失。</li><li>非黏性Session<br>又名复制Session，此模式下同一会话中的请求可以被分配到不同的tomcat实例上进行处理，此时就需要在不同服务器之间同步、复制session，这样一来即使一台服务器挂掉了，请求在其它服务器上照样可以访问到session信息，其缺点在于Session复制需要系统资源和网络开销</li></ul><h3 id="Servlet_中的_Filter_与_Spring_中的_Interceptor_区别"><code>Servlet</code> 中的 <code>Filter</code> 与 <code>Spring</code> 中的 <code>Interceptor</code> 区别</h3><ol><li><code>Interceptor</code> 是基于 <code>java</code> 的反射机制的，而 <code>Filter</code> 是基于函数回调</li><li><code>Filter</code> 依赖于 <code>Servlet</code> 容器，而 <code>Interceptor</code> 不依赖于 <code>Servlet</code> 容器</li><li><code>Interceptor</code> 可以访问应用的上下文，而 <code>Filter</code> 不能</li><li>在一次请求中，<code>Interceptor</code> 可以多次被调用，而 <code>Filter</code> 只能在容器初始化时被调用一次</li></ol>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络小知识</title>
      <link href="/Network/Network/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/Network/Network/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h3 id="GET与POST的区别">GET与POST的区别</h3><ul><li>GET请求能够被缓存</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>以GET请求的URL能够保存为浏览器书签</li><li>GET请求有长度限制</li><li>GET参数通过URL传递，而POST放在Request Body中，所以GET更不安全</li><li>GET只接受ASCII字符，而POST无限制</li><li>GET请求只能进行url编码，而POST支持多种编码方式</li><li>GET产生一个TCP数据包，而POST产生两个数据包；GET请求直接将header与data一并发送出去，服务器响应200,而POST，浏览器先发送header，服务器响应100后，再发送data，服务器再响应200</li></ul><h3 id="Etag">Etag</h3><ol><li><p>机制<br><br>一种缓存机制，利用 Header 中的 If-Match 或者说 If-None-Match 这个条件判断请求的资源是否被修改。其基本流程如下: 当用户第一次请求资源时，在 Header 中将包含一个 Etag 域，当用户下次再次发起请求时，会在 Header 的 If-None-Match字段上，填上上次的 Etag 值，当服务器判断 If-None-Match 为false，即匹配，将返回304，而不是200，让用户使用上次缓存的页面，从而达到减少网络通信量的目的，否则下载最近的页面。</p></li><li><p>解决了什么样的问题<br><br>主要解决 Last-Modifies 无法解决的一些问题，比如修改频率在秒以下，那么 Last-Modifies-Since 将不能监测，而 Etag 可以根据 Inode, MTime和Size灵活组装，可以避免这个问题</p></li><li><p>Etag的问题<br><br>当使用集群时，因为不同的机器其 Inode 肯定不一样，所以 Etag 每次将不一样，这样就达不到缓存的目的。</p></li></ol>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ实现无阻塞消息重试</title>
      <link href="/RabbitMQ/J2ee/RabbitMQ%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%98%BB%E5%A1%9E%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/"/>
      <url>/RabbitMQ/J2ee/RabbitMQ%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%98%BB%E5%A1%9E%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/</url>
      <content type="html"><![CDATA[<h4 id="1-_问题">1. 问题</h4><p>在处理接受到的消息时，如果发生了异常，然后该消息将一直重试。一直重试这个操作倒没有问题，但是这个重试的操作，是一个阻塞的过程，导致没办法去处理队列中其它的消息，这个现象是致命的。</p><h4 id="2-_调研及分析">2. 调研及分析</h4><p>经过调研，发现有三个技术方案涉及到消息重试，分别是:</p><ol><li>利用Spring retry实现可定制化的重试；</li><li>实现 <code>MessageRecoverer</code></li><li>死信队列</li></ol><p>其实方案一与方案二，可以算作一类，即配置 Interceptor，相关联的类是 <code>StatefulRetryOperationsInterceptorFactoryBean</code> 和 <code>StatelessRetryOperationsInterceptorFactoryBean</code>，但是它们有一个问题，的确它们能够实现定制化的重试，但是其并没有解决阻塞这个问题。Spring retry 是可以定制重试的次数及每次重试的间隔，而 <code>MessageRecover</code> 则是在重试结束后，给你一个机会去处理这个消息。而死信队列，它能够实现消息的转发，并且会在消息头上加上 <code>x-death</code> 信息，能够保存消息原来的 exchange 与 queue，然后我们觉得利用这个可以实现非阻塞。</p><h4 id="3-_死信机制">3. 死信机制</h4><p>会有三种情况会触发死信机制:</p><ol><li>消息被拒绝（basic.reject/ basic.nack）并且requeue=false</li><li>消息TTL过期（参考：RabbitMQ之TTL（Time-To-Live 过期时间））</li><li>队列达到最大长度</li></ol><p>当触发死信机制后，会通过配置的 exchange 发送到指定的队列</p><h4 id="4-_解决方案的思路">4. 解决方案的思路</h4><ol><li>在处理消息时，不能抛出业务异常，因为MQ是一个消息中间件，业务上的异常，其本身是没有处理的能力的</li><li>把消息配置成手动确认的模式</li><li>关闭重试功能，利用Spring retry，配置成 <code>org.springframework.retry.policy.NeverRetryPolicy</code>，即永不重试</li><li>创建死信队列的exchange(dlx), 创建死信队列 (dlq), 创建超时队列的exchange (timeout_exchange), 创建超时队列 (timeout_queue)</li><li><p>在超时队列上也设置死信机制:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;timeout_queue&quot;&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;kk.timeout&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>当然`timeout_exchange`就是如下的配置了:`kk.timeout` 指明的是当消息超时，将消息发送到dlq时用的key<span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:direct-exchange name=&quot;timeout_exchange&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding queue=&quot;timeout_queue&quot; key=&quot;timeout.queue&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:direct-exchange&gt;</span><br></pre></td></tr></table></figure></span>所以发送到 `timeout_queue` 的key必须为 `timeout.queue`</code></pre><ol start="6"><li><p>在需要重试机制的队列上配置如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;yourQueue&quot;&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个配置，表明当处理该队列的消息出现异常时，将会把这个消息通过dlx发送出去，当然你也可以通过配置 `x-dead-letter-routing-<span class="variable">key</span>` 指明把这个消息发送出去时的route-<span class="variable">key</span>，如果不指定的话，则会用原来的route-<span class="variable">key</span></code></pre><ol start="7"><li>然后配置一个Listener 去消费 <code>dlq</code> 中的消息，根据消息头的 <code>x-death</code> 去计算其失败的次数，可以根据失败的次数，计算出下次重试的时间，然后在其消息头上设置 <code>expiration</code> 字段，然后将其通过 <code>timeout_exchange</code> 发送到 <code>timeout_queue</code>，当消息过期后，又将返回到 <code>dlq</code> 此时再根据 <code>x-death</code> 信息，判断是否应该发送到 <code>timeout_queue</code> 还是发送到原来的队列里面。</li></ol>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JDK8 New Features</title>
      <link href="/Java/Java/JDK8%20New%20Features/"/>
      <url>/Java/Java/JDK8%20New%20Features/</url>
      <content type="html"><![CDATA[<h3 id="1-_default_:_接口能增加默认方法，又称为扩展方法">1. default : 接口能增加默认方法，又称为扩展方法</h3><p>增加该接口主要是主为了在不影响之前的接口的前提下，为接口增加方法，如List接口中stream方法，例如：</p><pre><code><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>{        <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    <span class="keyword">default</span> <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{        <span class="function"><span class="keyword">return</span> Math.<span class="title">sqrt</span><span class="params">(a)</span></span>;    }}</code></pre><h3 id="2-_Lambda表达式">2. Lambda表达式</h3><ol><li><p>格式</p><ul><li>(Type1 param1, Type2 param2, …) -&gt; Statement1, Statement2, …, StatementN</li><li>(param1, param2, …) -&gt; Statement1, Statement2, …, StatementN</li></ul></li><li><p>注</p><ul><li>返回最后一个表达式的结果</li><li>lambda函数可以访问外部本地局部的变量，但是不能改变其值</li><li>lambda函数即可访问也可以修改静态变量</li><li>lambda函数不能直接访问默认函数</li></ul></li></ol><h3 id="3-_增加的注解">3. 增加的注解</h3><p>@FunctionInterface : 函数接口，将lambda表达式映射到一个单方法的接口上</p><ul><li><p>格式</p><pre><code><span class="annotation">@FunctionalInterface</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">T</span>, <span class="title">F</span>&gt; </span>{    <span class="function">T <span class="title">convert</span><span class="params">(F f)</span></span>;}</code></pre></li><li><p>使用</p><pre><code>Converter&lt;<span class="keyword">String</span>, Integer&gt; converter = (from) -&gt; <span class="keyword">String</span>.valueOf(from);<span class="keyword">String</span> <span class="built_in">str</span> = converter.convert(<span class="number">123</span>);System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</code></pre></li></ul><h3 id="4-_增加的操作符">4. 增加的操作符</h3><p>::  操作符，用来对方式和构造函数的引用</p><ul><li><p>针对方法的引用</p><pre><code>Converter&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; converter = <span class="built_in">Integer</span><span class="tag">::valueOf</span>;<span class="built_in">Integer</span> converted = converter<span class="built_in">.</span>convert(<span class="string">"123"</span>);System<span class="built_in">.</span>out<span class="built_in">.</span>println(converted);                <span class="comment">// 123</span></code></pre></li><li><p>针对构造函数的引用</p><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{    <span class="built_in">String</span> firstName;    <span class="built_in">String</span> lastName;    Person() {}    Person(<span class="built_in">String</span> firstName, <span class="built_in">String</span> lastName) {        <span class="keyword">this</span>.firstName = firstName;        <span class="keyword">this</span>.lastName = lastName;    }}<span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>{    P create(<span class="built_in">String</span> firstName, <span class="built_in">String</span> lastName);}PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</code></pre></li></ul><h3 id="5-_特殊接口">5. 特殊接口</h3><ol><li><p>Predicate接口，用于与、或、非组成复杂的逻辑</p><pre><code>Predicate&lt;<span class="built_in">String</span>&gt; predicate = (s) <span class="subst">-&gt; </span>s<span class="built_in">.</span>length() &gt; <span class="number">0</span>;Predicate&lt;<span class="built_in">Boolean</span>&gt; nonNull = Objects<span class="tag">::nonNull</span>;predicate<span class="built_in">.</span>negative<span class="built_in">.</span>test(<span class="string">"abc"</span>);</code></pre></li><li><p>Consumer<t>接口，所对应的是一个传入一个类型T的实例对象，返回的类型为void的函数</t></p><pre><code>Consumer&lt;Person&gt; greeter = <span class="function"><span class="params">(p)</span> -&gt;</span> System.out.println(<span class="string">"Hello, "</span> + p.firstName);greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</code></pre></li><li><p>Supplier<t>接口，所对应的是一个不用传入任何的类型，返回一个类型T的实例对象，而且每次获取的对象都不一样的函数</t></p><pre><code>Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;personSupplier.<span class="keyword">get</span>(); <span class="comment">// new Person</span></code></pre></li><li><p>Function&lt;F，T&gt;接口，所对应的是一个传入一个类型F的实例对象，返回一个类型为T的实例对象</p><pre><code><span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; toInteger = <span class="built_in">Integer</span><span class="type-annotation">::</span>valueOf;System.out.println((toInteger.apply(<span class="string">"123456"</span>) instanceof <span class="built_in">Integer</span>));</code></pre></li></ol><h3 id="6-_stream操作">6. stream操作</h3><ol><li><p>过滤</p><ul><li><p>Filter</p><pre><code>Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter(n -&gt; n &gt; <span class="number">3</span>).forEach(System.out::println);</code></pre></li><li><p>distinct</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="keyword">distinct</span>().forEach(<span class="type">System</span>.<span class="keyword">out</span>::println);</code></pre></li></ul></li><li><p>遍历</p><ul><li><p>forEach, 用于有序列化流的遍历</p><pre><code>Stream.<span class="keyword">of</span>(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).forEach(System.<span class="keyword">out</span>::println);</code></pre></li><li><p>forEachOrdered, 用于并发流时，合成一个有序的集合后，再进行遍历</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.forEachOrdered(<span class="type">System</span>.out::println);</code></pre><p>  如果将forEachOrdered改成forEach，得到的结果，将不会是有序的，但是如果加上collect操作后，得到结果又是正确的，可以测试下面几个语句：</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.forEach(<span class="type">System</span>.out::println);<span class="type">System</span>.out.println(<span class="string">"========================="</span>);<span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.collect(<span class="type">Collectors</span>.toList<span class="literal">()</span>).stream<span class="literal">()</span>.forEach(<span class="type">System</span>.out::println);</code></pre></li><li><p>peek，与forEach类似，它不同与forEach的是，它在执行完成后，还会返回流，而forEach，则是流的终止操作</p><pre><code><span class="tag">Stream</span><span class="class">.of</span>("<span class="tag">A</span>", "<span class="tag">B</span>", "<span class="tag">C</span>")<span class="class">.peek</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span><span class="class">.map</span>(<span class="tag">String</span><span class="pseudo">::toLowerCase)</span><span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>map</p><pre><code>Stream<span class="built_in">.</span>of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)<span class="built_in">.</span><span class="built_in">map</span>(<span class="built_in">String</span><span class="tag">::toLowerCase</span>)<span class="built_in">.</span>forEach(System<span class="built_in">.</span>out<span class="tag">::println</span>);</code></pre></li><li><p>mapToInt</p><pre><code><span class="tag">Stream</span><span class="class">.of</span>("1", "2", "3")<span class="class">.mapToInt</span>(<span class="tag">Integer</span><span class="pseudo">::valueOf)</span><span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>mapToLong</p><pre><code>Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).mapToLong(<span class="keyword">Long</span>::valueOf).<span class="keyword">forEach</span>(System.out::println);</code></pre></li><li><p>mapToDouble</p><pre><code>Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).mapToDouble(<span class="keyword">Double</span>::valueOf).<span class="keyword">forEach</span>(System.out::println);</code></pre></li><li><p>flatMap</p><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(    Arrays.asList(<span class="number">1</span>),    Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),    Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));inputStream.flatMap(Collection::stream).forEach(System.out::println);</code></pre></li><li><p>flatMapToInt</p><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(    Arrays.asList(<span class="number">1</span>),    Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),    Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));inputStream.flatMapToLong(<span class="built_in">array</span> -&gt; <span class="built_in">array</span>.stream().mapToLong(Long::valueOf)).forEach(System.out::println);</code></pre></li><li><p>flatMapToLong， 同上</p></li><li>flatMapToDouble， 同上</li><li><p>reduce, 处理每一个元素，并得到最终的结果</p><pre><code><span class="type">System</span>.<span class="keyword">out</span>.println(<span class="type">Stream</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce(<span class="number">0</span>, (<span class="literal">result</span>, num) -&gt; <span class="literal">result</span> + num));</code></pre></li></ul></li><li><p>排序</p><ul><li><p>sorted</p><ul><li><p>不带函数参数的</p><pre><code>Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>).sorted().forEach(System.out::println);</code></pre></li><li><p>自定义比较函数</p><pre><code>Person a = <span class="keyword">new</span> Person(<span class="string">"A"</span>, <span class="number">12</span>);Person b = <span class="keyword">new</span> Person(<span class="string">"B"</span>, <span class="number">8</span>);Person c = <span class="keyword">new</span> Person(<span class="string">"C"</span>, <span class="number">15</span>);Arrays.asList<span class="function"><span class="params">(a, b, c)</span>.<span class="title">stream</span><span class="params">()</span>.<span class="title">sorted</span><span class="params">((x, y) -&gt; x.getAge() - y.getAge())</span>.<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></code></pre><p>  结果为：</p><pre><code>Person{name=<span class="string">'B'</span>, age=<span class="number">8</span>}Person{name=<span class="string">'A'</span>, age=<span class="number">12</span>}Person{name=<span class="string">'C'</span>, age=<span class="number">15</span>}</code></pre></li></ul></li><li><p>max</p><pre><code>System.out.println<span class="function"><span class="params">(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().max((x, y) -&gt; x - y).get())</span>;</span></code></pre></li><li><p>min</p><pre><code>System.out.println<span class="function"><span class="params">(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().min((x, y) -&gt; x - y).get())</span>;</span></code></pre></li></ul></li><li><p>匹配</p><ul><li><p>全部匹配</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().allMatch(n -&gt; n &gt; <span class="number">0</span>));</code></pre></li><li><p>部分匹配</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().anyMatch(n -&gt; n &gt; <span class="number">5</span>));</code></pre></li><li><p>不匹配, noneMatch</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().noneMatch(n -&gt; n &lt; <span class="number">0</span>));</code></pre></li></ul></li><li><p>计数</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>).stream().count());</code></pre></li><li><p>并行流</p><ul><li><p>parallelStream</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).parallelStream().isParallel());</code></pre></li><li><p>parallel</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>isParallel</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>sequential</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.sequential</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>unordered</p><pre><code>long start = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">Arrays</span>.asList(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>).stream<span class="literal">()</span>.parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.map(i -&gt; i + <span class="number">1</span>).forEach(<span class="type">System</span>.out::println);long <span class="keyword">end</span> = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">System</span>.out.println(<span class="string">"A : "</span> + (<span class="keyword">end</span> - start));long start2 = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">Arrays</span>.asList(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>).stream<span class="literal">()</span>.parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.unordered<span class="literal">()</span>.map(i -&gt; i+<span class="number">1</span>).forEach(<span class="type">System</span>.out::println);long end2 = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">System</span>.out.println(<span class="string">"B : "</span> + (end2 - start2));</code></pre></li></ul></li><li><p>流个数控制</p><ul><li><p>skip</p><pre><code>Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().skip(<span class="number">2</span>).forEach(System.out::println);</code></pre></li><li><p>limit</p><pre><code>Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().limit(<span class="number">2</span>).forEach(System.out::println);</code></pre></li><li><p>findAny</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.findAny</span>()<span class="class">.get</span>());</code></pre></li><li><p>findFirst</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.findFirst</span>()<span class="class">.get</span>());</code></pre></li></ul></li><li><p>迭代器</p><ul><li><p>spliterator, 用于并行流，forEachRemaining，能够保证并行流的顺序性</p><p>  Arrays.asList(“A”, “B”, “C”, “D”, “E”).stream().spliterator().forEachRemaining(System.out::println);</p></li><li><p>iterator</p><p>  Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + “ “));</p></li></ul></li><li><p>流的聚合</p><ul><li><p>collect</p><pre><code><span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.map</span>(<span class="tag">n</span> <span class="tag">-</span>&gt; <span class="tag">n</span>+1)<span class="class">.collect</span>(<span class="tag">Collectors</span><span class="class">.toList</span>())<span class="class">.stream</span>()<span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>toArray</p><pre><code>Object[] t = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().<span class="built_in">map</span>(n -&gt; n + <span class="number">1</span>).toArray();Arrays.asList(t).stream().forEach(System.out::println);</code></pre></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jdk8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-Arrays中的asList函数</title>
      <link href="/Java/Java/Java-Arrays%E4%B8%AD%E7%9A%84asList%E5%87%BD%E6%95%B0/"/>
      <url>/Java/Java/Java-Arrays%E4%B8%AD%E7%9A%84asList%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-_问题">1. 问题</h3><ul><li><p>代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] dd = new int[]&#123;3, 2, 1&#125;;</span><br><span class="line">Arrays.asList(dd).stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>结果<br>  <code>[I@41629346]</code></p></li></ul><h3 id="2-_分析">2. 分析</h3><p>其 <code>Arrays.asList</code> 的源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按通常的理解而言，此处的 <code>T</code> 指向的是 <code>int</code>，而基础类型是不能泛化的，但是 <code>int[]</code> 该类型可以。所以为了解决问题，只需要传入其包装类型就好。具体深入其中会发现， 此处的 <code>ArrayList</code> 非彼 <code>ArrayList</code>，其是一个内部类，继承自 <code>AbstractList</code>，其 <code>add</code>、<code>set</code> 方法并没重写，所以通过该方法返回的 <code>List</code> 并不能修改。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java自动装箱与拆箱</title>
      <link href="/Java/Java/Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
      <url>/Java/Java/Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
      <content type="html"><![CDATA[<h3 id="1-_自动装箱与拆箱">1. 自动装箱与拆箱</h3><ul><li>自动装箱，就是将基础类型自动转换成相应的包装类型</li><li>自动拆箱，就是将包装类型自动转换成相应的基础类型</li></ul><h3 id="2-_8种包装类型，什么情况下可以直接使用”=”">2. 8种包装类型，什么情况下可以直接使用”=”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Short           -128 ~ 127</span><br><span class="line">Integer         -128 ~ 127</span><br><span class="line">Long            -128 ~ 127</span><br><span class="line">Character          0 ~ 127</span><br><span class="line">Byte            -128 ~ 127</span><br><span class="line">Float              都不能</span><br><span class="line">Double             都不能</span><br><span class="line">Boolean       如果使用Boolean.FALSE或者Boolean.TRUE就可以</span><br></pre></td></tr></table></figure><h3 id="3-_什么情况下，会触发自动装箱与拆箱?">3. 什么情况下，会触发自动装箱与拆箱?</h3><ul><li>进行运算操作，比如对Short或者Integer，进行算术运算</li><li>装箱会调用 <code>valueof</code> 方法, 拆箱会调用 <code>intValue</code> 方法</li></ul><h3 id="4-_注意点">4. 注意点</h3><ul><li>Long与Integer比较时, 总是false</li><li>基础类型可以直接使用<code>=</code>比较，此时是比较的是值</li><li>包装类型使用<code>=</code>比较时，此时是比较的内存地址</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java应用高并发优化漫谈</title>
      <link href="/J2ee/J2ee/Java%E5%BA%94%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/"/>
      <url>/J2ee/J2ee/Java%E5%BA%94%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/</url>
      <content type="html"><![CDATA[<h3 id="一、背景">一、背景</h3><p>现在<code>QBus</code>每天有<strong>1.1～1.2</strong>亿次访问量，其中消息发送和删除的请求有<strong>9~10</strong>千万次，由两台4核8G的机器提供服务，消息拉取接口有<strong>1～2千万</strong>左右的访问量，同样也是由两台4核8G的机器提供服务。以下就是我们在提高服务整体性能上所做出的优化。</p><h3 id="二、优化思路">二、优化思路</h3><p>在谈优化思路前，首先需要搞清楚一个<code>QBus</code>请求是如何从各个服务器走到<code>qbus-server</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk ==&gt; 域名解析 ==&gt; http协议 ==&gt; kong(nginx) ==&gt; qbus-server</span><br></pre></td></tr></table></figure><p>以下是针对每个环节提供的一些优化点，大家可以深入了解一下:</p><ul><li><p>SDK<br><br>TCP的keepalive，复用连接，使用连接池</p></li><li><p>域名解析如何优化呢？<br><br>CDN，选择就近资源</p></li><li><p>HTTP协议优化如何优化呢？<br><br>现在比较流行的是<code>HTTP/1.1</code>，但是可以的话，用<code>HTTP/2</code>，性能将提高很多</p></li><li><p>kong优化？<br><br>操作系统优化和nginx的优化</p></li><li><p><code>qbus-server</code>如何优化？<br><br>操作系统优化、jvm优化、tomcat优化、代码优化</p></li></ul><p>主要叙述的是<code>qbus-server</code>的优化，以下将会从这几个方面讲解一下<code>qbus-server</code>中的优化:</p><ul><li>操作系统优化</li><li>JVM优化</li><li>Tomcat优化</li><li>代码优化</li></ul><h3 id="三、内核及网络优化">三、内核及网络优化</h3><p>以下主要基于腾讯云上的Centos7的内核、网络优化。大家可以根据各自的情况进行相应的调整。</p><p>调整步骤:</p><ul><li>用<code>root</code>权限编辑<code>/etc/sysctl.conf</code>文件</li><li>执行<code>sysctl -p</code>使配置生效</li></ul><p>特别注意在修改线上文件前，请先备份。注释的为默认值配置</p><h4 id="3-1_关闭无用的资源">3.1 关闭无用的资源</h4><ul><li><p>关闭<code>ipv6</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br></pre></td></tr></table></figure></li><li><p>数据转发<br><br>可以实现数据转发，通常用于将一张网卡的数据转发到另一张网发上</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.ip_forward = 0</span><br></pre></td></tr></table></figure></li><li><p>不处理无源地址的网络包</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"></span><br><span class="line"># net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2_安全方面优化">3.2 安全方面优化</h4><ul><li><p><code>开启防欺骗攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure></li><li><p><code>避免ping flood攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br></pre></td></tr></table></figure></li><li><p>开启防SYN洪水攻击，当出现SYN等待队列溢出时，启用cookies来处理</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3_TCP优化">3.3 TCP优化</h4><ul><li><p><code>keepalive</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效，默认是7200s</span><br><span class="line"># net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line"></span><br><span class="line"># keepalive探针，当对方不给予回应时，发送的探针的次数</span><br><span class="line"># net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"></span><br><span class="line"># keepalive探针的间隔，单位秒</span><br><span class="line"># net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`H</span>TTP<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`分</span>别有什么作用？<span class="escape">`H</span>TTP/<span class="number">1.0</span><span class="escape">`协</span>议，每一个HTTP请求开始，都将打开一个TCP连接，请求结束，都将会关闭TCP连接。从<span class="escape">`H</span>TTP/<span class="number">1.1</span><span class="escape">`开</span>始，提供了<span class="escape">`k</span>eepalive<span class="escape">`功</span>能，指的是同时请求同一个服务的同一台机器时，请求结束后，并不会立即关闭TCP连接，而是保留一段时间，在保留时间段内的请求，会复用TCP连接，过期后，才会真正结束TCP连接。TCP的<span class="escape">`k</span>eepalive<span class="escape">`指</span>的是<span class="escape">`T</span>CP<span class="escape">`协</span>议层面上的一个检测机制，当某一个TCP连接没有数据传输后，会存在着一个定时器用于确定一个<span class="escape">`T</span>CP<span class="escape">`连</span>接是否依然存活，以决定是否关闭当前连接。<span class="label">从上面的解释大家也能看出他们的区别，它们是两个不同层面上的协议，但是它们会共同影响`TCP`连接的生命周期。从时间上，`TCP`的`keepalive`和`HTTP`的`keepalive`会了出现如下几种情况:</span><span class="number">1</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间一样<span class="number">2</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间大<span class="number">3</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间小因为<span class="escape">`H</span>TTP<span class="escape">`是</span>比<span class="escape">`T</span>CP<span class="escape">`更</span>高层的协议，当<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`的</span>时间一样，或者比<span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`小</span>，其逻辑会是正常的，因为HTTP先关，再关TCP嘛。但是如果<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`大</span>，则有可能会出现，<span class="escape">`H</span>TTP<span class="escape">`的</span>连接依然在复用，但是<span class="escape">`T</span>CP<span class="escape">`已</span>经关闭。</code></pre><ul><li><p><code>TIME_WAIT</code>状态的重用及回收</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 启TCP时间戳，用来计算往返时间RTT（Round-Trip Time）和防止序列号回绕，用于支持tcp_tw_reuse和tcp_tw_recycle</span><br><span class="line"># net.ipv4.tcp_timestamps = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的状态的重用</span><br><span class="line"># net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的快速回收，在对外网提供服务时，需要关闭</span><br><span class="line"># net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`T</span>IME-WAIT<span class="escape">`会</span>保持两个周期(<span class="escape">`M</span>S<span class="escape">`)</span>，而一个<span class="escape">`M</span>S<span class="escape">`是</span>一个IP报文最大的存活时间，而两个周期在于客户端发出<span class="escape">`A</span>CK<span class="escape">`到</span>达服务器的过程和数据报来到客户端的过程。只有在两个<span class="escape">`M</span>S<span class="escape">`内</span>没有任何数据，才能让客户端确定再没有任何的数据来自服务器，才能关闭<span class="escape">`S</span>ocket<span class="escape">`。</span><span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>快速回收，是一种基于时间序列的快速回收机制，并不会让<span class="escape">`T</span>IME_WAIT<span class="escape">`状</span>态持续两个周期，而是保持一个重传时间，能够快速释放资源。<span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>重用，当满足特定条件的<span class="escape">`S</span>ocket<span class="escape">`，</span>可以用于接受新的连接，而不用先关闭再连接。</code></pre><ul><li><p><code>TCP</code>内存</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 内核分配给TCP连接的内存，单位是page：</span><br><span class="line">#  第一个数字表示TCP使用的page少于此值时，内核不进行任何处理（干预），</span><br><span class="line">#  第二个数字表示TCP使用的page超过此值时，内核进入“memory pressure”压力模式，</span><br><span class="line">#  第三个数字表示TCP使用的page超过些值时，报“Out of socket memory”错误，TCP 连接将被拒绝</span><br><span class="line"># net.ipv4.tcp_mem = 7658911021191 1531782</span><br><span class="line">net.ipv4.tcp_mem = 88557 118079 177114</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的读缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_rmem = 4096873806291456</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 6291456</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的写缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_wmem = 4096163844194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重试次数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP连接时，SYN 重发的最大次数</span><br><span class="line"># net.ipv4.tcp_syn_retries = 6</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line"># TCP连接时重发ACK的最大次数</span><br><span class="line"># net.ipv4.tcp_synack_retries = 5</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line"># 孤儿sockets废弃前重试的次数</span><br><span class="line"># net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`孤</span>儿sockets<span class="escape">`指</span>的是已经从进程上下文中删除了，可是还有一些清理工作没有完成的<span class="escape">`s</span>ocket<span class="escape">`。</span></code></pre><ul><li><p>端口范围</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口范围，提高服务能力</span><br><span class="line"># net.ipv4.ip_local_port_range = 32768 60999</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure></li><li><p>Other</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 设置FIN_WAIT2的等待时间，单位秒，默认为60</span><br><span class="line"># net.ipv4.tcp_fin_timeout = 60</span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br><span class="line"></span><br><span class="line"># 设置TIME_WAIT的最大个数，大于这个阀值后会被删除</span><br><span class="line"># net.ipv4.tcp_max_tw_buckets = 131072</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line"># 表示SYN队列的长度，默认为1024，可以容纳更多等待连接</span><br><span class="line"># net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 100000</span><br><span class="line"></span><br><span class="line"># 用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制</span><br><span class="line"># net.core.somaxconn = 128</span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line"></span><br><span class="line"># 即不属于任何进程的tcp socket最大数量. 超过这个数量的socket会被reset, 并同时告警</span><br><span class="line"># net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">net.ipv4.tcp_max_orphans = 100000</span><br><span class="line"></span><br><span class="line"># 当网卡接受数据包的速率, 比kernel处理来的快时, cache这些数据包的队列长度，默认是1000</span><br><span class="line"># net.core.netdev_max_backlog = 1000</span><br><span class="line">net.core.netdev_max_backlog = 32768</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4_其它">3.4 其它</h4><ul><li><p>日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 用于调试内核</span><br><span class="line"># kernel.sysrq = 1</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line"></span><br><span class="line"># 用于在core dump文件中，增加进程ID</span><br><span class="line"># kernel.core_uses_pid = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br></pre></td></tr></table></figure></li><li><p>内核队列</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 控制一个消息的大小，bytes</span><br><span class="line"># kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"></span><br><span class="line"># 限制一个队列的最大消息个数</span><br><span class="line"># kernel.msgmax = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、JVM优化">四、JVM优化</h3><p>JVM优化主要针对两个方面，<strong>内存</strong>和<strong>GC</strong>，以确保服务的质量和服务所占内存处于一个稳定状态。首先先介绍一下JVM的内存分布和现有<code>GC</code>算法</p><h4 id="4-1_JVM内存">4.1 JVM内存</h4><p>JVM中的内存主要有如下几个部分组成:</p><ul><li><p>程序计数器<br><br>用于指明当前线程需要执行的字节码行；<strong>线程私有</strong>；如果是Java方法，则记录虚拟机字节码指令地址，如果为<code>native</code>方法，则为<code>Undefined</code></p></li><li><p>虚拟机栈<br><br>每一个方法执行时，都将创建一个栈帧，用于记录局部变量、操作栈、动态链接、方法出口等，当方法被调用时，栈帧入栈，执行完成后，出栈。<strong>线程私有</strong>。</p></li><li><p>本地方法栈<br><br>与虚拟机栈类似，唯一的区别就是：虚拟机栈保存Java方法栈帧，而本地方法栈保存native方法栈帧。<strong>线程私有</strong>。</p></li><li><p>堆区<br><br>GC的主要区域，由<strong>所有线程共享</strong>，在虚拟机启动时创建，用于存储对象实例。</p></li><li><p>方法区<br><br>各个线程共享的区域，用于存储已经被虚拟机加载的类信息、final常量、静态变量、编译器即时编译的代码等。</p></li><li><p>直接内存<br><br>不受JVM管理的内存。</p></li></ul><p>而我们所做的优化主要针对堆区，而堆又分成：<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>、<code>Old</code>，其中<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>被统称为年轻代，<code>Old</code>是老年代。</p><h4 id="4-2_GC算法">4.2 <code>GC</code>算法</h4><p><code>GC</code>主要用于回收堆内存，而堆主要包含两个部分:</p><ul><li>年轻代</li><li>老年代</li></ul><p>针对年轻代的<code>GC</code>称为<code>Minor GC</code>，针对老年代的<code>GC</code>称为<code>Full GC</code>。</p><p>由于年轻代具有生命周期短的特点，通常采用 <strong>停止-复制</strong>的算法，其主要的算法有:</p><ul><li><p>Serial<br><br>新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。</p></li><li><p>ParNew<br><br>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。</p></li><li><p>Parallel Scavenge<br><br>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</p></li></ul><p>针对老年代对象具有数量多，对象大的特点，通常采用 <strong>标记-整理</strong>的算法，其算法有:</p><ul><li><p>Serial Old<br><br>老年代收集器，单线程收集器，使用标记整理的策略，单线程GC，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>Parallel Old<br><br>老年代，多线程收集器，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>CMS<br><br>Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</p><ol><li>初始标记， 仅仅标记一下GC Roots能直接关联到的对象</li><li>并发标记， 进行GC Roots Tracing的过程</li><li>重新标记， 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li><p>并发清除， 标记某一个对象不可用</p><p>初始标记与重新标记仍然需要停止其它工作线程。其主要的2个过程，都采用并发的操作，能够保证与工作线程一起运行。但是该算法对CPU资源很敏感，CPU越多，越快；无法处理浮动垃圾，即在一次GC过程中，可能又会出现一些垃圾，需要下次GC去处理，因为它没有停止工作线程；会产生大量内存碎片，没有整理。</p></li></ol></li><li><p>G1<br><br>基于“标记-整理”算法实现的收集器，不会产生空间碎片。G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ul><h4 id="4-3_JVM优化">4.3 JVM优化</h4><p>为了避免<code>GC</code>带来的停顿影响服务质量，在内存和GC优化过程中会有如下经验:</p><ul><li>年轻代使用<code>ParNew</code>算法，老年代使用<code>CMS</code>算法，能够减少系统由于GC带来的停顿，当然也可以直接用<code>G1</code>算法，<code>QBus</code>线上使用的就是<code>ParNew</code>和<code>CMS</code>的组合</li><li>最大堆和最小堆设置成一样，能够避免扩容引起的<code>Full GC</code></li><li>最大堆的大小，不能超过整个物理机内存的50%</li><li>年轻代的大小，最好占整个堆的 <code>3/8</code></li><li><code>Eden</code>和<code>Survivor</code>的比例是<code>8</code></li><li><code>-XX:+DisableExplicitGC</code>，这个参数慎用，<code>DirectBuffer</code>的内存释放依赖<code>System.gc()</code>，会导致内存泄露。</li></ul><p>除了内存与<code>GC</code>优化外，以下几个方面也是需要优化的:</p><ul><li>打印<code>GC</code>日志</li><li>出现内存问题时，导出内存到文件</li></ul><p>如下是线上的一台<code>QBus</code>机器的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-server </span><br><span class="line">                  -XX:+PrintGCDetails </span><br><span class="line">                  -XX:+PrintGCDateStamps </span><br><span class="line">                  -Xloggc:/data/logs/qbus-server/jvm-gc/gc.log </span><br><span class="line">                  -XX:ErrorFile=/data/logs/qbus-server/jvm-error/error.log </span><br><span class="line">                  -Xms4096M </span><br><span class="line">                  -Xmx4096M </span><br><span class="line">                  -Xss228k </span><br><span class="line">                  -Xmn1536M </span><br><span class="line">                  -XX:SurvivorRatio=8 </span><br><span class="line">                  -XX:+UseParNewGC </span><br><span class="line">                  -XX:+UseConcMarkSweepGC </span><br><span class="line">                  -XX:+AggressiveOpts </span><br><span class="line">                  -XX:MaxTenuringThreshold=15 </span><br><span class="line">                  -XX:+CMSParallelRemarkEnabled  </span><br><span class="line">                  -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure><h3 id="五、Tomcat优化">五、Tomcat优化</h3><p>Tomcat的优化主要从如下几个方面进行优化:</p><ul><li>网络模型</li><li>连接池</li><li>线程池</li><li>超时时间</li><li>TCP参数</li></ul><p>下面将从这几个方面谈优化。</p><h4 id="5-1_网络模型">5.1 网络模型</h4><p>Tomcat8.5版本中，<code>Connector</code>的<code>protocol</code>支持三个模式:</p><ul><li><p><code>org.apache.coyote.http11.Http11NioProtocol</code><br><br>同步非阻塞，用Java的NIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11Nio2Protocol</code><br><br>异步非阻塞，用Java的AIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11AprProtocol</code><br><br>异步非阻塞，通过<code>JNI</code>的方式调用核心链接库来处理文档读取和网络传输。该协议会用到如下几个库:</p><ol><li>Apache Portable Run-time libraries(Apache可移植运行库，APR)</li><li>JNI wrappers for APR used by Tomcat (libtcnative)</li><li><p>OpenSSL</p><p><code>APR</code>库，是一个跨平台库，提供与平台无关的API，能够保证同一个API，在不同平台下运行，其结果总是一致的。而<code>libtcnative</code>则会调用<code>APR</code>库进行文档和网络传输的处理。而<code>Tomcat</code>则会通过<code>JNI</code>调用<code>libtcnative</code>库。</p></li></ol></li></ul><p><code>org.apache.coyote.http11.Http11AprProtocol</code>是<code>Tomcat</code>上运行高并发的首选，接下来将介绍如何安装APR库。</p><hr><p>首先创建<code>tomcat-native-install.sh</code>脚本，并添加执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">base=`pwd`</span><br><span class="line">#tomcat的安装目录</span><br><span class="line">tomcat_base=$1</span><br><span class="line">#希望编译好的lib放到什么地方</span><br><span class="line">lib_base=$2</span><br><span class="line">    </span><br><span class="line">function install_openssl() &#123;</span><br><span class="line">    openssl=openssl-1.1.0f</span><br><span class="line">    wget https://www.openssl.org/source/$&#123;openssl&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;openssl&#125;.tar.gz</span><br><span class="line">    cd $&#123;openssl&#125; </span><br><span class="line">    ./config --prefix=$&#123;base&#125;/ssl no-shared -fPIC</span><br><span class="line">    make &amp;&amp; make install_sw</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;openssl&#125; $&#123;openssl&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_apr() &#123;</span><br><span class="line">    apr=apr-1.6.3</span><br><span class="line">    wget http://archive.apache.org/dist/apr/$&#123;apr&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;apr&#125;.tar.gz</span><br><span class="line">    cd $&#123;apr&#125;</span><br><span class="line">    ./configure --prefix=$&#123;base&#125;/apr</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;apr&#125; $&#123;apr&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_tomcat_native() &#123;</span><br><span class="line">    base_dir=`pwd`</span><br><span class="line">    cd $&#123;tomcat_base&#125;/bin</span><br><span class="line">    pwd</span><br><span class="line">    tar -xf tomcat-native.tar.gz</span><br><span class="line">    cd `ls $&#123;tomcat_base&#125;/bin | grep src`/native</span><br><span class="line">    ./configure --with-apr=$&#123;base&#125;/apr --with-ssl=$&#123;base&#125;/ssl --with-java-home=$JAVA_HOME --prefix=$lib_base</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd $base_dir</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">install_openssl</span><br><span class="line">install_apr</span><br><span class="line">install_tomcat_native</span><br><span class="line">    </span><br><span class="line">rm -rf $&#123;base&#125;/apr</span><br><span class="line">rm -rf $&#123;base&#125;/ssl</span><br><span class="line">    </span><br><span class="line">lib=$&#123;lib_base&#125;/lib</span><br><span class="line">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&apos;$&#123;lib&#125; &gt;&gt; ~/.profile</span><br><span class="line">source ~/.profile</span><br><span class="line">    </span><br><span class="line">echo 编译 Tomcat目录/conf/server.xml，将其中的 Connector 的 protocol 改成 org.apache.coyote.http11.Http11AprProtocol 和</span><br><span class="line">echo org.apache.coyote.ajp.AjpAprProtocol</span><br></pre></td></tr></table></figure><p>然后再用<code>root</code>执行<code>./tomcat-native-install.sh Tomcat的安装目录 APR库的安装位置</code>进行安装，在传参时，需要注意如下两点:</p><ol><li>传入给shell的参数需要全路径</li><li>传给shell的路径参数，最后不需要加上<code>/</code></li></ol><p>例如： <code>./tomcat-native-install.sh /usr/local/services/tomcat /usr/local/services/tomcat-apr/tomcat-native</code></p><p>安装完成后，还需要修改如下配置：</p><ol><li>修改<code>Tomcat目录/conf/server.xml</code>将其中的<code>Connector</code>的<code>protocol</code>改成<code>org.apache.coyote.http11.Http11AprProtocol</code> 和<code>org.apache.coyote.ajp.AjpAprProtocol</code></li><li>修改<code>Tomcat目录/bin/catalina.sh</code>中添加<code>JAVA_OPTS=&quot;$JAVA_OPTS -Djava.library.path=上面APR的安装目录/lib&quot;</code></li></ol><p>重启服务，即可生效。在<code>logs/catalina.out</code>，能看到如下输出，则能确定<code>APR</code>库生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">07-Mar-2019 11:46:15.871 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8080&quot;]</span><br><span class="line">07-Mar-2019 11:46:15.875 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]</span><br></pre></td></tr></table></figure><h4 id="5-2_连接池优化">5.2 连接池优化</h4><ul><li><p><code>acceptorThreadCount</code><br><br>在<code>Tomcat</code>中会由专门的<code>accept</code>线程用于接收请求，并将请求转交给工作线程。通常<code>accept</code>线程个数与CPU核数一致，默认值为1</p></li><li><p><code>acceptCount</code><br><br>当已经没有任何可用的工作线程为新的请求提供服务时，会将请求进行缓存。<code>acceptCount</code>则用于指定缓存队列的大小。当请求无法再放入缓存队列后，请求将会被拒绝。通常用户可能会在nginx层面上看到如下的异常:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure></li><li><p><code>maxConnections</code><br><br>用于设置<code>Tomcat</code>的最大连接数，这仅仅是Tomcat层面上的限制，超过最大连接数后，操作系统层面，仍然会接收请求，只是请求请求将会进入到缓存队列，当缓存队列满后，请求会被阻塞。可以设置为-1，关闭此限制。</p></li></ul><h4 id="5-3_线程池优化">5.3 线程池优化</h4><p>线程池的优化主要有两个方面:</p><ul><li>线程命名</li><li>线程个数</li></ul><p>线程命名是为在排查问题时，通过<code>jstack</code>命令查询，能够区分出哪些是<code>Tomcat</code>线程。而线程个数能够保证服务的稳定运行。<code>QBus</code>服务线上的配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Executor name=&quot;tomcatThreadPool&quot;</span><br><span class="line">              namePrefix=&quot;tomcatThreadPool-&quot;</span><br><span class="line">              maxThreads=&quot;500&quot;</span><br><span class="line">              maxIdleTime=&quot;10000&quot;</span><br><span class="line">              minSpareThreads=&quot;300&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 用于指明线程名字前缀</li><li><code>minSpareThreads</code> 初始化线程个数</li><li><code>maxThreads</code> 线程池的最大线程个数</li><li><code>maxIdleTime</code> 当某一个线程多久未使用，将会被回收，单位毫秒</li></ul><p>通常可以将线程个数的最大个数设置为500，或者更多，然后上线后，通过<code>jstack tomcat线程ID | grep Tomcat线程前缀名 | grep run | wc -l</code>查看线上稳定运行的线程个数，然后再去调整<code>minSpareThreads</code>。</p><p>请注意在Tomcat中的<code>TPS</code>是由<code>maxConnections</code>、<code>acceptCount</code>与<code>maxThreads</code>共同决定的。</p><h4 id="5-4_超时优化">5.4 超时优化</h4><p>Tomcat总体上有如下几个超时设置:</p><ul><li><p><code>connectionTimeout</code><br><br>当客户端与服务器已经建立连接后，等待客户端传输请求头时，最多等待<code>connectionTimeout</code>毫秒</p></li><li><p><code>keepAliveTimeout</code><br><br>针对<code>HTTP/1.1</code>协议，用于设置服务器最大保持连接的时间</p></li><li><p><code>disableUploadTimeout</code>和<code>connectionUploadTimeout</code><br><br>  当<code>disableUploadTimeout</code>为<code>false</code>时，<code>connectionUploadTimeout</code>才会生效。<code>connectionUploadTimeout</code>用于设置服务器等待客户传输请求体的最大等待时间。</p></li></ul><p>注意<code>connectionTimeout</code>和<code>connectionUploadTimeout</code>，这两个参数分别设置了传输请求头与请求体的最大等待时间。<code>QBus</code>的线上配置是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot;</span><br><span class="line">                executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">                protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">                URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">                enableLookups=&quot;false&quot;</span><br><span class="line">                connectionTimeout=&quot;30000&quot;</span><br><span class="line">                keepAliveTimeout=&quot;30000&quot;</span><br><span class="line">                disableUploadTimeout=&quot;false&quot;</span><br><span class="line">                connectionUploadTimeout=&quot;600000&quot;</span><br><span class="line">                acceptCount=&quot;500&quot;</span><br><span class="line">                useSendfile=&quot;false&quot;</span><br><span class="line">                compression=&quot;off&quot;</span><br><span class="line">                redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="5-5_TCP参数">5.5 TCP参数</h4><ul><li><p><code>tcpNoDelay</code><br><br>用于开启或者关闭<code>Nagle</code>算法。<code>Nagle</code>算法，会将小的<code>TCP</code>包合并成一个大的包再进行发送，避免过多的小报文的TCP头的资源消耗。通常在交互性比较强的应用中会关闭<code>Nagle</code>算法，默认是开启的。</p></li><li><p><code>connectionLinger</code><br><br>与<code>TCP</code>的<code>SO_LINGER</code>的选项一致，用于控制<code>TCP</code>的<code>close</code>行为。<code>SO_LINGER</code>通常有三个取值：</p><ol><li>-1，会将<code>socket</code>发送缓存区中的数据发送完成后，才关闭<code>socket</code></li><li>0，通过发送RST分组(而不是用正常的FIN|ACK|FIN|ACK四个分组)来关闭该连接，并放弃发送缓存区中的数据。</li><li>大于0，关闭时，进程将进入睡眠状态，内核通过定时器在超时前尽量发送数据，如果发送完成，则正常关闭，否则超时后，直接通过<code>RST</code>进行关闭，丢弃发送缓存区中的数据。</li></ol></li><li><p><code>deferAccept</code><br><br>与<code>TCP</code>中的<code>TCP_DEFER_ACCEPT</code>选项一致。在解释<code>TCP_DEFER_ACCEPT</code>参数前，先解释一下<code>TCP</code>的三次握手:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Client -&gt; Server：客户端给服务器发送SYN包</span><br><span class="line">2. Client &lt;- Server: 服务器在收到SYN包后，将返给客户SYN + ACK，Server端的连接为SYN_RECV状态</span><br><span class="line">3. Client -&gt; Server: 客户端收到SYN+ACK包后，向服务器发送ACK包，Client和Server端的连接均为ESTABLISHED</span><br></pre></td></tr></table></figure><p>  通常服务器在接受到最后的一个<code>ACK</code>包后，将进入<code>ESTABLISH</code>状态。此过程会出现一个问题，当服务器已经打开了连接，但是如果客户端一直不发数据的话，会占用服务器的资源。而<code>TCP_DEFER_ACCEPT</code>选项开启后，在接受到最后一个<code>ACK</code>后，并不会进入<code>ESTABLISH</code>状态，也并不会真正建立连接，而是保持在<code>SYN_RECV</code>状态，只是标记当前<code>socket</code>，当客户端的数据真正到来时，才建立连接。通常是需要开启<code>延迟ACK</code>，将<code>ACK</code>与数据一起发送，才能建立连接。</p></li><li><p><code>useSendfile</code><br><br>用于开启或者关闭<strong>零拷贝机制</strong>，该机制，通过减少数据在用户态和内核态的拷贝，从而提高性能。</p></li></ul><h4 id="5-6_Tomcat的注意点">5.6 Tomcat的注意点</h4><ul><li><code>Spring</code>项目，尽量不要将项目调整成<code>root</code>目录，否则有可能你会遇到某一个<code>bean</code>会被初始化两次的问题</li><li>一个<code>Tomcat</code>尽量只有一个项目</li></ul><h3 id="六、代码层面上的优化">六、代码层面上的优化</h3><p>代码方面，主要引入了内存级别的缓存层，将配置信息放入缓存，避免对数据库的读操作。多个进程间的缓存同步有两个机制进行保证:</p><ul><li>同步通过<code>QBus</code>本身进行同步</li><li>当从缓存中读取不到数据时，再读数据库，此时一定需要注意，避免出现<code>Dog Pipe Effect</code>现象</li></ul><p>加入缓存后，整个消息的发送时延多<code>40ms</code>降低到<code>10～15ms</code>之间。</p><h3 id="七、总结">七、总结</h3><p>以上就是<code>QBus</code>已经做过的优化，在孙哥(孙国峻)和我们沟通后，新版本的<code>QBus</code>中，我们将做如下的优化:</p><ol><li>减少对数据库的依赖，引入redis</li><li>模块分离，将<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>与页面逻辑进行模块分离</li><li>针对<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>接口，通过<code>netty</code>进行网络接连，这样可以自定义其<code>TCP</code>参数、连接池、线程池、网络模型等，而且除了能提高性能，同样也能给出详细的日志，比如metric信息、异常信息等，能更好地把控服务</li><li>优化日志，不直接写kafka，写文件，再同步到kafka，以便快速解决问题</li></ol><p>优化是一个长期过程，而要反复迭代，并且会很受到业务功能的影响，比如<code>QBus</code>的拉消息接口，其功能决定了这是一个慢操作，而发送消息、删除消息，就必须要保证尽可能快，所以相对而言，拉消息更消耗内存，而发送消息、删除消息接口更消耗CPU，所以优化时，也需要分开处理。欢迎大家补充指正。</p>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim</title>
      <link href="/Tools/Tools/Vim/"/>
      <url>/Tools/Tools/Vim/</url>
      <content type="html"><![CDATA[<h3 id="1-_Vim复制数据到剪切板">1. Vim复制数据到剪切板</h3><ol><li>安装vim-gui-commom<br><code>sudo apt-get install vim-gui-common</code></li><li><p>使用命令<br>在普通模式下，输入三个字符 <code>&quot;+y</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;，表示使用的是寄存器</span><br><span class="line">2. +，表示系统的剪切板</span><br><span class="line">3. y，复制</span><br></pre></td></tr></table></figure><p>可以通过 <code>:reg</code> 命令，查看所有的寄存器数据</p></li></ol><h3 id="2-_Vim的插件管理工具—-Bundle">2. Vim的插件管理工具—-Bundle</h3><p>安装过程如下:</p><ol><li>从github上down下Vundle，地址：<a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="noopener">https://github.com/gmarik/Vundle.vim</a></li><li>放在vimfiles文件的bundle目录下</li><li><p>在_vimrc文件中，加入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">filetype off</span><br><span class="line"> </span><br><span class="line">set rtp+=D:\Tools\Vim\vimfiles\bundle\Vundle.vim  #你下载的vundle的位置，目录名为Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line"> </span><br><span class="line">Plugin &apos;gmarik/Vundle.vim&apos;  &quot;Vundle插件</span><br><span class="line">...其它插件</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure></li></ol><p>安装插件时，在vundle中的格式如下:</p><ol><li>代码在github上,使用github帐号/项目名，例如: <code>Bundle &#39;tpope/vim-fugitive&#39;</code> 可以直接通过加上<code>https://github.com/tpope/vim-fugitive</code>进行访问</li><li>“代码在vimscript上，使用插件名称，插件名字可以在<code>http://vim-scripts.org/vim/scripts.html</code>页面中查找，例如: <code>Bundle &#39;vimwiki&#39;</code></li></ol><p>常用的命令如下:</p><ol><li>BundleInstall， 安装所有的在文件中配置了的插件</li><li>BundleSearch，搜索某个插件</li><li>BundleClean, 删除之前下载过，但是现在不使用的插件</li></ol>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Zookeeper</title>
      <link href="/Zookeeper/Zookeeper/Zookeeper/"/>
      <url>/Zookeeper/Zookeeper/Zookeeper/</url>
      <content type="html"><![CDATA[<h3 id="0-_Zookeeper介绍">0. Zookeeper介绍</h3><p>Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务。其维护了一个类似Linux文件系统，但比它更简单，支持分布式的文件系统，能够保证对于节点的操作具有原子性，并且能够保证集群中所有服务器都具有相同的数据。有如下优点:</p><ol><li>原子性<br>更新只能成功或者失败，没有中间状态</li><li>顺序性<br>包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面</li><li>最终一致性(单系统镜像)<br>Client不论连接到哪个Server，都能看到完全一致的数据</li><li>等待无关<br>慢的或者失效的Client不得干预快速的Client的请求，使得每个Client都能有效的等待</li><li>可靠性<br>具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受</li><li>实时性<br>Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</li></ol><p>主要使用Zookeeper完成命名服务、配置管理、同步、组服务。使用的 <strong>ZAB(ZooKeeper Atomic Broadcast)协议</strong> 作为其数据一致性的算法。其最大的特性就是数据复制，具有如下的优势:</p><ol><li>容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作</li><li>提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力</li><li>提高性能<br>让客户端本地访问就近的节点，提高用户访问速度</li></ol><h3 id="1-_基本概念">1. 基本概念</h3><ul><li>事务<br>Client发出的每一个操作数据的请求，都会包装成一个事务，用 ZXID 唯一标识事务。</li><li>ZXID<br>是64位的数字，高32位代表Leader周期的 epoch 编号，而低32位是一个简单递增的计数器。ZAB 使用 epoch 来区分不同的 Leader 周期</li><li><p>Znode<br>对于文件系统中的每一个层次，称为一个节点。节点能够存储数据，和一些额外的数据:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid: 创建时的事务</span><br><span class="line">   ctime: 创建时间</span><br><span class="line">   mZxid: 修改时的事务</span><br><span class="line">   mtime: 修改时间</span><br><span class="line">   pZxid: 子节点最后一次修改的事务</span><br><span class="line">   cversion: 子节点的修改版本号记录，子节点每修改一次，增加1</span><br><span class="line">   dataVersion： 当前节点的数据的修改记录，每修改一次，增加1</span><br><span class="line">   aclVersion: 用于控制节点的权限</span><br><span class="line">   ephemeralOwner: 如果是临时节点，则记录session id，否则为0</span><br><span class="line">   dataLength: 数据长度</span><br><span class="line">   numChildren: 子节点的个数</span><br></pre></td></tr></table></figure><p>  节点分为四类：<code>PERSISTENT</code>， <code>PERSISTENT_SEQUENTIAL</code>， <code>EPHEMERAL</code>， <code>EPHEMERAL_SEQUENTIAL</code>， 临时指的是Session关闭时，节点将会删除，持久是指是否可以持久化，顺序指的是创建的节点会根据创建时间进行编号，后创建的编号越大，编号一般都跟在名字后面。</p></li><li>Watch<br>客户端能够针对节点添加监听器，当节点改变后，会触发watch，然后会清除watch，即watch是一次性的，而且watch能够保证事件的顺序性。watch分为两类，数据监听器和子节点监听器。</li><li>Session<br>客户端和服务端建立连接后，会话随之建立，生成一个全局唯一的会话ID(Session ID)，服务器与客户端建立TCP长连接。</li><li>ACL<br>Access Controller List，用于控制对于节点的访问，类似于unix中的<code>allow/disallow</code></li></ul><h3 id="2-_常量">2. 常量</h3><ol><li>当节点的类型为<code>PERSISTENT_SEQUENTIAL</code>, <code>EPHEMERAL_SEQUENTIAL</code>，序号从<strong>0000000001 ~ 2147483647</strong>，格式为<code>%10d</code></li><li>节点数据不能超过 1M</li><li>最多接受来自服务器的数据大小为 4M</li><li>默认的session的过期时间，2 ~ 20 个 tickTime</li></ol><h3 id="3-_常见的使用场景">3. 常见的使用场景</h3><ol><li>命名服务<br>Zookeeper 提供了一套简单的文件系统，当在同一个路径下再次创建节点时，会出错，就能保证每一个路径的唯一性。而命名服务，需要保证每一个名字的唯一性，可以通过文件系统路径的唯一性去保证。</li><li>配置管理<br>将一些小的配置放到 Zookeeper 上，因为每个 Zookeeper 服务器所看到的数据都是一致的，并且能够一致更新，从而达到动态配置的目的。</li><li><p>同步<br>利用 Zookeeper 实现分布式锁。其实现锁有以下几种方式:</p><ol><li>利用节点名称的唯一性来实现共享锁<br>在同一个路径下去同时去创建节点，谁创建成功，则获得锁，使用完后，再删除节点；否则就监听该节点，当删除时，再次去尝试创建。利用 Zookeeper 操作的原子性。如果该节点下的 watcher 很多的话，当释放锁时，会有很多线程同时去创建锁，效率不高。</li><li>利用临时顺序节点实现共享锁的一般做法<br>首先创建一个节点(例如 /distribute_lock)，所有客户端在它下面创建临时顺序 (EPHEMERAL_SEQUENTIAL) 节点，例如(/distribute_lock/guid-lock-)，同时在这个节点上注册上子节点变更通知的 Watcher，客户端调用 getChildren(“/distribute_lock”)，如果发现自己创建的节点的序号最小，则获得锁，否则就等待锁被释放，然后每一次变更都比较一下，自己的序号是否为最小。如果子节点很多的话，会有很多无用的 watch 事件。</li><li>利用临时顺序节点实现共享锁的改进实现<br>与方法二类似，只是在 watch 时，只关注节点顺序比自己小 1 的节点的事件。</li></ol></li><li>组服务<br>主要体现在于 Zookeeper 对集群的管理，而对集群的管理，主要需要解决如下两个问题:<ol><li>动态观察是否有服务器退出和加入集群<br>在一个约定目录下，创建临时节点，并且监听该目录的变化，如果掉线，则节点会被删除，那么同时，其它服务器会收到其宕机的消息。</li><li>选举master<br>同样在一个约定目录下，创建临时有序节点，每次选取编号最小的机器作为master就好。</li></ol></li><li>队列管理<ol><li>Barrier: 当一个队列的成员都聚齐时，这个队列才可用，否则一直等待<br>在约定目录下创建临时目录节点，监听目录节点数是否和我们要求的数目一致</li><li>队列按照 FIFO 方式进行入队和出队的操作<br>在约定上当下创建临时顺序目录节点，出队按编号最小的原则出队</li></ol></li></ol><h3 id="4-_ZAB协议">4. ZAB协议</h3><p>ZAB协议是作为Zookeeper一致性复制的核心。除了保证数据一致性之外，还需要满足以下的两个安全属性:</p><ol><li>全序<br>Total Order, 如果消息a 在消息b 之前发送，则所有 Server 应该看到相同的结果</li><li>因果顺序<br>Causal Order, 如果消息a 在消息b 之前发生，并被一起发送，则a始终在b之前被执行</li></ol><p>在ZAB协议中使用了TCP协议和Leader机制。通过TCP协议保证了消息的全序特性，利用Leader机制保证了因果顺序。因为所有的操作数据的操作都将通过TCP协议发给Leader，而Leader只有一个。整个ZAB协议分成四个阶段: 选举(election)、发现(discovery)、同步(sync)、广播(Broadcast)。通常根据状态分为崩溃恢复模式和消息广播模式。ZAB协议中存在三种状态: Looking(处于选举状态)、Following(当前节点是跟随者)、Leading(当前节点是 Leader， 负责协调事务)。</p><h4 id="4-1_崩溃恢复模式">4.1 崩溃恢复模式</h4><ol><li><p>选举<br>必须确保选出的 Leader 具有最高的 ZXID 。选举流程如下:</p><ol><li>每个 Follower 都向其他节点发送选自身成为 Leader 的投票请求，并带上自己最新的 ZXID；</li><li>Follower 接受到的 ZXID 如果比自身的大时则投票，并记录，否则拒绝投票；</li><li>每个 Follower 中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该 Follower 选为 Leader；</li></ol></li><li><p>发现<br>当选出最新的 Leader 后，Leader 将生成新的 epoch，让 Follower 接受最新的 acceptedEpoch。并且接收 Follower 发过来的 FOLLOWERINFO (含有当前节点的最新的 ZXID)，发现大多数节点接收的最新提议。</p></li><li><p>同步<br>Leader 利用前一阶段获得的最新提交记录，与 Follower 同步数据。同步策略如下:</p><ol><li>SNAP<br>如果 Follower 数据太老， Leader 将发送快照 SNAP 指令给 Follower 同步数据</li><li>DIFF<br>Leader 发送从 Follower 的 LastZXID 到 Leader 的 LastZXID 的 DIFF 指令给 Follower，以同步数据。</li><li>TRUNC<br>当 Follower 的 LastZXID 比 Leader 的 LastZXID 大时，Leader 发送从 Leader 的 LastZXID 到 Follower 的 LastZXID 的 Trunc 指令，让 Follower 丢弃该段数据</li></ol><p>SNAP 与 DIFF 指令用于保证集群中的 Follower 节点与已经 Committed 数据一致， TRUNC 用于抛弃已经被处理但是没有 Committed 的数据。当集群中大多数 Follower 同步成功后，再会真正成为 Leader。</p></li><li><p>ZAB崩溃恢复的策略:</p><ol><li>ZAB协议需要确保那些已经在 Leader 服务器上提交的事务最终被所有服务器都提交<br>假设一个事务在 Leader 服务器上被提交了，并且已经得到了过半 Follower 服务器的 Ack 反馈，此时 Leader 已经提交，但是在它将 Commit 消息发送给所有 Follower 机器之前，Leader 服务器挂了，恢复过程中则需要恢复该操作日志</li><li>ZAB 协议将丢弃那些只在 Leader 服务器上被提出的事务。<br>假设初始的 Leader 服务器 Server 在提出一个事务之后，还没有给 Follower 发送请求，希望得到 Ack 之前，挂了,则要丢弃该事务</li></ol></li></ol><h4 id="4-2_消息广播模式">4.2 消息广播模式</h4><ol><li>Leader 服务器会为事务请求生成一个全局唯一递增的事务ID（即ZXID），保证每个消息的因果关系的顺序。</li><li>Leader 服务器会为该事务生成对应的 Proposal，进行广播。</li><li>Leader 服务器会为每一个 Follower 服务器都各自分配一个单独的队列，将需要广播的事务 Proposal 依次放入这些队列中去，并根据 FIFO 策略进行消息发送。</li><li>每一个 Follower 服务器在接收到这个事务 Proposal 之后，首先以日志形式写入本地磁盘，并且成功写入后反馈给 Leader 服务器一个 Ack 响应</li><li>当 Leader 服务器接收超过半数的 Follower 的 Ack 响应，Leader 自身也会完成对事务的提交。同时就会广播一个 Commit 消息给所有的Follower 服务器以通知进行事务提交。每一个 Follower 服务器在接收到 Commit 消息后，也会完成对事务的提交。</li></ol><p>消息广播过程中使用了 TCP 协议进行通讯所有保证了接受和发送事务的顺序性。</p><h3 id="5-_常见问题">5. 常见问题</h3><ul><li><p>为什么要限制ZooKeeper中ZNode的大小？<br>ZooKeeper 是一套高吞吐量的系统，为了提高系统的读取速度，ZooKeeper 不允许从文件中读取需要的数据，而是直接从内存中查找。换句话说，ZooKeeper 集群中每一台服务器都包含全量的数据，并且这些数据都会加载到内存中。同时 ZNode 的数据不支持 Append 操作，全部都是Replace。所以从上面分析可以看出，如果 ZNode 过大，那么读写某一个 ZNode 将造成不确定的延时; 同时 ZNode 过大，将过快地耗尽ZooKeeper 服务器的内存。</p></li><li><p>ZAB 与 Paxos 的关系与区别<br>ZAB 与 Paxos 算法一样都是一致性算法，而 ZAB 同时解决了全序与因果顺序的问题。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Zookeeper-01-简介</title>
      <link href="/Zookeeper/Zookeeper/Zookeeper-01-%E7%AE%80%E4%BB%8B/"/>
      <url>/Zookeeper/Zookeeper/Zookeeper-01-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。其通过一个类似于文件目录的树形文件系统，可以对外提供配置维护、分布式同步、组服务、域名服务。Zookeeper具有如下特点:</p><ol><li>简单<br>只需要类似于文件系统的操作，就可以完成分布式环境下程序的协调，不能不说，其操作是简单的</li><li>镜像服务<br><code>Zookeeper</code> 会保证在所有的服务器所存储的数据都是一样的</li><li>有序的<br><code>Zookeeper</code> 会通过事务ID去标记每一次的更新操作</li><li>快速的<br>在读多写少的情况下，效率最高，读写效率为 <code>10 : 1</code></li></ol><p>主要涉及如下的概念:</p><ol><li><p>节点<br><code>Zookeeper</code> 提供一种类似于文件系统的树形结构，该树形结构上每一个点，被称为节点。节点有如下几类:</p><ol><li><code>PERSISTENT</code><br>持久化非顺序的节点</li><li><code>PERSISTENT_SEQUENTIAL</code><br>持久化并且顺序的节点</li><li><code>EPHEMERAL</code><br>临时非顺序节点</li><li><code>EPHEMERAL_SEQUENTIAL</code><br>临时并且顺序的节点</li></ol><p>在上面提出两个概念 <strong>持久化</strong> 和 <strong>顺序</strong>，<strong>持久化</strong> 是指当创建操作成功后，无论服务器是否重启，该结点都将存在。<strong>临时</strong> 是相对 <strong>持久</strong> 而言的，是指创建的结点的生命周期与 <code>Session</code> 的生命周期一致，即当关闭 <code>Session</code> 后，该节点也将被删除；<strong>顺序</strong> 是指在创建该结点时，是否会在节点后面添加一个最大值为 <code>2147483647</code> 并且固定为 <code>10</code> 位的顺序号，顺序号的大小，表明了该节点的创建时间与其它节点的创建时间上的先后。即如果顺序号小，但是表明是先被创建的。</p></li><li><code>Watch</code><br>用于监听节点的变化</li><li><code>ACL</code><br>权限控制</li><li><code>Session</code><br>每一个连接到 <code>Zookeeper</code> 服务的客户端，系统都将为其创建一个 <code>Session</code>。</li></ol><h3 id="1-_源码的目录结构">1. 源码的目录结构</h3><p>先大概的说一下源码的编译方式吧:</p><ol><li>下载 <code>apache ant</code>，并将它添加进环境变量里</li><li>下载源码，在源码所在目录下运行 <code>ant eclipse</code></li><li><code>intellij idea -&gt; New -&gt; Project from Existing Sources -&gt; eclipse</code>，然后一直下一步</li><li>在 <code>ZooKeeperServerMain</code> 这个类，<code>Ctrl + Shift + F10</code>，然后关闭</li><li>编辑 <code>Run/Debug Configurations</code>， 在 <code>Program arguments</code> 中填入 <code>2180 ~/workstation/temp/zk-data</code> （路径自己定义）</li><li>然后，你再去一个编译好了的 <code>Zookeeper</code> ，然后在其的 <code>bin</code> 目录下，运行 <code>zkCli.sh -server 127.0.0.1:2180</code>，如果能正常显示，说明编译成功</li></ol><p>目录结构如下:</p><center><img src="/pics/Zookeeper-Sources.png" alt=""></center><ul><li>bin<br>一些脚本</li><li>conf<br>配置文件</li><li>docs<br>文档说明</li><li>src<br>在该目录下，只关注 <code>java</code> 与 <code>recipes</code> 目录，<code>java</code> 目录并没有什么好解释的，只需要关注 <code>generated</code> 是通过代码生成的 <code>java</code> 代码；<code>recipes</code> 是 <code>Zookeeper</code> 提供的一些高级功能，例如： 利用 <code>Zookeeper</code> 实现锁、<code>Queue</code>、<code>Election</code>。</li></ul>]]></content>
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Source codes analysis </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Zookeeper-02-Session</title>
      <link href="/Zookeeper/Zookeeper/Zookeeper-02-Session/"/>
      <url>/Zookeeper/Zookeeper/Zookeeper-02-Session/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>在对 <code>Zookeeper</code> 的使用过程中，经常会用到临时节点，而临时节点与 <code>Session</code> 相关，那么 <code>Session</code> 在 <code>Zookeeper</code> 中到底是怎样的一个概念呢？会从如下几个角度去看:</p><ol><li>Session 的创建</li><li>Session 的关闭</li><li>Session 的过期</li></ol><p>在 <code>Zookeeper</code> 找到了一个与 <code>Session</code> 相关的接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface SessionTracker &#123;</span><br><span class="line">    public static interface Session &#123;</span><br><span class="line">        long getSessionId();</span><br><span class="line">        int getTimeout();</span><br><span class="line">        boolean isClosing();</span><br><span class="line">    &#125;</span><br><span class="line">    public static interface SessionExpirer &#123;</span><br><span class="line">        void expire(Session session);</span><br><span class="line">        long getServerId();</span><br><span class="line">    &#125;</span><br><span class="line">    long createSession(int sessionTimeout);</span><br><span class="line">    boolean addGlobalSession(long id, int to);</span><br><span class="line">    boolean addSession(long id, int to);</span><br><span class="line">    boolean touchSession(long sessionId, int sessionTimeout);</span><br><span class="line">    void setSessionClosing(long sessionId);</span><br><span class="line">    void shutdown();</span><br><span class="line">    void removeSession(long sessionId);</span><br><span class="line">    boolean isTrackingSession(long sessionId);</span><br><span class="line">    public void checkSession(long sessionId, Object owner)</span><br><span class="line">            throws KeeperException.SessionExpiredException,</span><br><span class="line">            KeeperException.SessionMovedException,</span><br><span class="line">            KeeperException.UnknownSessionException;</span><br><span class="line">    public void checkGlobalSession(long sessionId, Object owner)</span><br><span class="line">            throws KeeperException.SessionExpiredException,</span><br><span class="line">            KeeperException.SessionMovedException;</span><br><span class="line">    void setOwner(long id, Object owner) throws SessionExpiredException;</span><br><span class="line">    void dumpSessions(PrintWriter pwriter);</span><br><span class="line">    Map&lt;Long, Set&lt;Long&gt;&gt; getSessionExpiryMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionTracker</code> 中的<code>Session</code> 这个接口，相对于 <code>Web</code> 中的 <code>Session</code>, 其功能是很弱的，感觉仅仅标记了一个 <code>Session</code> 而已。在查看资料时，发现如下的一个状态图:</p><center><img src="/pics/Zookeeper-Session-Status.jpg" alt=""></center><p>其它的状态没什么可以说的，但是需要注意 <code>CONNECTING</code> 与 <code>CONNECTED</code> 之间存在相互转换的过程，在如下的情况下 <code>Session</code> 将被关闭:</p><ol><li>登录的认证失败</li><li>客户端手动关闭</li><li>连接成功后，由于客户端的操作，导致 <code>Session</code> 过期，此时将重新进入 <code>CONNECTING</code>，在重新连接服务的过程中，连接失败，或者连接成功后，收到了 <code>Session</code> 过期的消息</li></ol><p>在<code>Zookeeper</code> 中的 <code>ClientCnxn</code> 用于负责客户端与服务器的连接、数据传输的相关操作，<code>Session</code> 的创建与关闭都将从该接口相关。</p><h3 id="1-_Session_的创建">1. <code>Session</code> 的创建</h3><p><code>ClientCnxn</code>的构建函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">        ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">        long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line">    eventThread = new EventThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到会创建两个线程: <code>SendThread</code> 、<code>EventThread</code>，<code>SendThread</code> 用于负责与服务器的连接操作、心跳、数据传输，而 <code>EventThread</code> 负责处理事件。其<code>SendThread</code> 的 <code>run</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">clientCnxnSocket.updateNow();</span><br><span class="line">clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">int to;</span><br><span class="line">long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">while (state.isAlive()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">// don&apos;t re-establish connection if we are closing</span><br><span class="line">if (closing) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">startConnect();</span><br><span class="line">clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        // ...</span><br><span class="line">&#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>startConnect</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void startConnect() throws IOException &#123;</span><br><span class="line">    // ... 获取地址等信息</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只看 <code>ClientCnxnSocketNIO</code> 的实现，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void connect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line">    SocketChannel sock = createSock();</span><br><span class="line">    try &#123;</span><br><span class="line">       registerAndConnect(sock, addr);</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;Unable to open socket to &quot; + addr);</span><br><span class="line">        sock.close();</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>registerAndConnect</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void registerAndConnect(SocketChannel sock, InetSocketAddress addr)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    boolean immediateConnect = sock.connect(addr);</span><br><span class="line">    if (immediateConnect) &#123;</span><br><span class="line">        sendThread.primeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>register</code> 是 <code>Java NIO</code> 中的 <code>Selector</code> 的相关操作；其 <code>primeConnection</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * Setup session, previous watches, authentication.</span><br><span class="line"> */</span><br><span class="line">void primeConnection() throws IOException &#123;</span><br><span class="line">long sessId = (seenRwServerBefore) ? sessionId : 0;</span><br><span class="line">    ConnectRequest conReq = new ConnectRequest(0, lastZxid,</span><br><span class="line">            sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">// …… 针对 watch 和 auth 相关的处理</span><br><span class="line">    outgoingQueue.addFirst(new Packet(null, null, conReq,</span><br><span class="line">                    null, null, readOnly));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起了一个连接请求。接下来，我们来看看服务器收到请求后，是如何处理的。在 <code>Zookeeper</code> 中 <code>ZookeeperServer</code> 代表着服务器，在其中有这样一个函数: <code>processConnectRequest</code> ，通过其名字，能够发现，是用于处理客户端的连接的，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    // ... 做校验</span><br><span class="line">    int sessionTimeout = connReq.getTimeOut();</span><br><span class="line">    byte passwd[] = connReq.getPasswd();</span><br><span class="line">    int minSessionTimeout = getMinSessionTimeout();</span><br><span class="line">    if (sessionTimeout &lt; minSessionTimeout) &#123;</span><br><span class="line">        sessionTimeout = minSessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSessionTimeout = getMaxSessionTimeout();</span><br><span class="line">    if (sessionTimeout &gt; maxSessionTimeout) &#123;</span><br><span class="line">        sessionTimeout = maxSessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">    cnxn.setSessionTimeout(sessionTimeout);</span><br><span class="line">    // We don&apos;t want to receive any packets until we are sure that the session is setup</span><br><span class="line">    cnxn.disableRecv();</span><br><span class="line">    long sessionId = connReq.getSessionId();</span><br><span class="line">    if (sessionId == 0) &#123;</span><br><span class="line">        LOG.info(&quot;Client attempting to establish new session at &quot;</span><br><span class="line">                + cnxn.getRemoteSocketAddress());</span><br><span class="line">        createSession(cnxn, passwd, sessionTimeout);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long clientSessionId = connReq.getSessionId();</span><br><span class="line">        LOG.info(&quot;Client attempting to renew session 0x&quot;</span><br><span class="line">                + Long.toHexString(clientSessionId)</span><br><span class="line">                + &quot; at &quot; + cnxn.getRemoteSocketAddress());</span><br><span class="line">        if (serverCnxnFactory != null) &#123;</span><br><span class="line">            serverCnxnFactory.closeSession(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        if (secureServerCnxnFactory != null) &#123;</span><br><span class="line">            secureServerCnxnFactory.closeSession(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        cnxn.setSessionId(sessionId);</span><br><span class="line">        reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>reopenSession</code> 与 <code>Session</code> 重连相关，在这里，我们只看 <code>createSession</code> 函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">long createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;</span><br><span class="line">    if (passwd == null) &#123;</span><br><span class="line">        // Possible since it&apos;s just deserialized from a packet on the wire.</span><br><span class="line">        passwd = new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">    long sessionId = sessionTracker.createSession(timeout);</span><br><span class="line">    Random r = new Random(sessionId ^ superSecret);</span><br><span class="line">    r.nextBytes(passwd);</span><br><span class="line">    ByteBuffer to = ByteBuffer.allocate(4);</span><br><span class="line">    to.putInt(timeout);</span><br><span class="line">    cnxn.setSessionId(sessionId);</span><br><span class="line">    Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);</span><br><span class="line">    setLocalSessionFlag(si);</span><br><span class="line">    submitRequest(si);</span><br><span class="line">    return sessionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>SessionTrackerImpl</code> 的 <code>createSession</code> 就创建了 <code>Session</code> ，而 <code>submitRequest</code> 则是将请求，提交到队列中，通过 <code>RequestProcessor</code> 去处理。在 <code>PrepRequestProcessor</code> 是该处理链的第一个，它是这样处理的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">request.setHdr(null);</span><br><span class="line">request.setTxn(null);</span><br><span class="line">try &#123;</span><br><span class="line">switch (request.type) &#123;</span><br><span class="line">//create/close session don&apos;t require request record</span><br><span class="line">case OpCode.createSession:</span><br><span class="line">case OpCode.closeSession:</span><br><span class="line">if (!request.isLocalSession()) &#123;</span><br><span class="line">pRequest2Txn(request.type, zks.getNextZxid(), request,</span><br><span class="line"> null, true);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">request.zxid = zks.getZxid();</span><br><span class="line">nextProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>pRequest2Txn</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                                Record record, boolean deserialize)</span><br><span class="line">        throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">switch (type) &#123;</span><br><span class="line">case OpCode.createSession:</span><br><span class="line">request.request.rewind();</span><br><span class="line">int to = request.request.getInt();</span><br><span class="line">request.setTxn(new CreateSessionTxn(to));</span><br><span class="line">request.request.rewind();</span><br><span class="line">if (request.isLocalSession()) &#123;</span><br><span class="line">zks.sessionTracker.addSession(request.sessionId, to);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zks.sessionTracker.addGlobalSession(request.sessionId, to);</span><br><span class="line">&#125;</span><br><span class="line">zks.setOwner(request.sessionId, request.getOwner());</span><br><span class="line">break;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个 创建<code>Session</code> 的请求，然后让 <code>nextProcessor</code> 去处理，而 <code>nextProcessor</code> 指的是 <code>SyncRequestProcessor</code>，其代码主要的逻辑是负责 <code>Request</code> 的序列化，或者做整个的 <code>DataTree</code> 与 <code>Session</code> 的快照。当 <code>SyncRequestProcessor</code> 处理完后，会由 <code>FinalRequestProcessor</code> 接着处理,其处理 <code>Session</code> 的主要的逻辑代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case OpCode.createSession: &#123;</span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line"></span><br><span class="line">    lastOp = &quot;SESS&quot;;</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">            request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    zks.finishSessionInit(request.cnxn, true);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>finishSessionInit</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void finishSessionInit(ServerCnxn cnxn, boolean valid) &#123;</span><br><span class="line">// cnxn 的 JMX 注册</span><br><span class="line">try &#123;</span><br><span class="line">ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout()</span><br><span class="line">: 0, valid ? cnxn.getSessionId() : 0, // send 0 if session is no</span><br><span class="line">// longer valid</span><br><span class="line">valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);</span><br><span class="line">// ... 创建 NIO buf</span><br><span class="line">cnxn.sendBuffer(bb);</span><br><span class="line">if (valid) &#123;</span><br><span class="line">LOG.info(&quot;Established session 0x&quot;</span><br><span class="line">+ Long.toHexString(cnxn.getSessionId())</span><br><span class="line">+ &quot; with negotiated timeout &quot; + cnxn.getSessionTimeout()</span><br><span class="line">+ &quot; for client &quot;</span><br><span class="line">+ cnxn.getRemoteSocketAddress());</span><br><span class="line">cnxn.enableRecv();</span><br><span class="line">&#125;</span><br><span class="line">        // ... else</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOG.warn(&quot;Exception while establishing session, closing&quot;, e);</span><br><span class="line">cnxn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码注意一下 <code>generatePasswd</code> 这个方法，这个是重连的关键。至此，服务器完成了对 <code>Session</code> 的创建。再看看，客户端当接受到 <code>ConnectResponse</code> 消息后，是如何处理的，具体逻辑在 <code>ClientCnxnSocketNIO</code> 中的<code>doIO</code> 逻辑中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">      throws InterruptedException, IOException &#123;</span><br><span class="line">SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">if (sock == null) &#123;</span><br><span class="line">throw new IOException(&quot;Socket is null!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (sockKey.isReadable()) &#123;</span><br><span class="line">    // ...</span><br><span class="line">if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">incomingBuffer.flip();</span><br><span class="line">if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">recvCount++;</span><br><span class="line">readLength();</span><br><span class="line">&#125; else if (!initialized) &#123;</span><br><span class="line">readConnectResult();</span><br><span class="line">enableRead();</span><br><span class="line">// ...</span><br><span class="line">initialized = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键是 <code>readConnectResult</code> 的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void readConnectResult() throws IOException &#123;</span><br><span class="line">ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">ConnectResponse conRsp = new ConnectResponse();</span><br><span class="line">conRsp.deserialize(bbia, &quot;connect&quot;);</span><br><span class="line">boolean isRO = false;</span><br><span class="line">try &#123;</span><br><span class="line">isRO = bbia.readBool(&quot;readOnly&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">this.sessionId = conRsp.getSessionId();</span><br><span class="line">sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,</span><br><span class="line">conRsp.getPasswd(), isRO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化连接的请求，并记录 <code>SessionId</code>，并调用 <code>onConnected</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void onConnected(int _negotiatedSessionTimeout, long _sessionId,</span><br><span class="line">byte[] _sessionPasswd, boolean isRO) throws IOException &#123;</span><br><span class="line">negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">// .. 协商 Session 超时时间</span><br><span class="line">readTimeout = negotiatedSessionTimeout * 2 / 3;</span><br><span class="line">connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">hostProvider.onConnected();</span><br><span class="line">sessionId = _sessionId;</span><br><span class="line">sessionPasswd = _sessionPasswd;</span><br><span class="line">state = (isRO) ? States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">seenRwServerBefore |= !isRO;</span><br><span class="line">KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据得到的 <code>Session</code> 超时时间，初始化客户端的一些参数，并发起一个 <code>Watcher.Event.EventType.None</code> 的事件通知，表明连接成功。至此连接建立完成。同时在服务器创建了 <code>Session</code>。</p><h3 id="2-_Session_的关闭">2. Session 的关闭</h3><p>在 <code>zookeeper</code> 的 <code>close</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        RequestHeader h = new RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.closeSession);</span><br><span class="line">        submitRequest(h, null, null, null);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // ignore, close the send/event threads</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起了一个关闭的请求，我们在 <code>PrepRequestProcessor</code> 的 <code>pRequest2Txn</code> 方法中能看到相应的处理操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">case OpCode.closeSession:</span><br><span class="line">    Set&lt;String&gt; es = zks.getZKDatabase().getEphemerals(request.sessionId);</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        for (ChangeRecord c : zks.outstandingChanges) &#123;</span><br><span class="line">            if (c.stat == null) &#123;</span><br><span class="line">                // Doing a delete</span><br><span class="line">                es.remove(c.path);</span><br><span class="line">            &#125; else if (c.stat.getEphemeralOwner() == request.sessionId) &#123;</span><br><span class="line">                es.add(c.path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String path2Delete : es) &#123;</span><br><span class="line">            addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));</span><br><span class="line">        &#125;</span><br><span class="line">        zks.sessionTracker.setSessionClosing(request.sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG.info(&quot;Processed session termination for sessionid: 0x&quot;</span><br><span class="line">            + Long.toHexString(request.sessionId));</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>会将相应的 <code>Session</code> 的 <code>isClosing</code> 属性设置为 <code>true</code>。接下来将由 <code>SessionExpire</code> 去处理，我们只需要去看 <code>ZookeeperServer</code> 中的处理即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void expire(Session session) &#123;</span><br><span class="line">    long sessionId = session.getSessionId();</span><br><span class="line">    LOG.info(&quot;Expiring session 0x&quot; + Long.toHexString(sessionId)</span><br><span class="line">            + &quot;, timeout of &quot; + session.getTimeout() + &quot;ms exceeded&quot;);</span><br><span class="line">    close(sessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>close</code> 函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void close(long sessionId) &#123;</span><br><span class="line">    Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);</span><br><span class="line">    setLocalSessionFlag(si);</span><br><span class="line">    submitRequest(si);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又会重新走一次上面的流程，但是不一样的在 <code>SyncRequestProcessor</code> 的 <code>queuedRequests</code> 将又会多一条的数据，因为 <code>SyncRequestProcessor</code> 其本身也是 <code>Thread</code> ，在其 <code>run</code> 有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Request si = null;</span><br><span class="line">if (toFlush.isEmpty()) &#123;</span><br><span class="line">    si = queuedRequests.take();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    si = queuedRequests.poll();</span><br><span class="line">    if (si == null) &#123;</span><br><span class="line">        flush(toFlush);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用其 <code>fluash</code> 方法，其代码中有如下的代码段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request i = toFlush.remove();</span><br><span class="line">if (nextProcessor != null) &#123;</span><br><span class="line">    nextProcessor.processRequest(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会调用 <code>FinalRequestProcessor</code> 的 <code>processRequest</code> 方法，最终会调用到 <code>ZookeeperServer</code> 中的 <code>processTxn</code> 函数，其关键代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionTracker.removeSession(sessionId);</span><br></pre></td></tr></table></figure><p>会调用 <code>SessionTrackerImpl</code> 中的 <code>removeSession</code>，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void removeSession(long sessionId) &#123;</span><br><span class="line">    SessionImpl s = sessionsById.remove(sessionId);</span><br><span class="line">    sessionsWithTimeout.remove(sessionId);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        sessionExpiryQueue.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从内存中移除对应的 <code>Session</code> ，并调用 <code>ExpiryQueue</code> 中的 <code>remove</code> 方法，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Long remove(E elem) &#123;</span><br><span class="line">    Long expiryTime = elemMap.remove(elem);</span><br><span class="line">    if (expiryTime != null) &#123;</span><br><span class="line">        Set&lt;E&gt; set = expiryMap.get(expiryTime);</span><br><span class="line">        if (set != null) &#123;</span><br><span class="line">            set.remove(elem);</span><br><span class="line">            // We don&apos;t need to worry about removing empty sets,</span><br><span class="line">            // they&apos;ll eventually be removed when they expire.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return expiryTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Source codes analysis </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MAC配置及问题修复</title>
      <link href="/Tools/Tools/MAC%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
      <url>/Tools/Tools/MAC%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
      <content type="html"><![CDATA[<h3 id="1-_mac安装brew">1. mac安装brew</h3><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><h3 id="2-_mac安装lrzsz">2. mac安装lrzsz</h3><ol><li><code>brew install lrzsz</code></li><li><code>git clone https://github.com/mmastrac/iterm2-zmodem</code></li><li>将 <code>iterm2-zmodem</code> 中的 <code>iterm2-send-zmodem.sh</code> 和 <code>iterm2-recv-zmodem.sh</code> 放到 <code>/usr/local/bin</code> 路径下，并为其添加执行权限 <code>sudo chmod +x iterm2*.sh</code></li><li><p>打开item2的 <code>Preferences</code> -&gt; <code>Profiles</code> 选项卡 -&gt; <code>Advanced</code> -&gt; <code>Triggers</code> ，点击 <code>Edit</code><br>添加两个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t1:</span><br><span class="line">Regular expression: \*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">t2:</span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">arameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><p><code>Regular expression</code> 、 <code>Action</code> 、 <code>Parameters</code> 为列名，注意与页面对应</p></li></ol><h3 id="3-_Mac_安装软件时，提示已损坏解决">3. Mac 安装软件时，提示已损坏解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><h3 id="4-_iTerm2的常用配置">4. iTerm2的常用配置</h3><ol><li><p>安装Oh my zsh<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装<code>PowerLine</code><br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">pip install powerline-status --user</span><br></pre></td></tr></table></figure></li><li><p>安装PowerFonts<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/powerline/fonts.git --depth=1</span><br><span class="line">cd fonts</span><br><span class="line"></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p> 然后选择<code>Meslo LG S for Powerline</code>字体</p></li><li><p>切换到主题<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译~/.zshrc，ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装高亮插件<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><pre><code>将<span class="escape">`z</span>sh-syntax-highlighting<span class="escape">`，</span>放在<span class="escape">`p</span>lugins<span class="escape">`的</span>最后</code></pre><ol start="6"><li><p>安装命令补全<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p> 将<code>zsh-autosuggestions</code>放在<code>zshrc</code>的<code>plugins</code>选项的倒数第二个</p></li></ol><h3 id="5-_Alfred的自定义命令端">5. Alfred的自定义命令端</h3><p><code>alfred</code>打开<code>iTerm</code>，并执行命令，通过设置<code>custom</code>，然后复制以下的脚本就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">    tell application &quot;iTerm&quot;</span><br><span class="line">        set _length to count window</span><br><span class="line">    if _length = 0 then</span><br><span class="line">        create window with default profile</span><br><span class="line">    end if</span><br><span class="line">    set aa to (get miniaturized of current window)</span><br><span class="line">    if aa then</span><br><span class="line">        set miniaturized of current window to false</span><br><span class="line">    end if</span><br><span class="line">    set bb to (get visible of current window)</span><br><span class="line">    if bb is false then</span><br><span class="line">        set visible of current window to true</span><br><span class="line">    end if</span><br><span class="line">    set cc to frontmost</span><br><span class="line">    if cc is false then</span><br><span class="line">        activate</span><br><span class="line">    end if</span><br><span class="line">        (*if _length = 0 then*)</span><br><span class="line">            set theResult to current tab of current window</span><br><span class="line">        (*else</span><br><span class="line">            set theResult to (create tab with default profile) of current window</span><br><span class="line">        end if*)</span><br><span class="line">        write session of theResult text q</span><br><span class="line">end tell</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Intellij Idea</title>
      <link href="/Tools/Tools/Intellij-Idea/"/>
      <url>/Tools/Tools/Intellij-Idea/</url>
      <content type="html"><![CDATA[<h3 id="1-_设置编码格式">1. 设置编码格式</h3><ul><li>设置IDE编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; IDE Encoding， 设置成UTF-8</li><li>设置Project编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; Project Encoding， 设置成UTF-8</li><li>设置properties编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; <code>Default encoding for properties files</code>， 设置成GB2312</li><li>安装中文字体<ul><li><code>下载SimSun字体</code></li><li><code>sudo mv simsun.ttc simsun.ttf /usr/share/fonts/zh_CN/TrueType/simsun</code></li><li><code>sudo fc-cache -fv</code></li></ul></li></ul><h3 id="2-_取消单行的fold">2. 取消单行的fold</h3><ul><li>Settings –&gt; Editor –&gt; Code Folding –&gt; One-Line methods</li><li>取消选择</li></ul><h3 id="3-_给Intellij_IDE_添加_serialVersionUID">3. 给Intellij IDE 添加 serialVersionUID</h3><ol><li><code>Setting -&gt; Inspections -&gt; Serialization issues -&gt; 勾上 Serializable class without ’serialVersionUID’</code></li><li>将光标定位到类名上，按 <code>Alt + Enter</code> 就会提示自动创建 serialVersionUID</li></ol><h3 id="4-_让Intellij_idea_支持_lua">4. 让Intellij idea 支持 lua</h3><p>下载 <code>https://plugins.jetbrains.com/plugin/5055-lua</code> ，然后从磁盘安装插件</p><h3 id="5-_Linux_下_Intellij_idea_提示_Unable_to_open_debugger_port">5. Linux 下 Intellij idea 提示 <code>Unable to open debugger port</code></h3><p>提示: <code>Unable to open debugger port : java.net.SocketException “Socket closed”</code><br>方案: 将 <code>TOMCAT</code> 的 <code>Bin</code> 目录里面的所有的 <code>.sh</code> 添加执行权限，<code>sudo chmod +x *.sh</code></p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Intellij Idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git</title>
      <link href="/Tools/Tools/Git/"/>
      <url>/Tools/Tools/Git/</url>
      <content type="html"><![CDATA[<h3 id="0-_Git术语">0. Git术语</h3><ul><li>Head<br>指向当前活跃分支</li><li>origin<br>是默的远程版本库的代称</li><li>工作区<br>指在某目录下的所有操作，都将被记录或者感知</li><li>暂存区<br>stage或者index，用于记录此时的工作目录与上次的提交之间的更改</li></ul><h3 id="1-_Git中文乱码">1. Git中文乱码</h3><p><code>git config --global core.quotepath false</code></p><h3 id="2-_配置快捷方式">2. 配置快捷方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status   // st 就代表 status</span><br><span class="line">git config --global alias.ci commit   // st 就代表 commit</span><br></pre></td></tr></table></figure><h3 id="3-_git_revert_与_git_reset_区别">3. git revert 与 git reset 区别</h3><ul><li><p>git revert</p><p>通过生成一个新的提交来撤销之前的提交，但是之前的commit会被保留</p></li><li><p>git reset</p><p>回到某一次commit，该commit之后的commit会被放到暂存区或者直接删除，取决于模式，有如下模式:</p><ul><li><code>hard</code>: 强行把当前的head指针指向某一次的commit，并且之后的commit会清空（仅在本地）</li><li><code>soft</code>: 把当前的head指针指向某一次的commit，并把之后的commit放入到暂存区</li></ul></li></ul><h3 id="4-_fast_foward_VS_no_fast_foward">4. fast foward VS no fast foward</h3><p>通常合并会产生一个 <code>merge commit</code>，但是决不绝对的，取决于不同的merge模式，有如下两种模式:</p><ul><li><code>fast foward</code>: 在没有任何的冲突时， 将不会产生 <code>merge commit</code></li><li><code>no fast foward</code>: 无论什么情况都会生成 <code>merge commit</code></li></ul><p><code>git merge</code> 默认是 <code>fast foward</code>，如果需要<code>no fast foward</code>的话，则需要加上 <code>--no-ff</code></p><h3 id="5-_git_merge_与_git_rebase的区别及其使用场景">5. git merge 与 git rebase的区别及其使用场景</h3><p>区别:</p><ol><li><code>git merge</code> 会创建一个<code>merge commit</code>，并且分别指向合并前的两个分支</li><li><code>git rebase</code> 不会创建一个 <code>merge commit</code>, 而是将两个分支的提交合并成一个线性的提交；其原理是先将一个分支相对于另一个分支所有提交缓存，然后将其更新到最新，然后再应用这缓存中的提交</li></ol><p><code>git rebase</code> 有一个黄金规则，即不能 <code>rebase</code> 一个公共的分支，会导致分支混乱，所以 <code>git rebase</code> 通常用在仅仅由某一个人开发的分支上，<code>git merge</code>用在共享分支上。</p><p><a href="https://segmentfault.com/a/1190000005937408" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005937408</a> 对此有详细的解释</p><h3 id="6-_git生成密钥">6. git生成密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@xx.com&quot;</span><br></pre></td></tr></table></figure><p>然后连续输入三个空格就好</p><h3 id="7-_-ignore文件的语法规则">7. <code>.ignore</code>文件的语法规则</h3><ul><li>空行和以 <code>＃</code> 开始行会被忽略</li><li>可使用通配符<ul><li><code>*</code>，代表任意多个字符</li><li><code>?</code>，代表一个字符</li><li>方括号 ([abc])，代表可选字符范围</li><li>大括号（{string1,string2,…}）代表可选的字符串</li></ul></li><li>名称前有一个感叹号(!)，表示例外规则，将不被忽略</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ul><p>常用的例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释行，将被忽略</span><br><span class="line">*.a       # 忽略所有以.a为扩展名的文件    </span><br><span class="line">!lib.a    # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略</span><br><span class="line">/TODO     # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略</span><br><span class="line">build/    # 忽略所有build目录下的目录，但如果是名为build的文件则不忽略</span><br><span class="line">doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略</span><br></pre></td></tr></table></figure><h3 id="8-_Git多帐户ssh登陆">8. Git多帐户ssh登陆</h3><p>问题:</p><p>在实际情况，会遇到这样的问题，假如我有两个帐号，分别是 github， coding的帐号，而且这两个帐号都有自己的公钥和私钥，而默认情况下 <code>ssh</code> 命令只会去读 <code>.ssh</code> 目录下的 <code>id_rsa</code> 这个私钥，但是我们现在有两个私钥。所以我们期望能够自动识别服务器地址，然后选择相应的私钥文件。</p><p>方案:</p><p>在 <code>~/.ssh/config</code>进行配置，没有的话新建一个格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host 名称</span><br><span class="line">HostName 主机名</span><br><span class="line">User 登录的用户名</span><br><span class="line">IdentityFile 证书文件路径</span><br></pre></td></tr></table></figure><p>其它字段，可以通过<code>man ssh_config</code>来查看</p><h3 id="9-_Git的cherry-pick">9. Git的<code>cherry-pick</code></h3><p>用于将另一个分支的部分<code>commit</code>合并到当前分支。命令如下:</p><p><code>git cherry-pick hash</code>，此处的<code>hash</code>为另一个分支的<code>commit</code>的<code>hash</code>值。</p><h3 id="10-_Git的bisect">10. Git的<code>bisect</code></h3><p>用于快速定位异常的<code>commit</code>。</p><p>场景:</p><p>假如有1，2，3，4这4个提交，此时你发现项目运行不起来，但是需要定位是哪一个commit导致的系统异常，此时可以用<code>bisect</code>，它采用一种二分搜索的方式去搜索。例如commit4不能运行，那就将commit4设置为<code>bad</code>，假设我回滚到commit1后，项目可以运行，那么就将commit1设置为<code>good</code>，针对1～4之间的提交，采用二分搜索的方式，能够准确定位。</p><p>其命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开始</span><br><span class="line">git bisect start</span><br><span class="line"></span><br><span class="line"># 标记当前Head所指向的提交，是错误的</span><br><span class="line">git bisect bad</span><br><span class="line"></span><br><span class="line"># 将某一个提交设置成good，一般在初始化时，需要设置</span><br><span class="line">git bisect good your_commit_hash</span><br><span class="line"></span><br><span class="line"># 标记当前Head所指向的提交，是正常的</span><br><span class="line">git bisect good</span><br><span class="line"></span><br><span class="line"># 结束，并且将Head指向最新提交</span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>首先须要执行<code>start</code>命令，再执行<code>bad</code>和<code>good</code>命令，最后如果找出异常的commit，则<code>reset</code></p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu配置及问题修复</title>
      <link href="/Tools/Tools/Ubuntu%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
      <url>/Tools/Tools/Ubuntu%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
      <content type="html"><![CDATA[<h3 id="1-_系统设置中_language_support_消失">1. 系统设置中 <code>language support</code> 消失</h3><p>在 <code>synaptick</code> 中安装 <code>language-selector-gnome</code>，这个软件与 <code>im-switch</code> 这个是冲突的，所以在安装 <code>im-switch</code> 后，它会将这一个软件删除，所以在系统的选项中将不会显示，只要再安装一次就可，但是这个软件也会删除 <code>im-switch</code></p><h3 id="2-_系统选项中很多图标消失">2. 系统选项中很多图标消失</h3><p>安装 <code>unity-control-center</code> 就可以恢复了</p><h3 id="3-_在VirtualBox中安装Xp系统时的问题：">3. 在VirtualBox中安装Xp系统时的问题：</h3><ol><li>安装Xp系统后提示”init 8, init failure”<br>表示你的系统中没有一个磁盘，是设置为主作为区，在PQ中，在转换中，可以将一个硬盘转换成“主作为区”</li><li>安装Xp，启动时，出现蓝屏，一直不能进入，并且提示”prossor.sys错误”<br>在PE中安装完Xp后不要马上启动系统，进入到C:\WINDOWS\system32\drivers下，并找到processr.sys这个文件，将这个文件更名processr.sys.old</li><li>安装完Xp，不能使用笔记本集成的摄像头<br>在VirtualBox的官网上下载对应你的型号的扩展包，然后打开VirtualBox，在 “管理” –&gt; “全局选项” –&gt; “扩展” –&gt; 选择你的扩展包就可以安装了，重新启动就可以</li><li>出现Wine System Tray, 在切换到gnome classic，通知区域不见了，WineQQ，会显示一个 <code>Wine System Tray</code>，这表明通知区域没有被显示出来。解决步骤如下：<ol><li>在顶部的信息栏中上的空白处 Win+Alt+鼠标右键,选择“添加到面板“</li><li>在其中找到 “通知区域”</li><li>点击下面的“添加”即可</li></ol></li></ol><h3 id="4-_“Virtual_machine_‘Centos’_has_terminated_unexpectedly_during_startup”">4. “Virtual machine ‘Centos’ has terminated unexpectedly during startup”</h3><p>是因为 <code>vboxdrv</code> 没有加载， 执行 <code>sudo /etc/init.d/vboxdrv setup</code></p><h3 id="5-_用户不在sudoers文件中的解决方法">5. 用户不在sudoers文件中的解决方法</h3><ol><li>切换到root用户权限<br><code>su root</code></li><li>查看/etc/sudoers文件权限，如果只读权限，修改为可写权限<br><code>chmod 777 /etc/sudoers</code></li><li>编辑 <code>/etc/sudoers</code> 文件，添加要提升权限的用户<br>找到 <code>root ALL=(ALL) ALL</code> 这一行，并在其下面加上一行:<br>  <code>user ALL=(ALL) ALL</code><br>说明：格式为（用户名 网络中的主机=(执行命令的目标用户) 执行的命令范围）</li><li>并恢复 <code>/etc/sudoers</code> 的访问权限为 <code>440</code><br><code>chmod 440 /etc/sudoers</code></li><li>切换到普通用户，测试用户权限提升功能</li></ol><h3 id="6-_Ubuntu_连接局域网共享">6. Ubuntu 连接局域网共享</h3><ol><li><p>安装samba</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br><span class="line">sudo apt-get install cifs-utils</span><br></pre></td></tr></table></figure></li><li><p>挂载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs -o username=anonymous,password=&apos;&apos; //192.168.2.253/xxxx/ ~/public-files</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-_双系统Ubuntu无法进入Windows磁盘的解决方法">7. 双系统Ubuntu无法进入Windows磁盘的解决方法</h3><ol><li>输入命令检测 ntfs-3g 是否已经安装： <code>locate ntfs-3g</code>, 否则就执行 <code>sudo apt-get install ntfs-3g</code></li><li>sudo ntfsfix /dev/sda6  # /dev/sda6 为需要修复的盘符</li></ol><h3 id="8-_win10和Ubuntu16-04双系统下时间不对的问题">8. win10和Ubuntu16.04双系统下时间不对的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br></pre></td></tr></table></figure><h3 id="9-_运行openProj时，提示_Your_Java_vendor_is_“Oracle_Corporation”-_To_run_OpenProj,_you_need_the_Sun_Java_implementation-The_auto-detected_Java_Runtime_used_is-">9. 运行openProj时，提示 Your Java vendor is “Oracle Corporation”. To run OpenProj, you need the Sun Java implementation.The auto-detected Java Runtime used is..</h3><p>将 <code>$HOME/.openproj/run.conf and</code> 从 <code>JAVA_OPTS=&quot;-Xms128m -Xmx768m&quot;</code> 改成 <code>JAVA_OPTS=&quot;-Djava.vendor=Sun -Xms128m -Xmx768m&quot;</code></p><h3 id="10-_安装爱壁纸时，提示_python-support找不到">10. 安装爱壁纸时，提示 python-support找不到</h3><ul><li><code>wget http://launchpadlibrarian.net/109052632/python-support_1.0.15_all.deb</code></li><li><code>sudo dpkg -i python-support_1.0.15_all.deb</code></li><li><code>sudo apt-get install -f</code></li></ul><p>然后再执行 <code>sudo dpkg -i xxx.deb</code></p><h3 id="11-_Ubuntu设置静态地址">11. Ubuntu设置静态地址</h3><ol><li><p>找到文件并作如下修改：</p><p><code>sudo vim /etc/network/interfaces</code></p><p> 修改如下部分：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto eth0                # 注意eth0，是你对应的网卡</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.0.117    # 地址</span><br><span class="line">gateway 192.168.0.1      # 网关</span><br><span class="line">netmask 255.255.255.0    # 掩码</span><br><span class="line">network 192.168.0.0      # 网络号</span><br><span class="line">broadcast 192.168.0.255  # 广播地址</span><br></pre></td></tr></table></figure></li><li><p>修改dns解析，因为之前是<code>dhcp</code>，会自动分配dns，现在需要手动配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. sudo vim /etc/resolv.conf</span><br><span class="line">2. 百度的dns</span><br><span class="line">   nameserver 180.76.76.76</span><br></pre></td></tr></table></figure></li><li><p>重启网卡<br><code>sudo /etc/init.d/networking restart</code></p></li></ol><h3 id="12-_Win8使用XShell连接Ubuntu">12. Win8使用XShell连接Ubuntu</h3><p>需要在 <code>VirtualBox</code> 设置两个网卡，分别是 <code>NAT</code> 和 <code>桥接</code>, <code>NAT</code>是为了能够让虚拟机上网，而 <code>桥接</code> 是为了让主机能够连接上虚拟机</p><h3 id="13-_配置字体">13. 配置字体</h3><p>将 windows 下的字体拷贝出来，放到Ubuntu的 <code>/usr/share/fonts/windows-fonts</code>，然后运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache -fv</span><br></pre></td></tr></table></figure><ul><li>命令成功后会提示 <code>fc-cache: succeeded</code></li><li><code>windows-fonts</code> 这是自己建的目录，命令会自己去扫描</li></ul><h3 id="14-_设置快捷方式">14. 设置快捷方式</h3><p>在 Ubuntu 中所有的快捷方式都在 <code>/usr/share/applications</code> 目录下，会存在很多 <code>.desktop</code>文件，如果需要自己建立一个通过双击就能运行的程序，就必须创建一个快捷方式，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=DrClient</span><br><span class="line">Comment=DrClient</span><br><span class="line">Exec=/home/haiyang/DrClient/DrClientLinux</span><br><span class="line">Icon=/home/haiyang/DrClient/icon.xpm</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=true</span><br><span class="line">Categories=Accessibility;Utility;</span><br><span class="line">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure><p>其它的用法，可以参考其它的快捷方式去创建</p><h3 id="15-_便笺工具">15. 便笺工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:umang/indicator-stickynotes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-stickynotes</span><br></pre></td></tr></table></figure><h3 id="16-_Ubuntu_16-04_阿里云源">16. Ubuntu 16.04 阿里云源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">##测试版源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"># 源码</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">##测试版源</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="17-_系统错误报告屏蔽">17. 系统错误报告屏蔽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/crash/*</span><br><span class="line">sudo vim /etc/default/apport</span><br></pre></td></tr></table></figure><p>将 <code>enabled</code> 设置为 <code>0</code></p><h3 id="18-_无法显示桌面">18. 无法显示桌面</h3><p>重装桌面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall ubuntu-desktop</span><br></pre></td></tr></table></figure><p>特别强调一下，尽量不要去删 Ubuntu 自带的软件，不要使用 <strong>Ubuntu商店</strong></p><h3 id="19-_zsh_提示_no_match_found_XX">19. zsh 提示 <code>no match found XX</code></h3><p>在 <code>~/.zshrc</code> 中加入 <code>setopt no_nomatch</code> 再 <code>source</code> 一下就好</p><h3 id="20-_Ubuntu_16-04_提示_the_system_is_running_in_low-graphics_mode">20. Ubuntu 16.04 提示 <code>the system is running in low-graphics mode</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + F1</span><br><span class="line">sudo add-apt-repository ppa:ubuntu-x-swat/updates</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="21-_修改_grub_的字体大小">21. 修改 grub 的字体大小</h3><p><code>http://forum.ubuntu.com.cn/viewtopic.php?f=139&amp;t=348988</code></p><h3 id="22-_Ubuntu_16-04出现：Problem_executing_scripts_APT::Update::Post-Invoke-Success_‘if_/usr/bin/test_-w_/var/cache/app-info_-a_-e_/usr/bin/appstreamcli;_then_appstreamcli_refresh_&gt;_/dev/null;_fi’">22. Ubuntu 16.04出现：Problem executing scripts APT::Update::Post-Invoke-Success ‘if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi’</h3><p>执行如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -KILL appstreamcli</span><br><span class="line">wget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.deb</span><br><span class="line">sudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure></p><p>再次执行 <code>sudo apt-get update</code> 就好了</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chrome</title>
      <link href="/Tools/Tools/Chrome/"/>
      <url>/Tools/Tools/Chrome/</url>
      <content type="html"><![CDATA[<h3 id="1-_无法安装插件">1. 无法安装插件</h3><ul><li>问题<br>给Chrome安装插件时，提示“只能通过Chrome网上应用店添加该程序。”</li><li>解决方案<ul><li>把下载后的.crx扩展名的离线Chrome插件的文件扩展名改成为.zip或者.rar，然后解压</li><li>将文件夹下的”_metadata”文件夹签名为“metadata”</li><li>然后在Chrome的扩展程序下，开启“开发者模式”</li><li>选择“加载正在开发的扩展程序”</li></ul></li></ul><p>不能删除解压后的目录，否则，下次启动Chrome时，插件就消失了</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos配置及问题修复</title>
      <link href="/Tools/Tools/Centos%E9%85%8D%E7%BD%AE/"/>
      <url>/Tools/Tools/Centos%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="1-_更新源">1. 更新源</h3><ol><li>首先备份<br><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li><li>进入yum源配置文件所在文件夹<br><code>cd /etc/yum.repos.d/</code></li><li>下载163的yum源配置文件，放入 <code>/etc/yum.repos.d/</code><br><code>wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</code></li><li>生成缓存<br><code>yum makecache</code></li><li>更新系统<br><code>yum -y update</code></li></ol><h3 id="2-_多网卡配置静态IP">2. 多网卡配置静态IP</h3><ul><li>在<code>/etc/sysconfig/network-scripts/</code>目录下</li><li>在当前目录，根据你的网卡数，创建n个<code>ifcfg-ethX</code>个文件</li><li><p>配置每一个<code>ifcfg-ethX</code>文件，主要内容如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0                 //指出设备名称</span><br><span class="line">BOOTPROT=static             //启动类型 dhcp|static</span><br><span class="line">BROADCAST=192.168.1.203     //广播地址</span><br><span class="line">HWADDR=00:06:5B:FE:DF:7C    //硬件Mac地址</span><br><span class="line">IPADDR=192.168.0.2          //IP地址</span><br><span class="line">NETMASK=255.255.255.0       //子网掩码</span><br><span class="line">NETWORK=192.168.0.0         //网络地址</span><br><span class="line">GATEWAY=192.168.0.1         //网关地址</span><br><span class="line">ONBOOT=yes                  //是否启动应用</span><br></pre></td></tr></table></figure></li><li><p>重启网络服务<br><code>service network restart</code></p></li></ul><h3 id="3-_Centos最小化安装后，无法连网？">3. Centos最小化安装后，无法连网？</h3><ul><li>执行<code>dhclient eth0</code></li><li>修改<code>etc/sysconfig/network-scripts/ifcfg-eth0</code>文件，将<code>ONBOOT=no改为ONBOOT=yes</code></li></ul>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Linux </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Archlinux配置及问题修复</title>
      <link href="/Tools/Tools/Archlinux%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
      <url>/Tools/Tools/Archlinux%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
      <content type="html"><![CDATA[<h3 id="1-_安装yaourt">1. 安装yaourt</h3><ol><li>概念：<ol><li>Yaourt, <code>Yet AnOther User Repository Tool</code>，是社区贡献的一个pacman的一个外壳。</li><li>yaourt的安装方式是编译安装</li><li>AUR, <code>Arch Linux User-Community Repository</code>, 社区用户软件仓库</li></ol></li><li><p>安装</p><ol><li>安装依赖包<br>pacman -S base-devel</li><li><p>安装package-query</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://aur.archlinux.org/packages/pa/package-query/package-query.tar.gz</span><br><span class="line">tar zxvf package-query.tar.gz</span><br><span class="line">cd package-query</span><br><span class="line">makepkg -si</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>安装yaourt</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://aur.archlinux.org/packages/ya/yaourt/yaourt.tar.gz</span><br><span class="line">tar zxvf yaourt.tar.gz</span><br><span class="line">cd yaourt</span><br><span class="line">makepkg -si</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2-_安装ibus五笔输入法">2. 安装ibus五笔输入法</h3><ol><li>安装ibus框架<br><code>pacman -S ibus ibus-table ibus-table-chinese</code></li><li><p>在bash中配置ibus的启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. vim .bashrc</span><br><span class="line">2.</span><br><span class="line">   export GTK_IM_MODULE=ibus</span><br><span class="line">   export XMODIFIERS=@im=ibus</span><br><span class="line">   export QT_IM_MODULE=ibus</span><br></pre></td></tr></table></figure></li><li><p>后台启动ibus的守护进程<br><code>ibus-daemon -drx</code></p></li><li>添加五笔<br><code>ibus-setup --&gt; 汉语 --&gt; 极点五笔</code></li><li>重启ibus<br><code>ibus restart</code></li></ol><h3 id="3-_Xfce4中文设置">3. Xfce4中文设置</h3><ol><li><p>加载中文设置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. vim /etc/locale.gen</span><br><span class="line">2. 将zh_CN.UTF-8 UTF-8的注释去掉</span><br><span class="line">3. locale-gen</span><br></pre></td></tr></table></figure></li><li><p>修改语言</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. cd</span><br><span class="line">2. vim .bash_profile</span><br><span class="line">3. 在末尾加上：</span><br><span class="line">  export LANG=zh_CN.UTF-8</span><br><span class="line">  export LANGUAGE=zh_CN.UTF-8</span><br><span class="line">  export LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-_安装字体">4. 安装字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S wqy-microhei tf-arphic-ukai、ttf-arphic-uming</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Archlinux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro-05-在Shiro中是如何实现独立的Session</title>
      <link href="/Shiro/Shiro/Shiro-05-%E5%9C%A8Shiro%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8B%AC%E7%AB%8B%E7%9A%84Session/"/>
      <url>/Shiro/Shiro/Shiro-05-%E5%9C%A8Shiro%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8B%AC%E7%AB%8B%E7%9A%84Session/</url>
      <content type="html"><![CDATA[<h3 id="0-_引入">0. 引入</h3><p><code>Shiro</code> 对其 <code>Session</code> 管理是这样描述的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use a Session API in any environment, even without web or EJB containers.</span><br></pre></td></tr></table></figure></p><p>能够将 <code>Session</code> 应用到任意一个环境上，而不仅仅在 <code>Web</code> 和 <code>EJB containers</code>，这就引起我的一个好奇，那么它是如何做的呢？在之前，我们也曾分析过 <code>Shiro</code> 的登录、登出及创建，接下来我们将再次从这个角度去分析 <code>Shiro</code> 中的 <code>Session</code>，及其整个生命周期。在分析之前，我很好奇 <code>HttpSession</code> 与 <code>Shiro</code> 内部的 <code>Session</code> 会有什么区别呢，下面只展示其接口:</p><ol><li><p><code>HttpSession</code>:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public interface HttpSession &#123;</span><br><span class="line">public long getCreationTime();</span><br><span class="line">      public String getId();</span><br><span class="line">      public long getLastAccessedTime();</span><br><span class="line">      public ServletContext getServletContext();</span><br><span class="line">      public void setMaxInactiveInterval(int interval);</span><br><span class="line">      public int getMaxInactiveInterval();</span><br><span class="line">      public HttpSessionContext getSessionContext();</span><br><span class="line">      public Object getAttribute(String name);</span><br><span class="line">      public Object getValue(String name);</span><br><span class="line">      public Enumeration&lt;String&gt; getAttributeNames();</span><br><span class="line">      public String[] getValueNames();</span><br><span class="line">      public void setAttribute(String name, Object value);</span><br><span class="line">      public void putValue(String name, Object value);</span><br><span class="line">      public void removeAttribute(String name);</span><br><span class="line">      public void removeValue(String name);</span><br><span class="line">      public void invalidate();</span><br><span class="line">      public boolean isNew();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Shiro</code> 的 <code>Session</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Session &#123;</span><br><span class="line">Serializable getId();</span><br><span class="line">    Date getStartTimestamp();</span><br><span class="line">    Date getLastAccessTime();</span><br><span class="line">    long getTimeout() throws InvalidSessionException;</span><br><span class="line">    void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException;</span><br><span class="line">    String getHost();</span><br><span class="line">    void touch() throws InvalidSessionException;</span><br><span class="line">    void stop() throws InvalidSessionException;</span><br><span class="line">    Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException;</span><br><span class="line">    Object getAttribute(Object key) throws InvalidSessionException;</span><br><span class="line">    void setAttribute(Object key, Object value) throws InvalidSessionException;</span><br><span class="line">    Object removeAttribute(Object key) throws InvalidSessionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>粗略一看还是有一定的区别。</p><h3 id="1-_在_Web_环境下登录与非_Web_环境下登录其_Session_有什么区别呢？">1. 在 <code>Web</code> 环境下登录与非 <code>Web</code> 环境下登录其 <code>Session</code> 有什么区别呢？</h3><h4 id="1-1_在非Web_环境下登录，此时_Session_的创建过程？">1.1 在非<code>Web</code> 环境下登录，此时 <code>Session</code> 的创建过程？</h4><p>直接看 <code>DefaultSecurityManager</code> 的 <code>getSession()</code> 方法，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SessionContext sessionContext = createSessionContext();</span><br><span class="line">Session session = this.securityManager.start(sessionContext);</span><br><span class="line">this.session = decorate(session);</span><br></pre></td></tr></table></figure><p>省略了很多代码，比较关键的是这三行代码。</p><ul><li>第一行代码，创建了 <code>SessionContext</code> ，其本质是一个 <code>Map</code>，其中针对需要存储的对象，设置了一个固定的 <code>Key</code>;</li><li>第三行代码，仅仅包装了一下创建出来的 <code>Session</code></li><li>第二行代码，真正创建 <code>Session</code></li></ul><p>在创建过程中，会经过 <code>DefaultSecurityManager</code> 转到 <code>DefaultSessionManager</code>，然后再转到 <code>AbstractNativeSessionManager</code> 的 <code>start</code> 方法，其方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Session start(SessionContext context) &#123;</span><br><span class="line">    Session session = createSession(context);</span><br><span class="line">    applyGlobalSessionTimeout(session);</span><br><span class="line">    onStart(session, context);</span><br><span class="line">    notifyStart(session);</span><br><span class="line">    //Don&apos;t expose the EIS-tier Session object to the client-tier:</span><br><span class="line">    return createExposedSession(session, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要分析 <code>createSession</code> 这个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext context) throws AuthorizationException &#123;</span><br><span class="line">    enableSessionValidationIfNecessary();</span><br><span class="line">    return doCreateSession(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enableSessionValidationIfNecessary</code> 配置一个线程池去定期清理过期的 <code>Session</code>, <code>doCreateSession</code> 对应到 <code>DefaultSessionManager</code> ，方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Session doCreateSession(SessionContext context) &#123;</span><br><span class="line">    Session s = newSessionInstance(context);</span><br><span class="line">    if (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(&quot;Creating session for host &#123;&#125;&quot;, s.getHost());</span><br><span class="line">    &#125;</span><br><span class="line">    create(s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>create(s)</code> 仅仅是缓存创建的 <code>Session</code>，其默认实现为 <code>MemorySessionDAO</code> 的 <code>doCreate</code> 方法，其通过 <code>UUID</code> 生成 <code>SessionId</code>  然后，将 <code>SessionId</code> 为 <code>key</code>, <code>Session</code> 为值，放到一个 <code>ConcurrentMap</code> 中；而 <code>newSessionInstance</code> 具体是由 <code>SimpleSessionFactory</code> 的 <code>createSession</code> 去执行，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Session createSession(SessionContext initData) &#123;</span><br><span class="line">    if (initData != null) &#123;</span><br><span class="line">        String host = initData.getHost();</span><br><span class="line">        if (host != null) &#123;</span><br><span class="line">            return new SimpleSession(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅就是简单地 <code>new</code> 了一个 <code>SimpleSession</code> 对象而已。那么如何判断一个非认证的用户在同一个 <code>Session</code> 呢，因为在 <code>Web</code> 环境中，就算一个用户没有通过认证，但是我们能够通过其 <code>Cookie</code> 判断其在同一个 <code>Session</code> 中。</p><h4 id="1-2_在_Web_环境下登录，此时_Session_的创建过程？">1.2 在 <code>Web</code> 环境下登录，此时 <code>Session</code> 的创建过程？</h4><p>此时创建 <code>Session</code> 的过程与非 <code>Web</code> 环境的创建 <code>Session</code> 的过程比较一致，大的区别在于 <code>WebDelegatingSubject</code> 和 <code>ServletContainerSessionManager</code>， 在 <code>WebDelegatingSubject</code> 可以看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected SessionContext createSessionContext() &#123;</span><br><span class="line">    WebSessionContext wsc = new DefaultWebSessionContext();</span><br><span class="line">    String host = getHost();</span><br><span class="line">    if (StringUtils.hasText(host)) &#123;</span><br><span class="line">        wsc.setHost(host);</span><br><span class="line">    &#125;</span><br><span class="line">    wsc.setServletRequest(this.servletRequest);</span><br><span class="line">    wsc.setServletResponse(this.servletResponse);</span><br><span class="line">    return wsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法中，会将 <code>ServletRequest</code> 与 <code>ServletResponse</code> 放入到 <code>WebSessionContext</code> 中； 在 <code>ServletContainerSessionManager</code> 中看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext sessionContext) throws AuthorizationException &#123;</span><br><span class="line">    if (!WebUtils.isHttp(sessionContext)) &#123;</span><br><span class="line">        String msg = &quot;SessionContext must be an HTTP compatible implementation.&quot;;</span><br><span class="line">        throw new IllegalArgumentException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    HttpServletRequest request = WebUtils.getHttpRequest(sessionContext);</span><br><span class="line">    HttpSession httpSession = request.getSession();</span><br><span class="line">    String host = getHost(sessionContext);</span><br><span class="line">    return createSession(httpSession, host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，可以看到在先从 <code>ServletRequest</code> 中获取 <code>HttpSession</code>，然后通过 <code>createSession</code> 包装原始的 <code>HttpSession</code>。其 <code>createSession</code> 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(HttpSession httpSession, String host) &#123;</span><br><span class="line">    return new HttpServletSession(httpSession, host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装成了一个 <code>HttpServletSession</code> (<code>Shiro</code> 的内部对象)。在此过程无缓存。</p><h4 id="1-3_在登录过程中_Web_环境与_非_Web_环境的_Session_创建的比较">1.3 在登录过程中 <code>Web</code> 环境与 非 <code>Web</code> 环境的 <code>Session</code> 创建的比较</h4><ol><li>在 <code>Web</code> 环境下，包装 <code>HttpSession</code> 成 <code>Shiro</code> 的内部对象 <code>HttpServletSession</code>，无缓存，也无须去管理定时去清理 <code>Session</code> 的问题，这些问题，会由容器去处理</li><li>在 非<code>Web</code> 环境下，创建 <code>SimpleSession</code> 对象，能够为每一个访问者提供一个类似于 <code>Web</code> 容器的 <code>Session</code> 的功能，并且通过 <code>SessionDao</code> 缓存对象，并且创建线程池定期清理过期的 <code>Session</code> 对象</li></ol><p>通过对上面的分析，大家可能对 <code>Session</code> 有一个粗略的理解，但是我认为想要完全地达到 <code>Web</code> 容器的 <code>Session</code> 的功能，必须要解决掉，如何唯一标识一个用户(可能已经认证，可以非认证)</p><h3 id="2-_登出的过程_Web_环境与非_Web_环境的_Session_销毁有什么区别？">2. 登出的过程 <code>Web</code> 环境与非 <code>Web</code> 环境的 <code>Session</code> 销毁有什么区别？</h3><p>因为 <code>DelegatingSubject</code>、<code>DefaultSecurityManager</code> 与 <code>WebDelegatingSubject</code>、<code>DefaultWebSecurityManager</code> 这四个类，分别代表非 <code>Web</code> 及 <code>Web</code> 环境。在通过比较两个 <code>logout</code> 方法时，能够发现，有区别的仅仅是在 <code>DefaultSecurityManager</code> 与 <code>DefaultWebSecurityManager</code> 的 <code>beforeLogout</code> 方法，而 <code>DefaultWebSecurityManager</code> 又继承自 <code>DefaultSecurityManager</code>，在<code>DefaultWebSecurityManager</code> 可以看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void beforeLogout(Subject subject) &#123;</span><br><span class="line">    super.beforeLogout(subject);</span><br><span class="line">    removeRequestIdentity(subject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void removeRequestIdentity(Subject subject) &#123;</span><br><span class="line">    if (subject instanceof WebSubject) &#123;</span><br><span class="line">        WebSubject webSubject = (WebSubject) subject;</span><br><span class="line">        ServletRequest request = webSubject.getServletRequest();</span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会调用父类的 <code>beforeLogout</code> 方法，而它的父类则为 <code>DefaultSecurityManager</code>，所以区别在于 <code>removeRequestIdentity</code> 方法，在该方法中，仅仅看到的是在 <code>ServletRequest</code> 添加了一个 <code>ShiroHttpServletRequest.IDENTITY_REMOVED_KEY</code>。</p><h3 id="3-_该如何做_Session_的同步呢？">3. 该如何做 <code>Session</code> 的同步呢？</h3>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Source codes analysis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro 与 Spring集成</title>
      <link href="/Shiro/Shiro/Shiro%E4%B8%8ESpring%E9%9B%86%E6%88%90/"/>
      <url>/Shiro/Shiro/Shiro%E4%B8%8ESpring%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<h3 id="0-_基础概念">0. 基础概念</h3><p>在整个Shiro框架中， <code>SecurityManager</code> 是整个框架的核心，它会去协调内部的调用关系，<code>Subject</code> 代表所有的请求发起者，通常只需要通过 <code>Subject</code> 进行登录与登出操作，然后实现自己的 <code>Realm</code> 去实现认证与授权就可以了</p><h3 id="1-_与Spring的集成">1. 与Spring的集成</h3><ol><li><p>引入 maven 的依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 此处省略了版本号，当然是引入最新的版本就好</p></li><li><p>配置 Shiro 的过滤器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p> <code>DelegatingFilterProxy</code> 就不用多解释了，会在Spring容器中去找到一个名为 <code>shiroFilter</code> 的过滤器，并且用该<code>Filter</code>过滤所有的访问请求。</p></li><li><p>配置Spring容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;realm&quot; ref=&quot;shiroDbRealm&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定的Realm--&gt;</span><br><span class="line">   &lt;bean id=&quot;shiroDbRealm&quot; class=&quot;xx.xxx.ShiroDbRealm&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;successUrl&quot; value=&quot;/home&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">           &lt;value&gt;</span><br><span class="line">               /static/** = anon</span><br><span class="line">               /** = user</span><br><span class="line">           &lt;/value&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;shiroEhcacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache-shiro.xml&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">       &lt;constructor-arg value=&quot;rememberMe&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;rememberMeManager&quot;</span><br><span class="line">         class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;cipherKey&quot; value=&quot;#&#123;T(org.apache.shiro.codec.Base64).decode(&apos;4AvVhmFLUs0KTA3Kprsdag==&apos;)&#125;&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><code>shiroFilter</code> 就是 <code>Web.xml</code> 中配置所需要的Bean，因为 Shiro 的核心是 <code>securityManager</code>，其它的几个Bean，大多数都是为了SecurityManager 所准备的，而 <code>lifecycleBeanPostProcessor</code> 会自动去调 Shiro 特定 Bean 的初始化与destroy方法。</p></li><li><p>登录与登出操作</p><ol><li><p>登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username</span><br><span class="line">                , password, isRememberMe;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">try &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; catch (AuthenticationException e) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>登出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">if (currentUser.isAuthenticated() || currentUser.isRemembered())&#123;</span><br><span class="line">    currentUser.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro-01-简介</title>
      <link href="/Shiro/Shiro/Shiro-01-%E7%AE%80%E4%BB%8B/"/>
      <url>/Shiro/Shiro/Shiro-01-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>Apache Shiro 是一个强大、灵活的安全框架，提供认证、授权、Session管理和加密服务。其构架如下:</p><center><img src="/pics/ShiroArchitecture.png" alt=""></center><p>涉及到如下的几个核心概念:</p><ol><li>Subject<br>代表任意的请求发起方，可以是浏览器、爬</li><li>SecurityManager<br>是Shiro框架的核心，负责Shiro内部组件的协调，以保证整个功能的正确性</li><li>Authenticator<br>认证器，负责校验访问者的身份</li><li>Authorizer<br>授权器，用于确认访问者的权限，每一个访问，都需要得到Authorizer的认可后，才可以访问</li><li>Session Manager<br>负责 Session 的管理</li><li>Cache Manager<br>缓存管理，对Shiro框架中所有需要使用到的缓存的地方提供支持</li><li>Session Dao<br>对 Session 进行存储</li><li>Realm<br>通常根据用户的需求去定制，负责用户身份的认证与权限鉴别</li><li>Cryptography<br>加密服务</li><li>principals<br>即主体的标识属性，通常是用户名，需要保持其唯一性，可以存在多个principals，但是只有一个Primary principals</li><li>credentials<br>即只有Subject才知道的安全值，如密码/数字证书</li></ol><h3 id="1-_源码包的目录简介">1. 源码包的目录简介</h3><center><img src="/pics/Shiro源码目录.png" alt=""></center><ol><li>all<br>打包</li><li>cache<br>Shiro 对于缓存的封装</li><li>config<br>用于解析配置文件， 支持 Ini 和 OGDL 方式</li><li>core<br>Shiro 的核心逻辑</li><li>crypto<br>加密模板，提供了对 JCA 的支持</li><li>event<br>事件机制的封装</li><li>integration-tests、test-coverage<br>测试</li><li>lang<br>各个模板都会用到的类</li><li>samples<br>例子</li><li>support<br>提供了一些常用的支持</li><li>tools</li><li>web<br>提供对 Web 的支持</li></ol><h3 id="2-_会通过如下的角度去分析Shiro框架">2. 会通过如下的角度去分析Shiro框架</h3><ol><li>通过Ini文件的方式，分析登录、登出的过程</li><li>Shiro的框架结构</li><li>如何与Spring集成</li><li>在Shiro中是如何实现独立的Session</li></ol>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Source codes analysis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro-02-Ini配置下的登录、登出</title>
      <link href="/Shiro/Shiro/Shiro-02-Ini%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA/"/>
      <url>/Shiro/Shiro/Shiro-02-Ini%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA/</url>
      <content type="html"><![CDATA[<h3 id="0-_例子入口">0. 例子入口</h3><p>配置文件shiro.ini如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">root = secret, admin</span><br><span class="line">guest = guest, guest</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin = *</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure></p><p>源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">SecurityManager securityManager = factory.getInstance();</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line"></span><br><span class="line">if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    // 3</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    try &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (currentUser.isAuthenticated()) &#123;</span><br><span class="line">    // 表明用户已经登录</span><br><span class="line">&#125;</span><br><span class="line">// 4</span><br><span class="line">if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;</span><br><span class="line">    log.info(&quot;May the Schwartz be with you!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 5</span><br><span class="line">if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;</span><br><span class="line">    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;</span><br><span class="line">    log.info(&quot;You are permitted to &apos;drive&apos; the winnebago with license plate (id) &apos;eagle5&apos;.  &quot; +</span><br><span class="line">            &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 6</span><br><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure></p><h3 id="1-_分析">1. 分析</h3><h4 id="1-1-_步骤1，创建_SecurityManager，_并读取_shiro-ini">1.1. 步骤1，创建 SecurityManager， 并读取 <code>shiro.ini</code></h4><p>其初始化函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public IniSecurityManagerFactory() &#123;</span><br><span class="line">    this.builder = new ReflectionBuilder();</span><br><span class="line">&#125;</span><br><span class="line">public IniSecurityManagerFactory(Ini config) &#123;</span><br><span class="line">    this();</span><br><span class="line">    setIni(config);</span><br><span class="line">&#125;</span><br><span class="line">public IniSecurityManagerFactory(String iniResourcePath) &#123;</span><br><span class="line">    this(Ini.fromResourcePath(iniResourcePath));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>根据传过来的路径，生成了 Ini 对象，Ini 对象保存着 <code>shiro.ini</code> 中记录的数据，并自动在 FactoryBean 中生成了 <code>ReflectionBuilder</code>。</li><li>在 <code>getInstance</code> 这个方法中，会去调用 <code>IniSecurityManagerFactory</code> 中的 <code>createInstance</code> 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected SecurityManager createInstance(Ini ini) &#123;</span><br><span class="line">    if (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Ini argument cannot be null or empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager securityManager = createSecurityManager(ini);</span><br><span class="line">    if (securityManager == null) &#123;</span><br><span class="line">        String msg = SecurityManager.class + &quot; instance cannot be null.&quot;;</span><br><span class="line">        throw new ConfigurationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    return securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在<code>createSecurityManager</code> 方法中，创建了 <code>SecurityManager</code> 和 <code>IniRealm</code></li><li>而在 <code>ReflectionBuilder</code> 中创建了默认的 <code>DefaultEventBus</code></li><li>通过<code>ReflectionBuilder</code> 的 <code>buildObjects</code> 方法的 <code>LifecycleUtils.init(objects.values());</code> 去初始化这三个创建的类</li><li>在 <code>IniRealm</code> 的初始化 (onInit方法)过程中，会将 <code>shiro.ini</code> 中配置的user和role创建对应的 <code>SimpleAccount</code> 和 <code>SimpleRole</code>。</li><li><code>Subject currentUser = SecurityUtils.getSubject();</code> 这一行代码，会创建 Subject, SubjectContext，创建好的 Subject 将会存储在 ThreadContext 中，而 SubjectContext 用于记录在创建 Subject 中会用到的数据，如 SecurityManager、Session、Host等</li><li><p>创建 Subject 是由 <code>DefaultSubjectFactory</code> 的 <code>createSubject</code> 方法:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext context) &#123;</span><br><span class="line">    SecurityManager securityManager = context.resolveSecurityManager();</span><br><span class="line">    Session session = context.resolveSession();</span><br><span class="line">    boolean sessionCreationEnabled = context.isSessionCreationEnabled();</span><br><span class="line">    PrincipalCollection principals = context.resolvePrincipals();</span><br><span class="line">    boolean authenticated = context.resolveAuthenticated();</span><br><span class="line">    String host = context.resolveHost();</span><br><span class="line"></span><br><span class="line">    return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码会创建一个 <code>DelegatingSubject</code>，在后续的过程中，会通过SubjectDAO缓存创建的 <code>DelegatingSubject</code></p></li></ol><h4 id="1-2_步骤2,_Session">1.2 步骤2, Session</h4><p>在创建的 Session 的过程中，会调用 <code>AbstractValidatingSessionManager</code> 的 <code>createSession</code> 方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext context) throws AuthorizationException &#123;</span><br><span class="line">    enableSessionValidationIfNecessary();</span><br><span class="line">    return doCreateSession(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>会先创建 <code>SessionValidationScheduler</code>，用于定期清除过期的 Session</li><li><p>会由  <code>SimpleSessionFactory</code> 的 <code>createSession</code>方法创建 Session, 如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Session createSession(SessionContext initData) &#123;</span><br><span class="line">    if (initData != null) &#123;</span><br><span class="line">        String host = initData.getHost();</span><br><span class="line">        if (host != null) &#123;</span><br><span class="line">            return new SimpleSession(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建完成后，会通过 SessionDAO，存储到一个Map中，以作缓存</p></li><li>为了便于用户使用，而又不影响Map缓存的Session，会创建了一个 <code>DelegatingSession</code> 去包裹真实的Session</li><li>在 Subject 的层面，创建了一个 <code>StoppingAwareProxiedSession</code> ，重写了 <code>stop</code> 方法，当调用 <code>stop()</code> 方法时，会将Subject中的session置空</li></ol><h4 id="1-3_步骤3,_登录过程">1.3 步骤3, 登录过程</h4><p>会调用 <code>DelegatingSubject</code> 的 <code>login</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void login(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    Subject subject = securityManager.login(this, token);</span><br><span class="line">    // 将创建的新的 subject 的属性值放到当前 DelegatingSubject 中，因为针对外界而言，引用的是之前的那一个Subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>登录过程是委托给 <code>securityManager</code> 的 <code>login</code> 方法，</li><li>在该过程中，会调用 <code>ModularRealmAuthenticator</code> 的 <code>doAuthenticate</code> 方法，最终转到 <code>IniRealm</code> 的 <code>getAuthenticationInfo</code>，最后转到 <code>SimpleAccountRealm</code> 的 <code>doGetAuthenticationInfo</code> 方法，从而得到 <code>SimpleAccount</code> 对象，即 IniRealm 根据 <code>shiro.ini</code> 创建的对象。</li></ol><h4 id="1-4_步骤4，角色检查">1.4 步骤4，角色检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasRole(String roleIdentifier) &#123;</span><br><span class="line">    return hasPrincipals() &amp;&amp; securityManager.hasRole(getPrincipals(), roleIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是委托给 <code>securityManager</code> ，中间经过 ModularRealmAuthenticator、IniReaml，最终转到 <code>SimpleAccountRealm</code> 中进行权限的检查</p><h4 id="1-5_步骤5,_权限检查">1.5 步骤5, 权限检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPermitted(String permission) &#123;</span><br><span class="line">    return hasPrincipals() &amp;&amp; securityManager.isPermitted(getPrincipals(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与角色检查的过程类似，委托给 <code>securityManager</code> ，中间经过 ModularRealmAuthenticator、IniReaml，最终转到 <code>SimpleAccountRealm</code>，获取所有的权限对象，让权限对象自己去校验是否拥有权限</p><h4 id="1-6_步骤6,_登出">1.6 步骤6, 登出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void logout() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        clearRunAsIdentitiesInternal();</span><br><span class="line">        this.securityManager.logout(this);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        this.session = null;</span><br><span class="line">        this.principals = null;</span><br><span class="line">        this.authenticated = false;</span><br><span class="line">        //Don&apos;t set securityManager to null here - the Subject can still be</span><br><span class="line">        //used, it is just considered anonymous at this point.  The SecurityManager instance is</span><br><span class="line">        //necessary if the subject would log in again or acquire a new session.  This is in response to</span><br><span class="line">        //https://issues.apache.org/jira/browse/JSEC-22</span><br><span class="line">        //this.securityManager = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>登出的过程，同样的是委托给 <code>securityManager</code>，如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void logout(Subject subject) &#123;</span><br><span class="line"></span><br><span class="line">    if (subject == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Subject method argument cannot be null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beforeLogout(subject);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals = subject.getPrincipals();</span><br><span class="line">    if (principals != null &amp;&amp; !principals.isEmpty()) &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(&quot;Logging out subject with primary principal &#123;&#125;&quot;, principals.getPrimaryPrincipal());</span><br><span class="line">        &#125;</span><br><span class="line">        Authenticator authc = getAuthenticator();</span><br><span class="line">        if (authc instanceof LogoutAware) &#123;</span><br><span class="line">            ((LogoutAware) authc).onLogout(principals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        delete(subject);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            String msg = &quot;Unable to cleanly unbind Subject.  Ignoring (logging out).&quot;;</span><br><span class="line">            log.debug(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            stopSession(subject);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                String msg = &quot;Unable to cleanly stop Session for Subject [&quot; + subject.getPrincipal() + &quot;] &quot; +</span><br><span class="line">                        &quot;Ignoring (logging out).&quot;;</span><br><span class="line">                log.debug(msg, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>登出的过程会经过如下几个步骤:</p><ol><li>如果存在 <code>RememberMeManager</code>，则清除Cookie</li><li>通知实现了 <code>LogoutAware</code> 接口的 <code>Authenticator</code></li><li>删除缓存的 <code>Subject</code></li><li>修改 Session 的 <code>stopTimestamp</code> 字段</li></ol></li></ol><h3 id="2-_总结">2. 总结</h3><p>以下，便是以代码的角度粗略地看了一下 Shiro 框架给我们带来的些</p><ol><li>SecurityManager 代表了整个框架，而 Subject 代表了所有的访问者</li><li>只有显示调用 <code>getSession</code> 才会创建 Session</li><li>所有的认证与授权都是通过 <code>Realm</code> 实现的</li><li>在整个过程中，都会使用缓存, <code>SubjectDAO</code> 和 <code>SessionDAO</code></li></ol>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Source codes analysis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro-04-如何是与Spring集成的</title>
      <link href="/Shiro/Shiro/Shiro-04-%E5%A6%82%E4%BD%95%E6%98%AF%E4%B8%8ESpring%E9%9B%86%E6%88%90%E7%9A%84/"/>
      <url>/Shiro/Shiro/Shiro-04-%E5%A6%82%E4%BD%95%E6%98%AF%E4%B8%8ESpring%E9%9B%86%E6%88%90%E7%9A%84/</url>
      <content type="html"><![CDATA[<h3 id="0-_引入">0. 引入</h3><p>在对 <code>Shiro</code> 的使用中，更多的是用在 <code>Spring MVC</code> 中，那么 <code>Shiro</code> 是如何集成到 <code>Spring MVC</code> 中的呢？我只是先大概说明一下步骤:</p><ol><li>引用 <code>shiro-spring</code> 的maven依赖</li><li>在 <code>web.xml</code> 配置一个名为 <code>shiroFilter</code>，类为 <code>org.springframework.web.filter.DelegatingFilterProxy</code>的 Filter，拦截所有请求</li><li>在 <code>Spring</code> 容器中配置一个名为 <code>shiroFilter</code>，类为 <code>org.apache.shiro.spring.web.ShiroFilterFactoryBean</code> 的 <code>Bean</code></li><li>实现自定义的 <code>Realm</code></li><li>使用过程，使用 <code>@RequiresPermissions</code> 等注解</li></ol><p>根据以上的步骤，可以将该问题，拆分成两个小的问题:</p><ol><li>ShiroFilterFactoryBean 到底做了些什么</li><li><code>@RequiresPermissions</code> 这些注解是如何生效的</li></ol><h3 id="1-_ShiroFilterFactoryBean">1. ShiroFilterFactoryBean</h3><p>该类的属性如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private SecurityManager securityManager;</span><br><span class="line">private Map&lt;String, Filter&gt; filters;</span><br><span class="line">private Map&lt;String, String&gt; filterChainDefinitionMap;</span><br><span class="line">private String loginUrl;</span><br><span class="line">private String successUrl;</span><br><span class="line">private String unauthorizedUrl;</span><br><span class="line">private AbstractShiroFilter instance;</span><br></pre></td></tr></table></figure><p>需要解释的字段:</p><ol><li><p><code>Map&lt;String, Filter&gt; filters</code><br>在 <code>org.apache.shiro.web.filter.mgt.DefaultFilter</code> 定义了一个enum，该枚举的作用，是通过枚举的名字建立与对应的Filter的关系，此处是一个扩展点，用于建立用户自定义的名字与一个特定的Filter的关系。eg:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;filters&quot;&gt;</span><br><span class="line"> &lt;map&gt;</span><br><span class="line">  &lt;entry key=&quot;cas&quot; value-ref=&quot;casFilter&quot;/&gt;</span><br><span class="line"> &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 其默认的枚举如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anon(AnonymousFilter.class),</span><br><span class="line">authc(FormAuthenticationFilter.class),</span><br><span class="line">authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">logout(LogoutFilter.class),</span><br><span class="line">noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">port(PortFilter.class),</span><br><span class="line">rest(HttpMethodPermissionFilter.class),</span><br><span class="line">roles(RolesAuthorizationFilter.class),</span><br><span class="line">ssl(SslFilter.class),</span><br><span class="line">user(UserFilter.class);</span><br></pre></td></tr></table></figure></li><li><p><code>Map&lt;String, String&gt; filterChainDefinitionMap</code><br>设置不同的请求，所对应的Filter，路径是通过 <code>Ant</code> 匹配规则进行匹配的。eg:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">&lt;value&gt;</span><br><span class="line">/config_* = anon</span><br><span class="line">/logout = logout</span><br><span class="line">/cas/* = cas</span><br><span class="line">/** = stUser</span><br><span class="line">&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 可以使用默认定义的，也可以使用自定义的</p></li><li><code>AbstractShiroFilter instance</code><br>该 <code>FactoryBean</code> 创建的对象，是单例，所以记录创建的对象</li></ol><p>因为该类为 <code>FactoryBean</code> ，可以发现，在其 <code>getObject</code> 中会创建一个单例的 <code>SpringShiroFilter</code>, 这是一个内部类，在整个类中最核心的函数是 <code>AbstractShiroFilter createInstance() throws Exception</code>。其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractShiroFilter createInstance() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    SecurityManager securityManager = getSecurityManager();</span><br><span class="line">    if (securityManager == null) &#123;</span><br><span class="line">        String msg = &quot;SecurityManager property must be set.&quot;;</span><br><span class="line">        throw new BeanInitializationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(securityManager instanceof WebSecurityManager)) &#123;</span><br><span class="line">        String msg = &quot;The security manager does not implement the WebSecurityManager interface.&quot;;</span><br><span class="line">        throw new BeanInitializationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FilterChainManager manager = createFilterChainManager();</span><br><span class="line">    PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();</span><br><span class="line">    chainResolver.setFilterChainManager(manager);</span><br><span class="line"></span><br><span class="line">    return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码做了三件事:</p><ol><li>检查 <code>SecurityManager</code></li><li>创建 <code>FilterChainManager</code>，<code>PathMatchingFilterChainResolver</code></li><li>生成 <code>SpringShiroFilter</code> 对象</li></ol><p><code>FilterChainManager</code> 其主要的是维护一个路径与Filter的关系， <code>PathMatchingFilterChainResolver</code> 会利用 <code>AntPathMatcher</code> 去匹配请求的路径，然后调用 <code>FilterChainManager</code> 获取一个对应的Filter去拦截请求。而 <code>SpringShiroFilter</code> 是对 <code>AbstractShiroFilter</code> 的一个包装，而且该Filter拦截所有的请求，然后选择相应的Filter进行处理。（<code>ShiroFilterFactoryBean</code> 为一个 <code>FactoryBean</code>， 在反射过程中，会直接调用其 <code>getObject</code> 方法，生成 <code>SpringShiroFilter</code>）</p><h3 id="2-_如何在每一个请求中，注入_Subject_对象？">2. 如何在每一个请求中，注入 Subject 对象？</h3><p>在分析 <code>ShiroFilterFactoryBean</code> 可以发现，其最终会生成 <code>SpringShiroFilter</code>，然后根据不同的请求路径，让相应的Filter去拦截处理。但是有一个问题，不一定是每一个请求都是进入同一个线程中，那它是在什么时候，将已经认证过的 <code>Subject</code> 注入到 <code>ThreadContext</code> 对象中去的呢？查看 <code>SpringShiroFilter</code>，顺序着 <code>doFilter</code> (Filter的过滤函数)去找，发现在 <code>SpringShiroFilter</code> 的父类 <code>AbstractShiroFilter</code> 的 <code>doFilterInternal</code> 方法有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)</span><br><span class="line">        throws ServletException, IOException &#123;</span><br><span class="line">    Throwable t = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">        final ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">        final Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        subject.execute(new Callable() &#123;</span><br><span class="line">            public Object call() throws Exception &#123;</span><br><span class="line">                updateSessionLastAccessTime(request, response);</span><br><span class="line">                executeChain(request, response, chain);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略了一些代码，发现 <code>final Subject subject = createSubject(request, response);</code> 每次都会创建一个新的 <code>WebSubject</code> ，那么它是如何取得之前的登录信息呢，不能做一个全局的缓存，因为不能与某一个未认证的用户建立关系，所以有一个感觉，应该是存在于 <code>Session</code> 中,事实上也是如此。看一下 <code>DefaultSecurityManager</code> 中的 <code>Subject createSubject(SubjectContext subjectContext)</code> 方法，该方法会在 <code>login</code> 时，创建 <code>Subject</code> 时，被调用，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext subjectContext) &#123;</span><br><span class="line">    SubjectContext context = copy(subjectContext);</span><br><span class="line">    context = ensureSecurityManager(context);</span><br><span class="line">    context = resolveSession(context);</span><br><span class="line">    context = resolvePrincipals(context);</span><br><span class="line">    Subject subject = doCreateSubject(context);</span><br><span class="line">    save(subject);</span><br><span class="line">    return subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>save</code> 方法 会将认证信息放到 <code>Session</code> 中。在创建 <code>WebSubject</code> 时，会调用 <code>DefaultWebSubjectFactory</code> 去创建 <code>WebSubject</code> ，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext context) &#123;</span><br><span class="line">    if (!(context instanceof WebSubjectContext)) &#123;</span><br><span class="line">        return super.createSubject(context);</span><br><span class="line">    &#125;</span><br><span class="line">    WebSubjectContext wsc = (WebSubjectContext) context;</span><br><span class="line">    SecurityManager securityManager = wsc.resolveSecurityManager();</span><br><span class="line">    Session session = wsc.resolveSession();</span><br><span class="line">    boolean sessionEnabled = wsc.isSessionCreationEnabled();</span><br><span class="line">    PrincipalCollection principals = wsc.resolvePrincipals();</span><br><span class="line">    boolean authenticated = wsc.resolveAuthenticated();</span><br><span class="line">    String host = wsc.resolveHost();</span><br><span class="line">    ServletRequest request = wsc.resolveServletRequest();</span><br><span class="line">    ServletResponse response = wsc.resolveServletResponse();</span><br><span class="line"></span><br><span class="line">    return new WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,</span><br><span class="line">            request, response, securityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有很多的 <code>wsc.resolveXXXX</code> 这类的代码，就可以看到其在执行过程，最终会落实到从 <code>Session</code> 中取数据。最后附上所有的Filter的类关系图:</p><center><img src="/pics/Shiro-Filter.png" alt=""></center><h3 id="3-_@RequiresPermissions_这些注解是如何生效的？">3. <code>@RequiresPermissions</code> 这些注解是如何生效的？</h3><p>在 <code>Shiro</code> 对AOP提供了两种支持，一种支持 <code>AOP Alliance</code>，另一种是 <code>Shiro</code> 自己定义的AOP接口。因为在 <code>Spring</code> 中是用的 <code>AOP Alliance</code> 所定义的接口。粗略地看一下其接口，有如下几个类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Advice</span><br><span class="line">AspectException</span><br><span class="line">ConstructorInterceptor</span><br><span class="line">ConstructorInvocation</span><br><span class="line">Interceptor</span><br><span class="line">Invocation</span><br><span class="line">Joinpoint</span><br><span class="line">MethodInterceptor</span><br><span class="line">MethodInvocation</span><br></pre></td></tr></table></figure><p>针对 AOP ，此处提出了两个概念 <code>Advice</code> 和 <code>Joinpoint</code>， <code>Joinpoint</code> 代表切面的对象，<code>Advice</code> 代表对该切面点的处理。而所有的 <code>Interceptor</code> 是 <code>Advice</code>，而所有的 <code>Invocation</code> 代表 <code>Joinpoint</code>。在 <code>Shiro</code> 项目中的 <code>aspectj</code> 的模块中，有一个 <code>ShiroAnnotationAuthorizingAspect</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Aspect()</span><br><span class="line">public class ShiroAnnotationAuthorizingAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final String pointCupExpression =</span><br><span class="line">            &quot;execution(@org.apache.shiro.authz.annotation.RequiresAuthentication * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresGuest * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresPermissions * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresRoles * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresUser * *(..))&quot;;</span><br><span class="line"></span><br><span class="line">    @Pointcut(pointCupExpression)</span><br><span class="line">    public void anyShiroAnnotatedMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(pointCupExpression)</span><br><span class="line">    void anyShiroAnnotatedMethodCall(JoinPoint thisJoinPoint) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AspectjAnnotationsAuthorizingMethodInterceptor interceptor =</span><br><span class="line">            new AspectjAnnotationsAuthorizingMethodInterceptor();</span><br><span class="line"></span><br><span class="line">    @Before(&quot;anyShiroAnnotatedMethodCall(thisJoinPoint)&quot;)</span><br><span class="line">    public void executeAnnotatedMethod(JoinPoint thisJoinPoint) throws Throwable &#123;</span><br><span class="line">        interceptor.performBeforeInterception(thisJoinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我想大概应该很熟悉了，其关键点在于 <code>interceptor.performBeforeInterception(thisJoinPoint)</code> 这行代码，顺着这条线看下去，会在 <code>AnnotationsAuthorizingMethodInterceptor</code> 类里看到这样一个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException &#123;</span><br><span class="line">    //default implementation just ensures no deny votes are cast:</span><br><span class="line">    Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; aamis = getMethodInterceptors();</span><br><span class="line">    if (aamis != null &amp;&amp; !aamis.isEmpty()) &#123;</span><br><span class="line">        for (AuthorizingAnnotationMethodInterceptor aami : aamis) &#123;</span><br><span class="line">            if (aami.supports(methodInvocation)) &#123;</span><br><span class="line">                aami.assertAuthorized(methodInvocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>getMethodInterceptors()</code> 返回的是在构造函数初始化的几个 <code>Interceptor</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodInterceptors = new ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(5);</span><br><span class="line">methodInterceptors.add(new RoleAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new PermissionAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new AuthenticatedAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new UserAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new GuestAnnotationMethodInterceptor());</span><br></pre></td></tr></table></figure><p>结合上面的两段代码，再看一下这几个 <code>Interceptor</code> 我想你就能够明白了，根据其注解的类型，选择相应的 <code>Interceptor</code> 去进行处理，其处理的过程，最终会在相应的 <code>AnnotationHandler</code> 中进行处理。</p><h3 id="4-_总结">4. 总结</h3><p>以上就是通过带着问题的方式，去看 <code>Shiro</code> 如何去 <code>Spring</code> 的集成，其中省略了很多的代码，上面展示的只是看代码的一个过程，及其最终的结果，中间的步骤，需要大家根据其中的思路继续深入，才能理解在这个框架中，给我们带来的思想与灵感。</p>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Source codes analysis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shiro-03-Shiro的框架结构</title>
      <link href="/Shiro/Shiro/Shiro-03-Shiro%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84/"/>
      <url>/Shiro/Shiro/Shiro-03-Shiro%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="1-_Authenticator">1. Authenticator</h3><p>负责用户身份的认证，其接口如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Authenticator &#123;</span><br><span class="line">    public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)</span><br><span class="line">            throws AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>验证 <code>AuthenticationToken</code> 对象，如果成功则返回 <code>AuthenticationInfo</code> 对象。<code>AuthenticationToken</code> 接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationToken extends Serializable &#123;</span><br><span class="line">    Object getPrincipal();</span><br><span class="line">    Object getCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要理清两个概念： <code>Principal</code>和<code>Credentials</code>。 <code>Principal</code> 用于唯一标识用户, <code>Credentials</code> 凭证，用于表明该用户的确拥有该用户。通俗的理解就是，<code>Principal</code> 就是用户名, <code>Credentials</code> 是密码，不过在 Shiro 框架中，对用户名与密码做了抽象，它可能有多种表现形式。例如可能用户名会存在多个，密码也有可能是一个文件等等。在理解了这两个概念后，我想对于 <code>AuthenticationToken</code> 也有一定的认识了吧，它是用户输入的载体。 <code>AuthenticationInfo</code> 接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationInfo extends Serializable &#123;</span><br><span class="line">    PrincipalCollection getPrincipals();</span><br><span class="line">    Object getCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口承载的是用户登录后的，保存的认证信息，以便在应用上下文中，使用其用户名或者密码。<code>PrincipalCollection</code> 代表 <code>Principal</code> 的集合。为什么会用户名会是多个呢？在实际的情况下，可能会存在这样的情况，当一个用户用ID登录后，但是其用户名、邮箱、手机号也可以唯一标识该用户的，则可以放到该集合里。<code>Authenticator</code> 其继承关系如下:</p><center><img src="/pics/Shiro-Authenticator.png" alt=""></center><p>首先 <code>SecurityManager</code> 下面再谈; <code>AbstractAuthenticator</code> 提供了对 <code>AuthenticationListener</code> 的支持，并且实现了 <code>LogoutAware</code> 接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LogoutAware &#123;</span><br><span class="line">    public void onLogout(PrincipalCollection principals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>一旦看到 <code>Aware</code>，我们就能很自然地想到 Spring，<code>LogoutAware</code> 表明在 <code>Subject</code> 调用 <code>logout</code> 时，所有实现了 <code>LogoutAware</code> 的类，都将被调用其 <code>void onLogout(PrincipalCollection principals)</code> 方法；</li><li>通过阅读 <code>AuthenticationListener</code> 的源码，可以发现，它对 <code>Authenticator</code> 的 <code>AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException</code> 方法进行了包装，其继承类，只需要实现 <code>AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException;</code> 即可，在包装的过程，主要做了两件事，一件事，当出现异常时，通知在 <code>AbstractAuthenticator</code> 中记录的所有 <code>AuthenticationListener</code>，当成功后，通知所有 <code>AuthenticationListener</code>, 当登出，通知所有的 <code>AuthenticationListener</code>。</li></ol><p>接下来，我们再来看看 <code>ModularRealmAuthenticator</code>，在此模块中，引入了一个概念，<code>PAM</code>, <code>Pluggable Authentication Module</code>，可插拔式认证模块，这是一个Linux下的概念，即多模块认证的方式。现实情况下，也的确有这样的需求，例如，我即可以通过ID登录，也可以通过手机登录，邮箱登录都是可以的。但是这同时又会引入一个新的策略类 <code>AuthenticationStrategy</code>，它提供了一个策略，在多个 <code>Realm</code> 同时认证时，什么情况下，才认为用户是认证成功的，是必须所有的 <code>Realm</code> 都认证成功，还是仅仅只有一个 <code>Realm</code> 认证成功就可以，等等。</p><h3 id="2-_Authorizer">2. Authorizer</h3><p>负责对已经登录的用户进行授权，其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Authorizer &#123;</span><br><span class="line">    boolean isPermitted(PrincipalCollection principals, String permission);</span><br><span class="line">    boolean isPermitted(PrincipalCollection subjectPrincipal, Permission permission);</span><br><span class="line">    boolean[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line">    boolean[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions);</span><br><span class="line">    boolean isPermittedAll(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line">    boolean isPermittedAll(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions);</span><br><span class="line">    void checkPermission(PrincipalCollection subjectPrincipal, String permission) throws AuthorizationException;</span><br><span class="line">    void checkPermission(PrincipalCollection subjectPrincipal, Permission permission) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(PrincipalCollection subjectPrincipal, String... permissions) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions) throws AuthorizationException;</span><br><span class="line"></span><br><span class="line">    boolean hasRole(PrincipalCollection subjectPrincipal, String roleIdentifier);</span><br><span class="line">    boolean[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers);</span><br><span class="line">    boolean hasAllRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers);</span><br><span class="line">    void checkRole(PrincipalCollection subjectPrincipal, String roleIdentifier) throws AuthorizationException;</span><br><span class="line">    void checkRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;</span><br><span class="line">    void checkRoles(PrincipalCollection subjectPrincipal, String... roleIdentifiers) throws AuthorizationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过其接口，我们也能看出来，主要提供对权限和角色的验证，这觉得这一块的东西，是没必要多做解释的，在Shiro框架中，角色与权限都需要用户自己去定义。其继承关系如下:</p><center><img src="/pics/Shiro-Authorizer.png" alt=""></center><p>虽然其实现类，很多，但是这些不过是针对具体的协议下的不同做法而已。</p><h3 id="3-_Realm">3. Realm</h3><p>其英文名字是 <code>范围、领域</code> 的意思，其主要的功能是获取用户认证信息与授权数据，与数据源是一对一的关系。其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Realm &#123;</span><br><span class="line">    String getName();</span><br><span class="line">    boolean supports(AuthenticationToken token);</span><br><span class="line">    AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>String getName();</code> 为该 <code>Realm</code> 取一个唯一的名字</li><li><code>boolean supports(AuthenticationToken token);</code> 判断当前 <code>Realm</code> 是否支持当前用户的输入</li><li><code>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code> 用户的认证信息</li></ol><p>其继承关系如下:</p><center><img src="/pics/Shiro-Realm.png" alt=""></center><ol><li><code>CachingRealm</code><br>提供对缓存的支持, 在其中注入了 <code>CacheManager</code>，添加了一些常用的方法</li><li><code>AuthenticatingRealm</code><br>对 <code>Authenticator</code> 的支持， 将 <code>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code> 包装成了 <code>AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code>，并将缓存的操作，集成到了 <code>getAuthenticationInfo</code> 这个方法里。缓存的key为 <code>AuthenticationToken.getPrincipal</code> 其值为 <code>AuthenticationInfo</code></li><li><code>AuthorizingRealm</code> 对 <code>Authorizer</code> 的支持<br>除了实现 <code>Authorizer</code> 的方法外，还对外抛出了 <code>AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)</code> 这个待实现的接口，该是被 <code>AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals)</code> 这个方法包装的，在包装的过程，将顶层的 <code>CachingRealm</code> 集成了进来。通过其命名就能看到 <code>getAuthorizationInfo</code> 是与 <code>AuthenticatingRealm</code> 的 <code>getAuthenticationInfo</code> 同一级的函数。缓存的key为 <code>PrincipalCollection</code>， 而值为 <code>AuthorizationInfo</code></li></ol><p>剩下的类，都是针对具体的协议，没必要去分析。通过其继承关系，我们可以明白 <code>Realm</code>，其实代表了认证与授权的数据，理所当然也就应该实现 <code>Authenticator</code> 和 <code>Authorizer</code>，为了提高性能，都采取了缓存的方式。</p><h3 id="4-_SecurityManager">4. SecurityManager</h3><p>在之前也曾提及到，<code>SecurityManger</code> 代表着整个框架，它会自动去协议内部对象。其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface SecurityManager extends Authenticator, Authorizer, SessionManager &#123;</span><br><span class="line">    Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;</span><br><span class="line">    void logout(Subject subject);</span><br><span class="line">    Subject createSubject(SubjectContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个最顶层的类，代表着一个 <code>SecurityManager</code> 所应具体的功能，可以看到主要涉及到三个方面: 认证、授权、Session管理，而这三个方面，不正是 Shiro 所在做的事吗。其 <code>login</code> 、<code>logout</code>、<code>createSubject</code> 则是外界的行为，如果通读源码的话，会发现，Subject的行为，会被委托给 <code>SecurityManager</code>，而且必须委托给 <code>SecurityManager</code>。我认为可以从 <code>Shiro</code> 框架对 <code>SecurityManager</code> 以及对 <code>Subject</code> 的定位进行分析，<code>SecurityManager</code> 代表着 <code>Shiro</code>，而 <code>Subject</code> 代表所有的访问者，不可能把所有的内部对象都放到 <code>Subject</code> 中去吧，而且 <code>Shiro</code> 肯定得对外提供 <code>login</code> 和 <code>logout</code> 接口。</p><center><img src="/pics/Shiro-SecurityManager.png" alt=""></center><p>通过其继承关系，可以明了，<code>SecurityManager</code> 走了两条线，一条是普通的 <code>SecurityManager</code> 而另一条线则是提供了对 Web 的支持。对 Web 的支持暂时不分析。</p><ol><li>CachingSecurityManager<br>提供了对 <code>EventBus</code> 与 <code>CacheManager</code> 的注入方法</li><li>RealmSecurityManager<br>提供了对 <code>Collection&lt;Realm&gt;</code> 的注入</li><li>AuthenticatingSecurityManager<br>提供了对 <code>Authenticator</code> 的注入，默认为 <code>ModularRealmAuthenticator</code></li><li>AuthorizingSecurityManager<br>提供了对 <code>authorizer</code> 的注入，默认为 <code>ModularRealmAuthorizer</code></li><li>SessionSecurityManager<br>提供了对 <code>SessionManager</code> 的注入，默认为 <code>DefaultSessionManager</code></li><li>DefaultSecurityManager<br>提供了对 <code>RememberMeManager</code>、 <code>SubjectDAO</code>、<code>SubjectFactory</code> 的注入，<code>RememberMeManager</code> 需要外界注入，而 <code>SubjectDAO</code>、<code>SubjectFactory</code> 如果外界没有设置的话，默认为 <code>DefaultSubjectDAO</code> 和 <code>DefaultSubjectFactory</code>。很多逻辑都在该类里面。</li></ol><h3 id="5-_Subject">5. Subject</h3><p><code>Subject</code> 代表着所有的外部访问者，其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">// 用户常见的调用</span><br><span class="line">    Object getPrincipal();</span><br><span class="line">    PrincipalCollection getPrincipals();</span><br><span class="line">    void login(AuthenticationToken token) throws AuthenticationException;</span><br><span class="line">    void logout();</span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line">    boolean isRemembered();</span><br><span class="line"></span><br><span class="line">    // Session的创建</span><br><span class="line">    Session getSession();</span><br><span class="line">    Session getSession(boolean create);</span><br><span class="line"></span><br><span class="line">    // 权限与角色的判断</span><br><span class="line">    boolean isPermitted(String permission);</span><br><span class="line">    boolean isPermitted(Permission permission);</span><br><span class="line">    boolean[] isPermitted(String... permissions);</span><br><span class="line">    boolean[] isPermitted(List&lt;Permission&gt; permissions);</span><br><span class="line">    boolean isPermittedAll(String... permissions);</span><br><span class="line">    boolean isPermittedAll(Collection&lt;Permission&gt; permissions);</span><br><span class="line">    void checkPermission(String permission) throws AuthorizationException;</span><br><span class="line">    void checkPermission(Permission permission) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(String... permissions) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;</span><br><span class="line">    boolean hasRole(String roleIdentifier);</span><br><span class="line">    boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);</span><br><span class="line">    boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);</span><br><span class="line">    void checkRole(String roleIdentifier) throws AuthorizationException;</span><br><span class="line">    void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;</span><br><span class="line">    void checkRoles(String... roleIdentifiers) throws AuthorizationException;</span><br><span class="line"></span><br><span class="line">// 异步执行</span><br><span class="line">    &lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;</span><br><span class="line">    void execute(Runnable runnable);</span><br><span class="line">    &lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);</span><br><span class="line">    Runnable associateWith(Runnable runnable);</span><br><span class="line"></span><br><span class="line">// runAs</span><br><span class="line">    void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;</span><br><span class="line">    boolean isRunAs();</span><br><span class="line">    PrincipalCollection getPreviousPrincipals();</span><br><span class="line">    PrincipalCollection releaseRunAs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Subject</code> 中还有一个 <code>Builder</code>，与分析 <code>Subject</code> 无关，所以省略。<code>Subject</code> 代表着访问者，即其中的方法，则为访问者的行为，初步一看，其实和 <code>SecurityManager</code> 碾平后的代码相似度比较高。其行为主要分为如下几类:</p><ol><li>登录、登出、判断是否登录，是否记住，获取用户名</li><li>Session的获取与创建</li><li>权限与角色的判断</li><li>异步执行</li><li>runAs</li></ol><p>前三个主要是委托给 <code>SecurityManager</code> 去做，异步执行与runAs，则是 <code>Subject</code> 去实现，默认实现在 <code>DelegatingSubject</code> 中。</p><h3 id="5-_总结">5. 总结</h3><p>零零碎碎地讲了很多，主要是明确主要的几个组件之间的相互关系，及其职责，其中还有很多可以去分析，比如其对缓存的封装，事件的分析，对加密算法的封装，AOP，接下来会从它是如何去Spring去集成和其独立的Session到底是怎么一回事的角度去分析。</p>]]></content>
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> Source codes analysis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSL Pining</title>
      <link href="/Security/Security/SSL%20Pining/"/>
      <url>/Security/Security/SSL%20Pining/</url>
      <content type="html"><![CDATA[<ol start="0"><li><p>背景<br>很多Mobile App默认会选择使用 SSL 来进行网络通信，但是在这种情况下，依然不能保证数据不被窃听。IOS上SSL连接默认是在Client与Server建立一个连接，Server返回其SSL证书，如果这个证书是被信任的证书机构签发，那么这个连接就能正常进行，随后交换 Session Key进行通信。如果攻击者使用中间人攻击，利用 Charles 或者 Mitmproxy，Mobile Device很可能也会信任攻击者的证书，从而暴露请求数据、地址等信息。</p></li><li><p>ssl pining<br>通过把 Server 的 SSL 证书捆绑到程序中，每次请求时，Client能够把 Server 的证书和一个已知的 Server 证书的拷贝做对比，从而确保证书来源的可信，避免了数据被窃听。在IOS中一般通过 AFNetworking 去设置。</p></li></ol>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL/TLS </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDoS</title>
      <link href="/Security/Security/DDoS/"/>
      <url>/Security/Security/DDoS/</url>
      <content type="html"><![CDATA[<h2 id="一-_DDoS攻击">一. DDoS攻击</h2><p>DDoS攻击(分布式拒绝服务攻击), 是拒绝服务(DoS)的一种，用分布式的客户端，向服务提供者发起大量看似合法的请求，消耗或长期占用大量资源，从而达到拒绝服务的目的。</p><h2 id="二-_攻击方式">二. 攻击方式</h2><h4 id="1-_消耗网络宽带资源：">1. 消耗网络宽带资源：</h4><p>互联网基础设施的数据包处理能力都是存在上限的，攻击者发送大量网络数据包，使正常请求无法得到正常. 有效的响应，造成服务拒绝。  </p><ol><li>直接攻击：使用大量受控主机直接向攻击目标发送大量数据包，达到服务拒绝的目的。常见的有ICMP/IGMP洪水攻击，与UDP攻击，不过攻击者容易被发现。</li><li>反射攻击：又称为DRDoS，攻击者伪装成受害人，欺骗路由器或服务器产生大量响应，进而攻击受害者；ACK应答，DNS响应数据，NTP及SNMP等协议的响应数据等都可以成为攻击方式<center><img src="/pics/ddos-1.jpg" alt=""></center></li><li>攻击链路：与其它攻击方式有所不同，其攻击的目标并不是作为互联网端点的服务器的宽带资源，而是骨干网上的链路的宽带资源<center><img src="/pics/ddos-2.jpg" alt=""></center></li></ol><h4 id="2-_消耗系统资源">2. 消耗系统资源</h4><p>终端设备与服务器进行通信时，会大量使用系统资源。DDoS通过人为增加连接资源进行消耗和占用，阻止正常连接的建立，从而达到拒绝服务的目的。攻击TCP连接：</p><ol><li>TCP的三次握手<center><img src="/pics/ddos-3.jpg" alt=""></center></li><li>SYN洪水攻击：是最经典的一种形式，通过短时间内产生大量的TCP半开连接，实现攻击</li><li>攻击SSL连接：安全套接层(SSL)协议密钥协商。加密和解密的过程中消耗大量的系统资源，这也达成了攻击的目标。攻击者只需要让服务器不停地去解密和验证，就能够产生大量消耗服务器的计算资源。</li></ol><h4 id="3-_消耗应用资源">3. 消耗应用资源</h4><p>消耗应用资源的DDoS正逐渐成为拒绝服务攻击的主要手段之一。而由于DNS和Web服务的广泛性和重要性，这两种服务也成为了消耗应用资源的分布式拒绝服务攻击的最主要的攻击目标。</p><ol><li>攻击DNS服务：在DNS解析的过程中，客户端发起一次查询请求，DNS服务器可能需要进行额外的多次查询才能给出应答，常见的DNS Query与DNS NXDomain两种攻击。而DNS NXDomain会消耗更多的DNS本地缓存，危害更大。</li><li>攻击Web服务：<ol><li>大量正常的HTTP请求</li><li>不完整的HTTP请求</li><li>慢速的HTTP长连接</li><li>构造恶意的HTTP请求</li></ol></li></ol><h2 id="三-_防范：">三. 防范：</h2><p>过滤网络，过滤出正常的请求</p>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> DDos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xss攻击</title>
      <link href="/Security/Security/Xss%E6%94%BB%E5%87%BB/"/>
      <url>/Security/Security/Xss%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<h2 id="0-_概念">0. 概念</h2><ol><li>XSS<br>Cross Site Scripting, 跨站脚本攻击</li><li>常用手段<br>攻击者通常会在有漏洞的程序中插入javascript, VBScript, ActiveX或Flash以欺骗用户，盗取用户账户，修改用户设置，盗取/污染cookie，做虚假广告。</li></ol><h2 id="1-_预防">1. 预防</h2><ol><li>完善的过滤体系<br>不合法的输入，一概过滤</li><li>html encode<br>对html标签进行转码，页面仅仅显示转码后的内容。这仅仅适用于已经确定内容中不存在html的情况</li></ol>]]></content>
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Xss </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS</title>
      <link href="/Network/Network/DNS/"/>
      <url>/Network/Network/DNS/</url>
      <content type="html"><![CDATA[<h3 id="0-_DNS">0. DNS</h3><ul><li>域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址</li><li>DNS规定，域名中的标号都有英文和数字组成，每一个标号不超过63个字符(为了记忆方便，一般不会超过12个字符)，也不区分大小写字母。</li><li>最高的顶级域名则由ICANN进行管理</li><li>ICANN（The Internet Corporation for Assigned Names and Numbers）互联网名称与数字地址分配机构</li></ul><h3 id="1-_基础">1. 基础</h3><ul><li>一个服务器所负责管辖(或有权限)的范围叫做区(zone)</li><li>DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位</li><li>区 &lt;= 域</li></ul><h3 id="2-_域名分类">2. 域名分类</h3><ul><li>根域名<br>最高层次的域名服务器。当本地域名服务器无法解析域名时，都会向根域名服务器求助，根域名，不直接把待查询的域名直接解析出来，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</li><li>顶级域名TLD(Top Level Domain)<br>负责管理在该顶级域名服务器注册的二级域名， 分为三大类：<ul><li>国家顶级域名nTLD：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)</li><li>通用顶级域名gTLD：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)</li><li>基础结构域名(infrastructure domain)：这种顶级域名只有一个，即arpa，用于反向域名解析，因此称为反向域名</li></ul></li><li>权限域名服务器<br>负责一个“区”的域名服务器</li></ul><h3 id="3-_域名的解析过程">3. 域名的解析过程</h3><ul><li>递归查询<br>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：主机问本地域名服务器，本地域名服务器问另一个域名服务器，然后再依次返回结果。</li><li>迭代查询<br>本地域名服务器向根域名服务器的查询采用的是迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。</li></ul><h3 id="4-_httpDNS">4. httpDNS</h3><ol><li>用于解决移动平台的运营商的LocalDNS解析域名异常的问题。</li><li>针对同一服务器，针对不同的网络，会存在多个DNS，DNS服务商会根据用户的请求网络不同，选择不同的DNS服务器，然后再解析出真实的地址。</li><li>问题<ul><li>有些运营商，为了节省成本，会将请求转发到另外的DNS运营商上，从而导致DNS对用户所在位置的定位不准确，可能会从一个很远的IDC中取数据。针对用户而言，访问就会变慢，影响用户体验</li><li>拦截，重定向到另外的网址，并植入广告，导致用户流失</li></ul></li><li>httpDNS的做法:<ol><li>为了灾备，备选会从DNS服务商获取地址</li><li>自建HttpDNS服务模块，请求转发到HttpDNS服务器，根据用户的来源，选择相应的网络，直接返回地址</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NAT回流</title>
      <link href="/Network/Network/NAT%E5%9B%9E%E6%B5%81/"/>
      <url>/Network/Network/NAT%E5%9B%9E%E6%B5%81/</url>
      <content type="html"><![CDATA[<h3 id="一-_问题：内网通过外网地址访问外网，无法建立连接">一. 问题：内网通过外网地址访问外网，无法建立连接</h3><center><img src="/pics/NAT回流.jpg" alt=""></center><p>如上图可以很明显的看出报文①发送到Router，Router根据NAT映射将目标地址改为10.110.10.1发送报文②。但是源地址不变仍为10.110.10.3。而后Web Server接收报文②后，发回③报文给Host A。注意此报文发送没有经过Router而是直接走二层。所以就导致了一个问题，Host A的请求目标为202.38.1.1，但是回应的源地址为10.110.10.1。所以导致会话不能建立。</p><h3 id="二-_方案">二. 方案</h3><ol><li>TCP代理</li><li>路由器支持端口回流<br>当路由器收到Host A发送的向202.38.1.1发送的TCP请求报文时，路由器将目标地址改为NAT的映射后的私网地址（10.110.10.1），端口为80。同时也把请求报文的源地址改为内部网关的地址即10.110.10.10，端口1025。之后Web服务器收到此请求报文。并对其回应。因为报文的源地址为网关地址。所以此报文会再经过网关。从而再次转换。达到Host A可以正常访问服务器的目的。</li></ol>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> NAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP中的seq与ack</title>
      <link href="/Network/Network/TCP%E4%B8%ADSEQ%E4%B8%8EACK/"/>
      <url>/Network/Network/TCP%E4%B8%ADSEQ%E4%B8%8EACK/</url>
      <content type="html"><![CDATA[<h2 id="0-_概念">0. 概念</h2><ul><li>TCP, Transmission Control Protocol, 传输控制协议</li><li>面向连接的、可靠的、基于字节流的运输层通信协议</li><li>TCP的可靠性中起到至关重要的SEQ与ACK</li><li>要点：<ul><li>ID<br>每个数据包的编号</li><li>Sequence Number<br>发送方，当前传输的数据中的第一个字节的编号</li><li>ACK<br>对上一次接收到的报文进行确认，并且标识希望收到的下一个报文序号</li><li>ISN<br>初始化序列号, 由协议栈随机产生的一个32位数</li></ul></li></ul><h2 id="1-_seq与ack">1. seq与ack</h2><p>例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataSize = 5000, isn = 1000, 则ID为1001 - 6000, 将数据分成5份</span><br><span class="line"></span><br><span class="line">段1：seq=1001（1001－2000）</span><br><span class="line">段2：seq=2001（2001－3000）</span><br><span class="line">段3：seq=2001（3001－4000）</span><br><span class="line">段4：seq=3001（4001－5000）</span><br><span class="line">段5：seq=4001（5001－6000）</span><br><span class="line"></span><br><span class="line">当接收到时seq=2070时，并且此时接受到200个字节大小的消息，那么此时ACK=2070 + 200 + 1, 2070+200，表明接收到了之前发送的数据，而+1，表明需要接收的下一个报文序号</span><br></pre></td></tr></table></figure><h2 id="2-_TCP不同过程中SEQ与ACK">2. TCP不同过程中SEQ与ACK</h2><ul><li><p>连接时  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      SYN, SEQ=0/ISN</span><br><span class="line">       -----------------------&gt;</span><br><span class="line"></span><br><span class="line">客户端     SYN, ACK=seq+1, SEQ=0/ISN     服务器</span><br><span class="line">       &lt;-----------------------</span><br><span class="line"></span><br><span class="line">      ACK, SEQ=1, ACK=1</span><br><span class="line">       -----------------------&gt;</span><br></pre></td></tr></table></figure><ul><li>SEQ的初始化值为ISN，也可以是0</li><li>最后一次握手时的SEQ和ACK都为1</li></ul></li><li><p>传输数据时</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      ACK=1, SEQ=1(data=12)</span><br><span class="line">       -----------------------&gt;</span><br><span class="line"></span><br><span class="line">客户端       ACK=13, SEQ=1(data=3)       服务器</span><br><span class="line">        &lt;-----------------------</span><br><span class="line"></span><br><span class="line">      SEQ=13(data=18), ACK=4</span><br><span class="line">       -----------------------&gt;</span><br><span class="line"></span><br><span class="line">  SEQ=4, ACK=31</span><br><span class="line">       &lt;-----------------------</span><br></pre></td></tr></table></figure><ul><li>当前的ACK为 <code>之前的seq + 接收到的数据长度</code>，因为ACK，表明已经得到的数据，而seq表明发送的第一个字节的序号+长度就是接收的整个的数据包，即验证了已经得到了数据，并且，也给出了希望得到的数据ID </li><li>当前的SEQ为 <code>之前的ACK</code>, 因为ACK，表明对方希望得到的数据ID</li></ul></li><li><p>关闭连接时</p><pre><code>              FIN, Push, ACK, Seq=<span class="number">120</span>, ACK=<span class="number">71</span>            -------------------------------&gt;客户端       ACK, Seq=<span class="number">71</span>, ACK=<span class="number">121</span>                 服务器            &lt;-------------------------------             FIN, ACK, SEQ=<span class="number">71</span>, ACK=<span class="number">121</span>            &lt;-------------------------------             ACK, SEQ=<span class="number">121</span>, ACK=<span class="number">72</span>            -------------------------------&gt;</code></pre><ul><li>当第一个请求发起时，会有FIN，Push, ACK, Seq标志位，FIN，表明关闭连接，Push表明立即处理请求</li><li>当服务器收到客户端发起的关闭连接的请求时，发出ACK包，表明确认并且同意关闭，前一个包并不带数据，但是此包很特殊，需要消耗一个包(120+1)</li><li>第三次发送数据时，不同的系统的实现不一样，有些是完全一样，即seq=71,有些是seq=71+1</li><li>无论如何，ACK，都会增加</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> TCP </tag>
            
            <tag> SEQ </tag>
            
            <tag> ACK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络-SSL/TLS</title>
      <link href="/Network/Network/SSL&amp;TLS/"/>
      <url>/Network/Network/SSL&amp;TLS/</url>
      <content type="html"><![CDATA[<h2 id="一-_概念">一. 概念</h2><ol><li><code>SSL</code> ：<code>Secure Socket Layer</code>，安全套接字层。该协议由两层组成：SSL记录协议和SSL握手协议。</li><li><code>TLS</code> ：<code>Transport Layer Security</code>，传输层安全协议。该协议由两层组成：TLS记录协议和TLS握手协议。</li></ol><p><code>TLS</code> 是 <code>SSL</code> 的升级版以及标准化。是网络层和应用层之间的一种安全协议。能够做到如下几点：</p><ol><li>认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>加密数据以防止数据中途被窃取</li><li>维护数据的完整性，确保数据在传输过程中不被改变</li></ol><h2 id="二-_CA基本概念">二. CA基本概念</h2><ul><li>CA<br><code>Certificate Authority</code> 的缩写，也叫“证书授权中心”。</li><li>对称加密<br>同一个密钥可以同时用作信息的加密和解密</li><li>非对称加密<br>需要两个密钥来进行加密和解密</li><li>数字签名<br>对需要加密的数据，生成摘要(digest)，然后用私钥，对摘要进行加密，生成后的数据为数字签名(signature)</li><li>数字证书<br>由CA机构颁发，当申请者向CA申请成功后，CA会将申请者的信息，证书有效期，申请人的公钥，通过CA自己的 <strong>私钥</strong> 加密，生成数字证书。而数字证书只能通过CA的 <strong>公钥</strong> 解密。解密后就能取得其中的所包含的申请人的公钥信息。</li><li>证书分类<ul><li>DV，<code>Domain Validation</code>，面向个体用户，安全体系相对较弱，验证方式就是向 whois 信息中的邮箱发送邮件，按照邮件内容进行验证即可通过</li><li>OV，<code>Organization Validation</code>，面向企业用户，证书在 DV 证书验证的基础上，还需要公司的授权，CA 通过拨打信息库中公司的电话来确认</li><li>EV，<code>Extended Validation</code>，这类证书的申请除了以上两个确认外，还需要公司提供金融机构的开户许可证</li></ul></li><li>证书认证链<br>证书认证链，是基于一个信任链(A信任B，B信任C，C信任D，那么D就是可信的)。那么针对证书而言，如果 D 需要可信，那么 C 就必须是可信的，以此类推。而每一个浏览器中内置了常见的 <code>Root CA</code>。根据 <code>x.509</code> 标准，每一个证书解密就能得到其中包含的公钥。一个网站向一个CA机构购买了一个证书，然后一个网站用户访问该网站时，浏览器会自动下载该网站的证书，然后进行安装，如果信任链中的某一个环节出错，就会提示 <strong>报证书不可信</strong>。<code>Root CA</code> 直接有公用密钥，所以二级证书，可以直接用 <code>Root CA</code> 的公钥进行解密，然后可以取出二级CA的公钥，以此类推就可以取得当前证书中所包含的所对应的CA的公钥。</li></ul><center><img src="/pics/CA认证链.png" alt=""></center><h2 id="三-_详细：">三. 详细：</h2><h3 id="2-1_SSL">2.1 SSL</h3><ol><li>协议组成<ol><li>SSL记录协议<br>它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持，能够保证数据的安全性与完整性(利用共享的MAC密钥生成鉴别码)。</li><li>SSL握手协议<br>它建立在SSL记录协议上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</li></ol></li><li><p>SSL协议的工作流程</p><ol><li>客户端给出协议版本号、成的随机数(Client random)，以及客户端支持的加密方法。</li><li>服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数(Server random)。</li><li>客户端确认数字证书有效，然后生成一个新的随机数 (Premaster secret)，并使用数字证书中的公钥，加密这个随机数，发给服务器。</li><li>服务器使用自己的私钥解密，获取客户端发来的随机数(Premaster secret)。</li><li>客户端和服务器根据之前约定的加密方法，使用前面的三个随机数(Client random, Server random, Premaster secret)，生成 “对话密钥” (session key)，用来加密接下来的整个对话过程(对称加密，速度快，如果所有数据都通过非对称加密效率较慢)。</li></ol><p>以上的完全是基于 RSA ，只要 RSA 足够长，就能保证数据的安全性。也可以不使用 RSA 使用 DH 算法是一样的。</p></li></ol><h3 id="2-2_TLS">2.2 TLS</h3><ol><li>TLS是互联网标准化组织ISOC接替NetScape公司，是针对SSL的升级以及标准化。</li><li>历史<br> 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。<br> 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。<br> 1996年，SSL 3.0版问世，得到大规模应用。<br> 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</li></ol><h2 id="四-_https的认证过程">四. https的认证过程</h2><center><img src="/pics/https.png" alt=""></center>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> SSL/TLS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-类加载机制</title>
      <link href="/Java/Java/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/Java/Java/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="一、类对象">一、类对象</h3><p>在面向对象编程中，类可以理解成是对象的模板。在<code>Java</code>体系中，可以通过<code>class</code>关键字声明类。代码通过<code>javac</code>编译后，将生成一个<code>.class</code>的二进制文件。当一个符合JVM要求的二进制文件，被类加载器加载到内存后，将会生成一个<code>java.lang.Class</code>的类对象，其作用是在运行时识别一个对象的类型和类信息。</p><h3 id="二、类对象的生命周期是怎样的？">二、类对象的生命周期是怎样的？</h3><center><img src="/pics/Java-Class-Loader.jpg" alt=""></center><p>验证、准备、解析统称为连接过程。加载、验证、准备和初始化这四个阶段<strong>开始</strong>的顺序是确定的，而其执行顺序是交叉混合的，而解析的过程，可能发生在初始化后，例如运行时绑定。</p><h4 id="2-1_加载">2.1 加载</h4><p>查找并加载类的二进制<code>.class</code>文件，在此过程中，虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li></ol><p>在此阶段中，解析二进制文件及生成<code>java.lang.Class</code>对象，都是固定，而且必须符合一个规范，但是用户自定义<code>ClassLoader</code>加载指定的<code>.class</code>文件。</p><h4 id="2-2_验证">2.2 验证</h4><p>确保被加载的类的正确性。其过程主要可以分为四个阶段: </p><ul><li><p>文件格式验证</p><p>验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></li><li><p>元数据验证</p><p>对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p></li><li><p>字节码验证</p><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></li><li><p>符号引用验证</p><p>确保解析动作能正确执行。</p></li></ul><p>验证阶段是必要的，但不是必须的。可以通过 <code>-Xverifynone</code> 来关闭类验证措施。</p><h4 id="2-3_准备">2.3 准备</h4><p>为类的静态变量分配内存并将其初始化为默认值，当前阶段分配的内存主要集中在方法区中。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int v1 = 1;</span><br><span class="line">public static int v2 = 2;</span><br><span class="line">public static final int v3 = 3;</span><br></pre></td></tr></table></figure><p>此阶段执行完成后，其赋值情况如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 暂时没有初始化</span><br><span class="line">v2 = 0</span><br><span class="line">v3 = 3</span><br></pre></td></tr></table></figure><h4 id="2-4_解析">2.4 解析</h4><p>虚拟机将常量池内的符号引用替换为直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</p><ul><li><p>符号引用</p><p>引用一组符号来描述所引用的目标，引用的目标并不一定已经加载到内存中；</p></li><li><p>直接引用</p><p>可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如是有了直接引用，那么目标必定存在</p></li></ul><h4 id="2-5_初始化">2.5 初始化</h4><p>为<strong>类的静态变量</strong>赋予正确的初始值，执行其静态块或者静态属性的初始化。优先初始化所依赖的父类，静态属性间是顺序初始化的。</p><p>以下六种情况会导致类的初始化：</p><ul><li><code>new</code>对象</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如Class.forName(“com.shengsiyuan.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li></ul><h4 id="2-6_使用">2.6 使用</h4><p>使用<code>new</code>生成实例，或者使反映生成实例。</p><h4 id="2-7_卸载">2.7 卸载</h4><p>在如下几种情况下，Java虚拟机将结束生命周期：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h3 id="三、类加载器">三、类加载器</h3><p>从上面已经了解了类，了解了类的生命周期，类加载器的作用则是将类所对应的<code>.class</code>从二进制文件中读入内存，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。系统自带的有三类类加载器，<code>启动类加载器(BootStrap ClassLoader)</code>，<code>扩展类加载器(Extension ClassLoader)</code>，<code>应用程序类加载器(Application ClassLoader)</code>，其关系如下：</p><center><img src="/pics/ClassLoader.png" alt=""></center><p>用户可以扩展<code>ClassLoader</code>实现自定义的需求，例如:</p><ul><li>1）在执行非置信代码之前，自动验证数字签名。</li><li>2）动态地创建符合用户特定需要的定制化构建类。</li><li>3）从特定的场所取得java class，例如数据库中和网络中。</li></ul><p>图中的箭头的方向，指向其父类，是因为在JVM中，<code>ClassLoader</code>采用了双亲委托的加载机制。</p><h4 id="3-1_双亲委派模型的工作流程">3.1 双亲委派模型的工作流程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>其有如下的意义:</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><h4 id="3-2_如何触发类的加载？">3.2 如何触发类的加载？</h4><ol><li>命令行启动应用时候由JVM初始化加载</li><li>通过<code>Class.forName()</code>方法动态加载</li><li>通过<code>ClassLoader.loadClass()</code>方法动态加载</li></ol><p>那么 <code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>的区别是什么呢？</p><ul><li><p><code>Class.forName()</code></p><p> 将类的<code>.class</code>文件加载到JVM中之外，默认会对类进行解释，然后初始化，也可以通过传参关闭初始化操作。</p></li><li><p>ClassLoader.loadClass()</p><p>只干一件事情，就是将<code>.class</code>文件加载到JVM中，不会执行初始化操作。</p></li></ul><h3 id="四、什么时候会加载类?">四、什么时候会加载类?</h3><p>有两个概念，<code>主动引用</code>和<code>被动引用</code>。</p><ul><li><code>主动引用</code>: 是指在启动JVM时，必须对类进行初始化的。</li><li><code>被动引用</code>: 是指除开 <code>主动引用</code> 以外，不会被初始化的行为。</li></ul><p>有且只有以下四种情况，必须对类进行<code>主动引用</code>:</p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令时(使用new实例化对象的时候、读取或设置一个类的静态字段、调用一个类的静态方法)。</li><li>使用<code>java.lang.reflet</code>包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，虚拟机会初始化主类(包含main方法的那个类)。</li></ul><p><code>被动引用</code>的情况：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发类的初始化。例如： <code>ClassA [] array=new ClassA[10]</code>，会触发了一个名为<code>[LClassA</code>的类的初始化，而不是ClassA;</li><li>访问类的常量，不会初始化类，因为常量会在编译阶段存入调用类的常量池。</li></ul><p>一个例子说明被动引用的几种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;superclass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value = 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;subclass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String value2 = &quot;asdfasd&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);  // 被动应用1</span><br><span class="line">        SubClass[] sca = new SubClass[10];   // 被动引用2</span><br><span class="line">        System.out.println(SubClass.value2); // 被动引用3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">superclass init</span><br><span class="line">123</span><br><span class="line">asdfasd</span><br></pre></td></tr></table></figure><h3 id="五-_一个很好的例子">五. 一个很好的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SingleTon &#123;</span><br><span class="line">  private static SingleTon singleTon = new SingleTon();</span><br><span class="line">  public static int count1;</span><br><span class="line">  public static int count2 = 0;</span><br><span class="line"></span><br><span class="line">  private SingleTon() &#123;</span><br><span class="line">    count1++;</span><br><span class="line">    count2++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static SingleTon getInstance() &#123;</span><br><span class="line">    return singleTon;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">    System.out.println(&quot;count1=&quot; + singleTon.count1);</span><br><span class="line">    System.out.println(&quot;count2=&quot; + singleTon.count2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count1=1</span><br><span class="line">count2=0</span><br></pre></td></tr></table></figure><p>分析:<br><code>new</code> 操作会主动引用类对象，引起类的初始化。执行 <code>private static SingleTon singleTon = new SingleTon();</code> 后 <code>count1=1, count2=1</code>。因为静态区是顺序执行的，再执行 <code>public static int count1;</code>，这仅仅是一个声明的操作，所以 <code>count1=1</code>; 继续执行 <code>public static int count2 = 0;</code> 这是一个声明加赋值的操作，此时 <code>count2=0</code></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高效思考的步骤</title>
      <link href="/Life/Life/%E5%A4%A7%E8%84%91%E7%9A%84%E6%80%9D%E8%80%83%E7%A8%8B%E5%BA%8F/"/>
      <url>/Life/Life/%E5%A4%A7%E8%84%91%E7%9A%84%E6%80%9D%E8%80%83%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="1-_界定问题">1. 界定问题</h3><p>也就是说，如果想让我们的大脑高效率的正常运转，进入主运算程序的话，第一要界定问题。我的朋友王子开了一家美容院。比如她刚刚开始经营，希望有客户到店里来，她要考虑如何增加她的企业的影响力，增加知名度，有更多的客户来接受她的服务，她思考这样的一问题的话，她要先界定：我到底遇到了什么问题？是我信息发布的问题，还是我服务项目的问题？还是我服务品质的问题？首先要界定清楚我遇到的是什么样的问题，我想解决什么问题，我是想把人招开？要把价格提上来？还是要把利润提上来？这是不同的概念。当我们的大脑在思考问题的时候，我们普通人思考了半天，啥都没想。大脑根本没有进入主运算程序。在同一个地方卡住了。所以大脑的运作程序，第一个是要先界定问题。比如考研究生，这是一个复杂的系统，我们评估一下，我到底要解决什么问题？是不认识相关的人，还是没有人来帮我，还是我要解决我的基础知识？问你到底要解决什么问题？很多女士在面临着丈夫有外遇，情爱的复杂问题上，她只是在那骂，怨恨，只是在那自艾自怜。没有真正问过自己，我到底遇到了什么样的问题？我该如何解决这个问题？首先我要解决什么问题？我是要解决离婚的问题，还是要保住这个家庭的问题！我要怎么样解决这个问题，先要弄清楚到底要解决什么问题。大部分人根本没有这个程序。相当于计算机闲置着，没有用。所以，你要先给你的大脑输入指令。大脑是台高效能的计算机，你没有给它输入条件，却让它求解！所以你必须先研究我到底要解决什么问题。这相当于给大脑输入一个指令，给我计算这个方程！我限你两个小时之内把解求出来。这是界定问题。</p><h3 id="2-_有坚定的解决问题的信念">2. 有坚定的解决问题的信念</h3><p>坚信你的大脑一定能解决这个问题，这叫做信念。坚信你的问题一定会有解，大脑一定能解决这个问题，得出结论。信念是进入大脑主程序的通道。大部分人开始界定了问题，“我要给自己营业额提高50%！”，他刚刚要进入这样的问题，然后马上给自己一个结论“这是不可能的！”等于刚输入指令，计算机刚要启动，你马上说“停！”，等于向相反方向下命令，所以这是不可能的！你刚告诉你的大脑，“我要提升50%的营业额”，马上又说，“这不可能，这长春这么热，非典影响这么大，这不可能！”。相当于你给大脑一个命令“往东走！”然后马上再下命令“往西走！”大脑根本什么也没做！有人说，“看我这个脑袋怎么就不像人家的那样好用呢！”那是因为人家的运作程序跟你不一样！所以，大脑思考的第二个程序就是你的信念，决定你是否启动主程序。主程序的按钮相当于计算机上的ENTER键，有信念，像按回车键；没有信念，就停止了。</p><h3 id="3-_解决问题的白热化欲望">3. 解决问题的白热化欲望</h3><p>你必须激发起要解决你问题的强烈欲望。计算机是否能在不开启电源的情况进行运作？不可能的。人脑运作的能量是哪来的？人脑运作需要供应的能量是欲望。我们大部分人是解决也行，不解决也无所谓！这就相当于给计算机断电。如果你想解决你人生中的任何一个难题，必须有白热化的欲望，人脑这台计算机才能开足马力进行运算。否则的话，计算机停电不工作。欲望是大脑的动力系统，而你没有解决问题的欲望，没有强烈的解决的欲望。“我就是要今年挣到100万！你必须给我运算出答案来！”你只有给大脑下死命令！大脑才会开始启动。首先是界定问题，我要今年挣到100万，这个问题已经明确了，第二个是信念：我一定能挣到100万！答案在哪，我一定能找出来！这样大脑开始运作了。开始它运作得很慢，当你有强烈的欲望，相当于你给大脑充分的电能进行加速！好像汽车的油门踩到底，它百分之百会把能量发挥出来，开足马力运作！所以当你想要解决你问题的时候，如果你没有解决问题的欲望的话，你的大脑是不会给你想出办法来的！当你有了白热化的欲望，你的潜意识接受到了这个信息，它慢慢开始启动程序，像一个巨大的螺纹系统，他开始慢慢的转动，愈转愈快，最后他给你运作一个答案来。这是第三个程序。</p><h3 id="4-_把你的注意力维持在这个事情的解决办法上，而不是问题上">4. 把你的注意力维持在这个事情的解决办法上，而不是问题上</h3><p>大部分人是想十分钟，没有解决办法，“不行，这事放弃吧！”信念开始动摇。这是基本的运算程序。如果大家没把这件事情考虑明白，那就太遗憾了。实际上，教你如何使用这个计算机，第一个是把问题输入进去；第二是要坚信它能够解决，你不坚信它就停了；第三个要输入巨大的能量，有强烈的要解决这个问题的欲望，有了白热化的欲望，它开始运转了，这相当于巨大的惯性系统的轮子一样开始运转；第四个是维持你的注意力，不间断的专注在你解决问题的办法上，而不是维持在“我为什么不可以解决”上！大部分人他的注意力维持不到五分钟。如果你能维持你的注意力在正面上就“一定能解决！一定有好消息！一定有好的办法！……”找出一个放在一边，这些方法先不进行评估，不断的去找，告诉自己“可能还有新的方法，可能还有新的方法！……就是有，一定有，一定有……”如果你能维持你的注意力两个小时以上，人生中普通人的所有难题都可以找到答案。大部分的人连五分钟都维持不住。你可以尝试一下，你会觉察你的大脑是怎么运作的。开始想“我怎么样才能把老公的心收回来？”好，问题设定完了。然后坚信“一定有办法把他的心收回来，把外边的妖精赶走！一定有办法！”第三个，强烈的欲望“我太痛苦了！我必须把他的心收回来！”然后开始想，“我今天化妆来诱惑他？我今天回家给他煮面？……”想各种办法。可是大部分人是怎么想的呢？“我一定要把他的心收回来”，然后马上想，“不可能，那个狐狸精比我……”马上她就反过来想，“我一定有办法把他解决，”接着想：“他这个人生性就花心……”；“我一定有办法”，接着再想“不行，他这个人说不动！……”你的大脑接受的指令是“往东！往西！往东！往西！……”大部分人在干嘛呢？大部分人想了二十分钟就痛苦不堪了。你是人，如果是计算机，它一定会找你的麻烦。计算机有时像这笑话里的鹦鹉。有人得到一个会说话的鹦鹉，鹦鹉在一支短枝上立着。主人对客人说“你看我的鹦鹉会说话，你拉它的左脚，它就会说‘你好！’；如果你拉它的右脚，它就会说‘谢谢！’”这个客人就拉一下它的左脚，鹦鹉张口：“你好！”，再拉它的右脚，鹦鹉又张口：“谢谢！”。这客人问主人，“如果我两只脚一起拽会怎样呢？”这时鹦鹉说话了：“你要把老娘摔死来呀！”实际上，你的大脑被你弄混乱了！你一会告诉它“有办法解决”，一会又告诉它“没有办法解决！”这两个相反方向的信息同时在输入，一会儿往东，一会儿往西，你会怎么样呢？紧张、焦虑、烦躁……痛苦不堪。就是因为你把它折磨，它才让你痛苦不堪。它让你感觉“我太痛苦了！算了，喝酒！……”一有压力，就有方式避开。你给大脑下了相反方向的命令，这是从小的习惯形成的，90%的人都是这样的。我们不懂大脑的运作程序。假设有个人站在这里，用二个小时我能把他折腾疯了！他一会就晕了，为什么说一仆二主难做呢，A主人说往东，B主人说往西，最后把人弄成精神病了。大部分人没有疯，是因为大脑的的容量太大了。“不想了，喝酒去吧！算了，大不了拿出个别的方案……”“算了，不行我也弄个情人得了！……”我想告诉大家，你的头脑需要持续的专注在一个问题上往正面的方向去想，往同一方向想，“一定有解！一定有解！……”这样大脑才能持续的运作。应该讲，爱因斯坦的专注力恐怕是世上无人可比的。他可以长达几周专注在同一个问题上。一个普通人如果你能专注在你的问题上，持续的沿着同一个方向想二个小时，所有人，包括我，我们所有的问题都是可以解决的。一个大的科学家，你能专注在你所研究的问题上，大约一周的时间，如果不变的话，那么遇到的大部分科学问题都可以得到答案。我们的大脑实在是太强大了，可是我们大部分人不明白这个道理。</p><h3 id="5-_放松">5. 放松</h3><p>大脑的运作是和身体连接的，它的物质形态的能量是要供应血液、通过糖的方式来供应大脑的高速运转的需要，相当于大脑里面的机器在运转。当我们肌肉紧张的时候就没有血液供应大脑，它里面的能量供应就减速。大脑是通过两种介质来进行思考的，一是化学介质，一是电介质。这两种介质是要在大脑兴奋的状况下才能活跃。一个化学分泌介质，就是荷尔蒙，另一是电介质。对大家而言，只有肌肉放松，才有能量供应大脑，才有能量供应大脑。大部分人处在紧张焦虑状态，当你的身体肌肉处在焦虑紧张状态时，没有血液流向大脑，大脑的能量不足，所以想一会你就头晕脑胀，什么也想不出来。要知道大脑进入真正高效率工作状态时，你会感觉异常清晰，大脑像一个无垠的宇宙一样，什么问题都可以瞬间去想。如果大脑供氧不足，一会头昏脑胀，什么也想不下去了。这是80%的人不会用脑，想一会事就累了，厌倦了，想不下去了。深层原因是肌肉处在紧张状态，整个人处在焦虑状态没有能量供应大脑。</p><h3 id="6-_主动体会大脑思考时的快乐">6. 主动体会大脑思考时的快乐</h3><p>当你能够体会思考的时候是大脑在高速运转的状态。如果你能够主动的去体会快乐，大脑会产生白色物质向大脑区域喷射，这种白色物质是叫β内腓肽系列的荷尔蒙。这样一来，大脑的记忆思考有两种介质，一个电，输入脑电波来进行信息收集传递；还有是内腓肽系列的化学物质。当你在快乐状态去思考问题的时候，你大脑分泌大量的荷尔蒙，相当于给你大脑运输的工具非常丰富，它会迅速的把信息传达到位，然后整合出想要的问题答案。对于大家来讲，处在紧张焦虑状态，无法体会思考的快乐。他们体会到的只是思考的痛苦。很多人一想到想问题就想得脑袋生疼，说明没进入主运算程序。假如计算机是有灵性的话，你刚输入“往东”，又“往西”，它也会愤怒，“你到底让我怎么做！”而你整天给你的大脑输入相反的指令，你的大脑还能扛在你的肩膀上就不错了！还能帮你运算出额外的程序，这是大脑的功能太强大了！</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Efficiency </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-集合类</title>
      <link href="/Java/Java/Java-%E9%9B%86%E5%90%88/"/>
      <url>/Java/Java/Java-%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h3 id="一、简介">一、简介</h3><p>集合是开发中常用的工具，在 Java 中大概有如下几类集合:</p><ul><li><code>List</code> 是一个有序的集合</li><li><code>Set</code> 不能包含重复元素的有序集合</li><li><code>Queue</code> 特殊的List，只能按照指定方式入队和出队</li><li><code>Map</code> 由一系列的键值对组成的集合</li></ul><p>其继承关系如下:˙</p><center><img src="/pics/Collection.png" alt="collection"></center><br><center><img src="/pics/Map.png" alt="map"></center><h3 id="二、List">二、List</h3><table><thead><tr><th>类名</th><th>作用</th><th>是否线程安全</th><th>备注</th></tr></thead><tbody><tr><td>ArrayList</td><td>有序集合</td><td>否</td><td>能够提供高效的随机访问，但是插入、删除操作可能会触发扩容</td></tr><tr><td>LinkedList</td><td>基于链表实现的有序集合</td><td>否</td><td>能够提供高效的插入与删除操作，随机访问、遍历的效率不高</td></tr><tr><td>Vector</td><td>线程安全的ArrayList</td><td>是</td><td>效率很低，不推荐使用，通常使用<code>Collections.synchronizedList</code>代替</td></tr><tr><td>Stack</td><td>基于Vector实现的一个后进先出的堆栈集合结构</td><td>是</td><td>不推荐使用，通常使用 <code>ArrayDeque</code> 进行代替</td></tr></tbody></table><h4 id="2-1_ArrayList如何扩容？">2.1 ArrayList如何扩容？</h4><p>在其中有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看的会扩容后的大小为原大小的 <strong>1.5倍</strong>，并且将原来的数据拷贝到新的数组中。</li><li>注意在 <code>Vector</code> 也有 <code>grow</code> 函数，通过其代码，可以看到，其默认的扩展为原来的 <strong>2倍</strong>。</li><li>初始化时，默认的大小为 <code>10</code></li></ul><h4 id="2-2-_Vector为什么不推荐使用？">2.2. Vector为什么不推荐使用？</h4><p>主要有两个方面：</p><ol><li><code>Vector</code> 从jdk1.0就有，其方法的命名不规范，方法存在重复，例如<code>addElement</code>和<code>add</code></li><li><code>Vector</code>的线程同步方式不高效，会针对每个单独的操作都进行加锁，在大多数情况，这是一种有缺陷的同步方式。相对于<code>Collections.synchronizedList</code> 而言，性能不高，而且其代码职责不明确</li></ol><h4 id="2-3-_如何实现一个线程安全的ArrayList和LinkedList?">2.3. 如何实现一个线程安全的ArrayList和LinkedList?</h4><p>可以通过 <code>Collections.synchronizedList</code> 创建一个线程安全的 <code>ArrayList</code>和<code>LinkedList</code>。<code>Vector</code>是通过<code>synchronized</code>关键字，锁的是类，而 <code>Collections.synchronizedList</code> 是通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 3053995032091335093L;</span><br><span class="line"></span><br><span class="line">        final Collection&lt;E&gt; c;  // Backing Collection</span><br><span class="line">        final Object mutex;     // Object on which to synchronize</span><br><span class="line"></span><br><span class="line">        SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">            this.c = Objects.requireNonNull(c);</span><br><span class="line">            mutex = this;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁的是对象，而且通过装饰模式的方式，能够做到只针对需要的操作才加锁，性能更高</p><h4 id="2-4_ArrayList和Vector的区别？">2.4 ArrayList和Vector的区别？</h4><ul><li>在同步性上，<code>ArrayList</code> 是非线程安全，而<code>Vector</code>是线程安全的; </li><li>在扩容方面，<code>ArrayList</code>默认扩容了原来的0.5倍的容量，而<code>Vector</code>直接将容量增加一倍</li></ul><h4 id="2-5_Enumeration和Iterator接口的区别">2.5 Enumeration和Iterator接口的区别</h4><ul><li><code>Iterator</code>是JDK1.5开始才有的接口，而<code>Enumeration</code>是从JDK1.0开始的接口，在命名上<code>Iterator</code>命名更规范，而且<code>Iterator</code>的存在就是用于替代<code>Enumeration</code></li><li><code>Iterator</code>有<code>fail-fast</code>机制</li><li><code>Iterator</code>能够删除元素，<code>Enumeration</code>并不能删除元素</li></ul><h4 id="2-6_ListIterator有什么特点">2.6 ListIterator有什么特点</h4><p><code>ListIterator</code>继承自<code>Iterator</code>接口，除了<code>Iterator</code>所有相关的接口外，还提供了双向遍历、添加元素、修改元素的接口</p><h3 id="三、Set">三、Set</h3><table><thead><tr><th>类名</th><th>作用</th><th>是否线程安全</th><th>备注</th></tr></thead><tbody><tr><td>HashSet</td><td>无重复元素的无序集合</td><td>无</td><td>集合元素可以是null</td></tr><tr><td>TreeSet</td><td>生成一个总是处于排序状态的 <code>Set</code>，内部基于 <code>TreeMap</code> 进行实现，使用元素的自然顺序对元素进行排序，或提供 <code>Comparator</code> 接口，默认是从小到大的顺序排列。</td><td>否</td><td></td></tr><tr><td>LinkedHashSet</td><td>不仅能够保证数据的不重复，而且能够保存其存储的顺序</td><td>否</td><td>内部通过一个链表，保留元素插入的顺序，在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet</td></tr><tr><td>EnumSet</td><td>一个在Enum类型上处理更高效的HashSet</td><td>否</td><td>在处理Enum类型上，效率很高，不允许空元素，不会出现ConcurrentModificationException，有序</td></tr></tbody></table><h4 id="3-1_HashSet如何实现？">3.1 HashSet如何实现？</h4><p><code>HashSet</code>完全基于<code>HashMap</code>实现，可以将<code>HashSet</code>看成一个值固定的<code>HashMap</code>。</p><h4 id="3-2_EnumSet的高效体现在什么地方？">3.2 EnumSet的高效体现在什么地方？</h4><p>一个<code>Enum</code>集合可以通过一个二进制数字表示，该数字的长度为枚举类型的<code>values()</code>值，每一个<code>Enum</code>为一个<code>bit</code>，每一个<code>Enum</code>根据其<code>ordinal</code>确定其位置，每一个<code>bit</code>的取值取决于当前集合是否包含这个<code>Enum</code>。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Day &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumSet&lt;Day&gt; set = EnumSet.noneOf(Day.class);</span><br><span class="line">set.add(Day.MONDAY);</span><br><span class="line">set.add(Day.THURSDAY);</span><br></pre></td></tr></table></figure><p>在 <code>idea</code> 中调试时，你可以看到 <code>((RegularEnumSet) set).elements</code> 的值为9。数字9与<code>Enum</code>的对应关系如下:</p>   <center><img src="/pics/Java-Collection-EnumSet.png" alt=""></center><p>其对集合的操作现在变成了对bit的操作，所以非常高效。</p><p>需要注意如下几点:</p><ul><li>EnumSet是一个抽象类，是不能直接实例化的</li><li>EnumSet有两个实现类，分别是<code>RegularEnumSet</code>和<code>JumboEnumSet</code></li></ul><p>在<code>EnumSet</code>中有如下的一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123;</span><br><span class="line">    Enum&lt;?&gt;[] universe = getUniverse(elementType);</span><br><span class="line">    if (universe == null)</span><br><span class="line">        throw new ClassCastException(elementType + &quot; not an enum&quot;);</span><br><span class="line"></span><br><span class="line">    if (universe.length &lt;= 64)</span><br><span class="line">        return new RegularEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">    else</span><br><span class="line">        return new JumboEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出当<code>Enum</code>的个数小于等于64时，会使用<code>RegularEnumSet</code>，大于64时，会使用<code>JumboEnumSet</code>。<code>RegularEnumSet</code>使用一个<code>long</code>类型来表示集合，而<code>JumboEnumSet</code>使用<code>long[]</code>来表示。当使用<code>long[]</code>会根据<code>ordinal</code>值确定其分部在那个<code>long</code>上。</p><h4 id="3-3_LinkedHashSet是如何实现？">3.3 LinkedHashSet是如何实现？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;</span><br><span class="line">    extends HashSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -2851667679971038690L;</span><br><span class="line"></span><br><span class="line">    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">        super(initialCapacity, .75f, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedHashSet() &#123;</span><br><span class="line">        super(16, .75f, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 <code>LinkedHashSet</code>的全部代码，其继承自<code>HashSet</code>，只调整了构造方法和<code>spliterator</code>外。构造方法几乎全部调用父类的构造方法，其父类的构造方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出是基于<code>LinkedHashMap</code>去实现的。</p><h3 id="四、Queue">四、Queue</h3><p>为“先进先出”（FIFO）</p><table><thead><tr><th>类名</th><th>作用</th><th>是否线程安全</th><th>备注</th></tr></thead><tbody><tr><td>PriorityQueue</td><td>每次从队列中取出的是具有最高优先权的元素，即值最小的元素，通过小顶堆实现，需要提供 <code>Comparator</code> 接口</td><td>否</td><td>并不是按照添加元素的顺序来排列元素，而是按照队列元素的大小进行由小到大排序，所以PriorityQueue不允许插入null元素</td></tr></tbody></table><p>主要主要的方法如下：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>增加一个元索，如果队列已满，则抛出一个IllegalStateException异常</td></tr><tr><td>put</td><td>添加一个元素，如果队列满，则阻塞</td></tr><tr><td>offer</td><td>添加一个元素并返回true，如果队列已满，则返回false</td></tr><tr><td>element</td><td>返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>poll</td><td>移除并返问队列头部的元素，如果队列为空，则返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素，如果队列为空，则返回null</td></tr><tr><td>take</td><td>移除并返回队列头部的元素，如果队列为空，则阻塞</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常</td></tr></tbody></table><h3 id="五、Deque">五、Deque</h3><p>代表一个双端队列，可以用来实现队列和栈</p><table><thead><tr><th>类名</th><th>作用</th><th>是否线程安全</th><th>备注</th></tr></thead><tbody><tr><td>LinkedList</td><td>一个链表实现的有序集合，能够提供高效的插入与删除操作</td><td>否</td><td></td></tr><tr><td>ArrayDeque</td><td>一个双向队列，既能够提供栈的功能，也能实现先进先出的队列</td><td>否</td><td>以循环数组实现的双向Queue，默认为16个元素</td></tr></tbody></table><h3 id="六、Map">六、Map</h3><table><thead><tr><th>类名</th><th>作用</th><th>是否线程安全</th><th>备注</th></tr></thead><tbody><tr><td>HashMap</td><td>以哈希表为基础实现的键值对的集合结构，采用散列链表的结构</td><td>否</td><td>无序</td></tr><tr><td>Hashtable</td><td>线程安全的 HashMap</td><td>是</td><td>不推荐</td></tr><tr><td>LinkedHashMap</td><td>不仅仅保存了HashMap的特性，而且还能够保证数据的先后顺序</td><td>否</td><td>有序</td></tr><tr><td>TreeMap</td><td>键以某种排序规则排序的键值对集合，以红黑树作为其结构，非线程安全</td><td>否</td><td></td></tr><tr><td>EnumMap</td><td>键为枚举的Map，在构造时，需要传入一个枚举类的类</td><td></td><td></td></tr><tr><td>Properties</td><td>通常用于读取Properties文件</td><td>是</td><td></td></tr><tr><td>IdentityHashMap</td><td>键值对集合，但是在其比较时，不是通过 <code>equals</code> 方法，而是直接通过 <code>==</code>，则意味着，是通过比较其内存地址。</td><td>否</td><td></td></tr><tr><td>WeakHashMap</td><td>种改进版的HashMap，它对key实现“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收</td><td>否</td><td></td></tr></tbody></table><h4 id="6-1_HashMap是如何实现？">6.1 HashMap是如何实现？</h4><p>借用网上的一张图:</p>  <center><img src="/pics/Java-HashMap.jpg" alt="HashMap"></center><p>其主要借助数组和链表进行实现，首先根据哈希值，确定在数组中的索引，再创建链表，解决哈希值冲突的问题。链表上的比较主要借助于<code>equals</code>方法。</p><h5 id="6-1-1_HashMap是如何扩容的？">6.1.1 HashMap是如何扩容的？</h5><p>其初始化容量为 <code>16</code>, 负载因子为 <code>0.75</code>，其扩容函数 (<code>resize</code>)如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (oldCap &gt; 0) &#123;</span><br><span class="line">    if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其容量扩大为原来的<strong>2</strong>倍。</p><h5 id="6-1-2_如何存储键为_null_的键值对？">6.1.2 如何存储键为 <code>null</code> 的键值对？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，用于生成一个 <code>key</code> 的 <code>hashCode</code> ，可以发现如果 <code>Key</code> 为 <code>null</code>，则为 <code>0</code>，则会存在 <code>table</code> 中的第一个数据上。</p><h4 id="6-2_TreeMap的实现？">6.2 TreeMap的实现？</h4><p>基于红黑树进行实现</p><h4 id="6-3_LinkedHashMap的实现？">6.3 LinkedHashMap的实现？</h4><p>继承自 <code>HashMap</code>，功能上与<code>HashMap</code>完全一样，但是<code>LinkedHashMap</code>能够保证遍历的顺序与插入时的顺序一致。其内部维护了一下双向链表，在<code>Entry</code>中保留了<code>before</code>和<code>after</code>的引用。注意在<code>LinkedHashMap</code>有一个<code>accessOrder</code>，当为<code>true</code>时，整个链表按照使用的顺序进行排序; 当为<code>false</code>时，整个链表按插入的顺序进行排序，这也是默认的顺序。可以结合<code>removeEldestEntry</code>实现一个<code>LRU</code>缓存。</p><h4 id="6-4_WeakHashMap的实现？">6.4  WeakHashMap的实现？</h4><p>通过<code>WeakReference</code>和<code>ReferenceQueue</code>，实现键的弱引用。</p><h4 id="6-5_HashMap和Hashtable的区别？">6.5 HashMap和Hashtable的区别？</h4><ul><li><p>共同点：<br> 从存储结构和实现来讲基本上都是相同的，都是实现Map接口</p></li><li><p>区别：</p><ul><li>同步性<br> HashMap是非同步的<br> Hashtable是同步的</li><li>是否允许为null<ul><li>HashMap允许为null</li><li>Hashtable不允许为null</li></ul></li><li>contains方法<ul><li>Hashtable有contains方法</li><li>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</li></ul></li><li>继承不同：<ul><li>HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</li><li>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</li></ul></li></ul></li></ul><h3 id="七、集合的_fail-fast_机制">七、集合的 <code>fail-fast</code> 机制</h3><p><code>fail-fast</code> 是指当通过 <code>Iterator</code> 去遍历集合时，如果存在另一个线程同时去修改该集合，将会抛出一个 <code>ConcurrentModificationException</code> 的异常，这种行为被称为 <code>fail-fast</code>。以下用 <code>ArrayList</code> 举例，可以发现其迭代器如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        // ..</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;</span><br><span class="line">        // ..</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在调用 <code>next()</code> 时，会调用 <code>checkForComodification()</code> 函数，该函数仅仅用于比较 <code>expectedModCount</code> 与 <code>modCount</code>是否相等。<code>modCount</code> 是 <code>ArrayList</code> 中的一个变量，当创建 <code>Itr</code> 这个迭代器时，将会为 <code>expectedModCount</code> 赋值。也就是说当 <code>modCount</code> 改变时，将会触发 <code>fail-fast</code> 机制。那什么地方会修改 <code>modCount</code> 呢？在 <code>ArrayList</code> 有如下的代码:</p><p>其增加方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line"> //..</span><br><span class="line">&#125;</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    // ..</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">// ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其删除方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"> // ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>clear</code> 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">// ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其增加、删除的操作，都会影响 <code>modCount</code>，即所有的影响集合大小的操作，都将使 <code>modCount</code> 改变。</p><h3 id="八、集合的_fail-safe_机制">八、集合的 <code>fail-safe</code> 机制</h3><p><code>fail-safe</code>与<code>fail-fast</code>相对应，<code>fail-fast</code>用于避免用户并发修改数据，而<code>fail-safe</code>则是为保证让用户能够并发地访问及修改数据，当然如果可以并发修改数据，也就不会抛出<code>ConcurrentModificationException</code>。以下就简单地分析一下并发集合<code>ConcurrentHashMap</code>是如何处理的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// P1</span><br><span class="line">static final class EntryIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt;</span><br><span class="line">        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public final Map.Entry&lt;K,V&gt; next() &#123;</span><br><span class="line">        Node&lt;K,V&gt; p;</span><br><span class="line">        if ((p = next) == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        K k = p.key;</span><br><span class="line">        V v = p.val;</span><br><span class="line">        lastReturned = p;</span><br><span class="line">        advance();</span><br><span class="line">        return new MapEntry&lt;K,V&gt;(k, v, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// P2</span><br><span class="line">static class BaseIterator&lt;K,V&gt; extends Traverser&lt;K,V&gt; &#123;</span><br><span class="line">        final ConcurrentHashMap&lt;K,V&gt; map;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public final void remove() &#123;</span><br><span class="line">        Node&lt;K,V&gt; p;</span><br><span class="line">        if ((p = lastReturned) == null)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        lastReturned = null;</span><br><span class="line">        map.replaceNode(p.key, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>fail-fast</code>中，主要关注的其<code>iterator</code>，而<code>iterator</code>的关键点在于其<code>remove</code>方法的处理方式。在<code>ConcurrentHashMap</code>中<code>iterator</code>的本质就是<code>EntryIterator</code>对象，通过代码可以看到，其删除操作，并不是一个真正的删除，而是临时将对象的值设置为null，所以<code>ConcurrentHashMap</code>不能存值为NULL的对象。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-TimSort</title>
      <link href="/Java/Java/Java-TimSort/"/>
      <url>/Java/Java/Java-TimSort/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>(一) 介绍</p><ul><li>TimSort是结合了合并排序和插入排序而得出的排序算法。</li><li>TimSort算法是为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序的特点进行了分区。</li><li>Arrays.sort 就是使用的 TimSort</li><li>TimSort是一个稳定的算法，当待排序的数组中已经有排序好的数，它的时间复杂度会小于 <code>nlogn</code></li></ul><p>(二) 概念:</p><ul><li><code>run</code><br>待排序数据中有序的数据段</li><li><code>Galloping Model</code><br>假设在归并过程中有两个数列，比较的时候，有个数列连续有 <code>MIN_GALLOP</code> 个元素都比另一个数列的第一个元素小，那不应该数一下后面到底还有多少个元素比另一个数列的第一元素小，数完后一次复制过去，减少复制次数</li></ul><p>(三) 基本步骤:</p><ol><li>如果数组长度小于某个值，直接用插入排序算法</li><li>找到各个 <code>run</code>，并入栈</li><li>按规则合并 <code>run</code></li></ol><h3 id="1-_源码分析">1. 源码分析</h3><ol><li>属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 当每一个 `run` 小于 `MIN_MERGE` 时，将采取二分插入排序</span><br><span class="line">private static final int MIN_MERGE = 32;</span><br><span class="line"></span><br><span class="line">// 在 `Merge` 的过程中，如果存在连续 `MIN_GALLOP` 个都比另一个数列的第一个元素小将采用 `GALLOP Model`</span><br><span class="line">private static final int  MIN_GALLOP = 7;</span><br><span class="line">private static final int INITIAL_TMP_STORAGE_LENGTH = 256;</span><br><span class="line"></span><br><span class="line">// 待排序的数据</span><br><span class="line">private final T[] a;</span><br><span class="line"></span><br><span class="line">// 比较函数</span><br><span class="line">private final Comparator&lt;? super T&gt; c;</span><br><span class="line"></span><br><span class="line">// Gallop 的最小连续个数</span><br><span class="line">private int minGallop = MIN_GALLOP;</span><br><span class="line"></span><br><span class="line">// tmp</span><br><span class="line">private T[] tmp;</span><br><span class="line">private int tmpBase; // base of tmp array slice</span><br><span class="line">private int tmpLen;  // length of tmp array slice</span><br><span class="line"></span><br><span class="line">// stack, runBase记录起始位置, runLen记录长度</span><br><span class="line">private int stackSize = 0;  // Number of pending runs on stack</span><br><span class="line">private final int[] runBase;</span><br><span class="line">private final int[] runLen;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private TimSort(T[] a, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen) &#123;</span><br><span class="line">    this.a = a;</span><br><span class="line">    this.c = c;</span><br><span class="line">    int len = a.length;</span><br><span class="line">    int tlen = (len &lt; 2 * INITIAL_TMP_STORAGE_LENGTH) ?</span><br><span class="line">        len &gt;&gt;&gt; 1 : INITIAL_TMP_STORAGE_LENGTH;</span><br><span class="line">    if (work == null || workLen &lt; tlen || workBase + tlen &gt; work.length) &#123;</span><br><span class="line">        T[] newArray = (T[])java.lang.reflect.Array.newInstance</span><br><span class="line">            (a.getClass().getComponentType(), tlen);</span><br><span class="line">        tmp = newArray;</span><br><span class="line">        tmpBase = 0;</span><br><span class="line">        tmpLen = tlen;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        tmp = work;</span><br><span class="line">        tmpBase = workBase;</span><br><span class="line">        tmpLen = workLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int stackLen = (len &lt;    120  ?  5 :</span><br><span class="line">                    len &lt;   1542  ? 10 :</span><br><span class="line">                    len &lt; 119151  ? 24 : 49);</span><br><span class="line">    runBase = new int[stackLen];</span><br><span class="line">    runLen = new int[stackLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Sort </tag>
            
            <tag> Arrays </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-桥接方法</title>
      <link href="/Java/Java/Java-%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/"/>
      <url>/Java/Java/Java-%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="0-_桥接方法出现的条件">0. 桥接方法出现的条件</h3><p>在java5之前，你可以向集合内放入任何对象，但是你从集合内里取对象时，却只能取出Object的对象，那么你也只有调用Object的方法。在java5中，引入了泛型，就能够解决这个问题。但是如何兼容老版本呢？所以就引入了桥接方法，如果是一个泛型的函数，那么它就会同时，提供一个Object的方法，该方法就称为桥接方法。</p><h3 id="1-_例子">1. 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">class P&lt;T&gt; &#123;</span><br><span class="line">public T test (T t)&#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends P&lt;String&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public String test(String t) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Class&lt;?&gt; clazz = S.class;</span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line">Arrays.asList(methods).stream().forEach( m  -&gt; &#123;</span><br><span class="line">System.out.println(m.getName());</span><br><span class="line">System.out.println(Arrays.toString(m.getParameterTypes()));</span><br><span class="line">System.out.println(m.isBridge());</span><br><span class="line">System.out.println(&quot;====================&quot;);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果就能看出编译器自动添加了一个方法，那么class S的方法就会有两个，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class S extends P&lt;String&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public String test(String t) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object test(Object t) &#123;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<code>public Object test(Object t)</code>，这个方法就是桥接方法。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> Generic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个服务器搭多个tomcat导致session丢失</title>
      <link href="/J2ee/J2ee/%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%A4%9A%E4%B8%AAtomcat%E5%AF%BC%E8%87%B4session%E4%B8%A2%E5%A4%B1/"/>
      <url>/J2ee/J2ee/%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%A4%9A%E4%B8%AAtomcat%E5%AF%BC%E8%87%B4session%E4%B8%A2%E5%A4%B1/</url>
      <content type="html"><![CDATA[<h3 id="1-_问题">1. 问题</h3><p>一个服务器上搭建了多个tomcat，端口不一样。例如：在机器上有A，B两个服务，分别在不同的端口上，在浏览器中登录访问A，再打开一个标签页访问B服务，再回过来点击访问A时，需要重新登录A才可以访问。</p><h3 id="2-_原因">2. 原因</h3><p>IP相同，浏览器即认为是同一个域，接收了B的set-cookie指令，把对应的cookie内容覆盖了，其中包括jsessionid，造成A的session丢失。</p><h3 id="3-_解决办法">3. 解决办法</h3><ol><li>将不同的多个应用服务在不现的虚拟主机中，或者映射不同的IP/域名进行部署</li><li>对应的Tomcat服务处理方式：修改cookie的名称保证cookie不重复，即jsessionid的不重名，保证IP相同下session cookiename不同</li></ol>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> Session </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-SPI</title>
      <link href="/Java/Java/Java-SPI/"/>
      <url>/Java/Java/Java-SPI/</url>
      <content type="html"><![CDATA[<h3 id="0-_SPI简介">0. SPI简介</h3><ul><li>Service Provider Interface</li><li>Java SE6，开始提供的API，可以帮助你查找、加载和使用服务</li><li>原理:<ol><li>ServiceLoader会在jar包的META-INF/services目录去检测是否存在程序提供的配置文件</li><li>如果有，就会存在这样一个约定，文件名，就对应着程序中的一个接口名(完整包名，包含Package信息), 文件中的每一行，表明是其接口的实现类</li></ol></li><li>作用:<br>在一般情况下, 其services目录下的文件内容，只会有一条。其实这就是一种策略模式，只不过这种策略模式的实现，是通过配置文件来实现的。</li></ul><h3 id="1-_例子">1. 例子</h3><p>接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IAnimal &#123;</span><br><span class="line">    void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements IAnimal &#123;</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵喵喵喵喵....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog implements IAnimal &#123;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪汪汪汪汪....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;IAnimal&gt; serviceLoader = ServiceLoader.load(IAnimal.class);</span><br><span class="line">        for(IAnimal animal : serviceLoader) &#123;</span><br><span class="line">            animal.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>因为我所有的类，都在根目录下，所以不需要加包名</li><li>META-INF/services目录，需要放在resources目录下，maven就会自动打包进jar中</li><li>需要在META-INF/MANIFEST.MF文件中新增加一行 <code>Main-Class: test</code> 表示入口函数的类，如果有包名，则应该带包名</li></ol>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC, MVP, MVVM</title>
      <link href="/J2ee/J2ee/MVC,%20MVP,%20MVVM/"/>
      <url>/J2ee/J2ee/MVC,%20MVP,%20MVVM/</url>
      <content type="html"><![CDATA[<h3 id="1-_MVC">1. MVC</h3><center><img src="/pics/mvc.png" alt=""></center><h3 id="2-_MVP">2. MVP</h3><center><img src="/pics/mvp.png" alt=""></center><h3 id="3-_MVVM">3. MVVM</h3><center><img src="/pics/mvvm.png" alt=""></center><h3 id="4-_区别">4. 区别</h3><p>区别在于它们的相互模式不一样</p>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaBean规范</title>
      <link href="/J2ee/J2ee/JavaBean%E8%A7%84%E8%8C%83/"/>
      <url>/J2ee/J2ee/JavaBean%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h3 id="0-_什么是JavaBean?">0. 什么是JavaBean?</h3><p>JavaBean就是一种规范，JavaBean类与普通的类本质上没有什么区别</p><h3 id="1-_类规范">1. 类规范</h3><ol><li>必须是一个public类</li><li>必须有一个空的构造函数</li><li>属性私有，应该通过一组存取方法( <code>getXXX</code>, <code>setXXX</code>, <code>isXXX</code>)来访问</li><li>实现序列化接口</li></ol><h3 id="2-_属性规范">2. 属性规范</h3><ul><li>属性为private</li><li>以小写字母开头</li><li>以驼峰命名</li></ul><h3 id="3-_特殊情况">3. 特殊情况</h3><ul><li>属性的第二个字母为大写<br>该属性名直接用作 <code>getter/setter</code> 方法中 <code>get/set</code> 的后部分，如 <code>uName</code>,方法名为 <code>getuName/setuName</code></li><li>属性的前两个字母是大写<br>属性名直接用作 <code>getter/setter</code> 方法名中的后部分，如URL，方法是 <code>getURL/setURL</code></li><li>首字母大写<br>直接用作用 <code>getter/setter</code> 方法中的 <code>get/set</code> 的后部分，如 <code>Name</code>，方法是 <code>getName/setName</code>，这种情况下，会找不到属性出错，因为默认的属性名是 <code>name</code></li><li>属性的前两个字母是 <code>is</code>，并且类型是 <code>boolean</code>(非Boolean类型)<br>根据 <code>JavaBean</code> 规范，如果类型是 <code>boolean</code> (非 <code>Boolean</code> 类型)类型时，那么其方法为 <code>isXXX/setXXX</code>, 所以如果你的类型既为 <code>boolean</code> (非 <code>Boolean</code> 类型)，而且前缀是 <code>is</code> 的话，那么它所对应的方法就是 <code>isXXX/setXXX</code>，例如 <code>isOk/setOk</code> 而当反解析的时候，它解析出来的类型是 <code>ok</code>，所以它对应的属性为 <code>boolean ok</code>，此时结果出错。</li></ul><h3 id="4-_注意点">4. 注意点</h3><ol><li>属性命名尽量使用驼峰式命名规则</li><li>属性名第一个单词尽量避免使用一个字母</li><li>boolean属性避免使用 <code>is</code> 开头的名称</li><li>尽量使用包装类型，而不是原生类型，如 <code>boolean</code>，应该使用 <code>Boolean</code></li></ol>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> JavaBean </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>REST</title>
      <link href="/J2ee/J2ee/RESTful/"/>
      <url>/J2ee/J2ee/RESTful/</url>
      <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol><li><code>REST</code>, <code>Representational State Transfer</code>，表现层状态转移</li><li><code>REST</code> 描述了一个架构样式</li><li>如果一个架构符合 <code>REST</code> 原则，就称它为 <code>RESTful</code> 架构</li></ol><h3 id="二-_REST">二. REST</h3><ol><li><p>关键字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资源               : Resource</span><br><span class="line">资源的多重表现形式  : Representation</span><br><span class="line">统一接口           : Uniform Interface</span><br><span class="line">状态转移           : State Transfer</span><br></pre></td></tr></table></figure></li><li><p>原则</p><ul><li>资源<br>所有需要请求的数据都为资源，每一个资源都会有一个惟一资源标识符(<code>Resource Indentifier</code>)</li><li>资源的多重表现形式<br>同一种资源，会存在多种的表现形式，比如文本，<code>json，word</code> 等, 通过 <code>Content-Type</code> 设置返回类型</li><li>统一接口<br><code>GET/POST/DELETE/PUT</code>，分别代表着对资源的操作方式，<code>GET</code>, 用于获取数据; <code>POST</code>, 用于更新数据; <code>PUT</code>, 用于增加数据; <code>DELETE</code>, 用于删除数据;</li><li>状态转移  <ul><li>表明数据的状态，通过一个操作，转换成另一个状态</li><li>无状态, Stateless，是指在状态转换的过程中，客户端与服务器都不存储当前的状态信息，服务器所有需要的数据，都在请求地址中</li></ul></li></ul></li><li>要求<ul><li>能够方便地增加缓存层，提高网络性能，即需要具体良好的分层架构</li><li>能够从服务器直接下载代码，对客户端进行扩展</li><li>因为无状态，服务器所有需要的数据都在请求地址中，所以可以无缝地在不同主机间进行切换</li></ul></li><li>特点<ul><li>面向资源<br>Resource Oriented，REST架构设计是以资源抽象为核心展开的</li><li>可寻址<br>Addressability，每一个资源在Web之上都有自己的地址</li><li>连通性<br>Connectedness，应该尽量避免设计孤立的资源，除了设计资源本身，还需要设计资源之间的关联关系，并且通过超链接将资源关联起来。</li><li>无状态<br>Statelessness</li><li>统一接口<br>Uniform Interface</li><li>超文本驱动<br>Hypertext Driven</li></ul></li></ol><h3 id="三-_其它">三. 其它</h3><ol><li><p>RESTful架构的典型设计误区：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. URI包含动词   ：一切都是资源，不能存在动作</span><br><span class="line">2. URI包含版本号 ：可以放在Accept部分</span><br></pre></td></tr></table></figure></li><li><p>从架构风格的抽象高度来看，常见的分布式应用架构风格有三种：</p><ul><li>分布式对象<br><code>Distributed Objects</code>，简称DO, 架构实例有 <code>CORBA/RMI/EJB/DCOM/.NET Remoting</code> 等等</li><li>远程过程调用<br>Remote Procedure Call，简称RPC, 架构实例有 <code>SOAP/XML-RPC/Hessian/Flash AMF/DWR</code> 等等</li><li>表述性状态转移<br>Representational State Transfer，简称REST</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> REST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Session与Cookie</title>
      <link href="/J2ee/J2ee/Session-Cookie/"/>
      <url>/J2ee/J2ee/Session-Cookie/</url>
      <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><ol><li>Session<br>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息</li><li>Cookie<br>由服务器端生成，发送给User-Agent，浏览器会将Cookie的key/value保存到某个目录下，下次请求同一网站时就发送该Cookie给服务器(启用Cookie)。</li><li>区别<ol><li>Request的生命周期是一个请求，请求结束，则request结束</li><li>Session的生命周期是session会话域，打开一个浏览器请求一个网站后的而后，Session开始，当session超时后，session注销而失效，或是人为使用 <code>session.invalidate()</code></li><li>Cookie存放在本地，安全性低</li><li>Session存放在服务器，安全性高</li></ol></li></ol><h3 id="1-_Cookie">1. Cookie</h3><ul><li>背景<br>HTTP协议是无状态的，一旦数据交换完成，客户端与服务器的连接就会关闭，再次交换数据时，需要建立新的连接。意味着服务器无法从连接上跟踪某会话。Cookie主要就是解决跟踪会话的问题。</li><li>作用<br>指某些网站为了辨别用户身份、进行 <code>session</code> 跟踪而储存在用户本地终端上的数据（通常经过加密）。</li><li>过程<br>Cookie实际上是一小段文本信息，客户端请求服务器，如果服务器需要记录该用户 状态，就会使用 response 向客户端颁发一个 Cookie，客户端浏览器会把Cookie保存下来，当浏览器再次请求网站时，浏览器把请求的网址连同Cookie一同提交给服务器，服务器根据Cookie，用于辩论用户状态。</li><li>Cookie的不可跨域性<br>请求某一个网站时，只会带自己网站的Cookie，有点类似于同源策略</li><li>分类<ul><li>会话Cookie<br>不设置过期时间，则表示这个 Cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口， Cookie 就消失了</li><li>持久化Cookie<br>设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些 Cookie 依然有效直到超过设定的过期时间</li></ul></li></ul><h3 id="2-_Session">2. Session</h3><ul><li>创建时机<br>当调用 <code>javax.servlet.http.HttpServletRequest.getSession(boolean create)</code> 才创建session, 并不是客户端一发起请求就创建 <code>Session</code></li><li>Session机制<br>当服务器为请求创建session时，会检查请求中是否带有 <code>jsessionid</code>, 如果存在，就根据 <code>SessionId</code> 检索出来，否则是新建。而一般 <code>jessionid</code> 是通过cookie带过来的，在手机上，如果禁用Cookie, 就直接将 <code>jessionid</code> 写在请求的Url上，这就是被称为 “URL重写技术”</li><li>Session在服务如何存储<br>Session存储在内存中，可以配置Tomcat从而共享Session</li></ul><h3 id="3-_Session同步">3. Session同步</h3><ul><li>问题<br>当今很多大型的网站，都会采用一种SOA架构，但是随之也带来一个问题，各个服务部署在不同的主机上，我希望只登录一次账户，其它所有服务都能使用</li><li>解决方案  <ul><li>Session同步<br>通过Redis 或者 Memcache 共享Session</li><li>SSO(单点登录)<br>实现方式就多种多样了，推广得比较好的是 <code>cas</code>，基本质就是利用 Cookie 从而达到一次登录，处处访问的目的</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> Session </tag>
            
            <tag> Cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring mvc 中ref和idref之间的区别</title>
      <link href="/J2ee/J2ee/Spring%20Idref%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/J2ee/J2ee/Spring%20Idref%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="(一)_问题">(一) 问题</h3><p>在<code>Spring</code>中，<code>idref</code>属性和<code>ref</code>属性都可以用在<code>constructor-arg</code>元素和<code>property</code>元素中完成注入，那么它之间有什么区别呢？</p><p>对比如下一段配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bea&quot; class=&quot;java.lang.String&quot;&gt;</span><br><span class="line"> &lt;constructor-arg index=&quot;0&quot;&gt;&lt;value&gt;testString&lt;/value&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;beanID&quot; class=&quot;com.zyh.spring3.hello.HelloWorld&quot;&gt;</span><br><span class="line"> &lt;constructor-arg name=&quot;name&quot;&gt;&lt;idref bean=&quot;bea&quot; /&gt;&lt;/constructor-arg&gt;</span><br><span class="line"> &lt;property name=&quot;id&quot;&gt;</span><br><span class="line">  &lt;ref local=&quot;bea&quot; /&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line"> &lt;property name=&quot;age&quot; value=&quot;25&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="(二)_分析">(二) 分析</h3><p>其实，<code>idref</code>注入的是目标<code>bean</code>的<code>ID</code>而不是目标<code>bean</code>的实例，同时使用<code>idref</code>容器在部署的时候还会验证这个名称的<code>bean</code>是否真实存在。其实<code>idref</code>就跟<code>value</code>一样，只是将某个字符串注入到属性或者构造函数中，只不过注入的是某个<code>Bean</code>定义的<code>id</code>属性值。所以上面的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;&lt;idref bean=&quot;bea&quot; /&gt;&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure><p>其实等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg name=&quot;name&quot;&gt;&lt;value&gt;bea&lt;/value&gt;&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure><p>而<code>ref</code>则是完全地不同，<code>ref</code>元素是将目标<code>Bean</code>定义的实例注入到属性或构造函数中。<code>ref</code>有如下三个属性：</p><ol><li><code>local</code><br><br>只能指定与当前配置的Bean在同一个配置文件中的Bean定义的名称；</li><li><code>parent</code><br><br>只能指定位于当前容器的父容器中定义的对象引用；</li><li><code>bean</code><br><br>基本上通吃，即包括以上两种情况都可以，所以，通吃情况下，直接使用<code>bean</code>来指定对象引用就可以了。</li></ol><p>所以，上面那段配置代码中，<code>beanID</code>这个<code>Bean</code>中构造函数的参数<code>name</code>注入的只是<code>bea</code>这个字符串；而其<code>id</code>属性注入的则是<code>testString</code>这个字符串。</p>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSO-CAS基础</title>
      <link href="/J2ee/J2ee/sso/"/>
      <url>/J2ee/J2ee/sso/</url>
      <content type="html"><![CDATA[<h2 id="1-_基本概念">1. 基本概念</h2><ol><li>SSO, Single Sign On，单点登录</li><li>SLO, Single Sign Out / Single Log-out, 单点登出</li><li>CAS, Central Authentication Service, 中心认证服务</li></ol><h2 id="2-_背景">2. 背景</h2><p>在一个互信的网络中，用户只需要登录一次，就可以访问所有网站，而不用多次重复登录。</p><h2 id="3-_SSO常见的解决方案">3. SSO常见的解决方案</h2><ol><li>Sun SSO</li><li>OpenSSO &amp; OpenAM</li><li>CAS</li><li>SAML</li><li>IBM TAM</li></ol><h2 id="4-_CAS">4. CAS</h2><p>CAS是Yale大学发起的一个开源项目，旨在为Web应用系统提供一种可靠的单点登录方法。CAS2.0以前的版本，是由Yale大学开学的，后来由JASIG继续开发。</p><h3 id="4-1_CAS中的概念">4.1 CAS中的概念</h3><ol><li>ST<br>Service Ticket，服务票据，服务的惟一标识码，由CAS Server生成，一个服务只有有一个惟一的ST</li><li>PT<br>Proxy Ticket， 是应用程序代理用户身份对目标程序进行访问的凭证</li><li>PGT<br>Proxy Granting Ticket， 由 CAS Server 颁发给拥有ST凭证的服务，PGT绑定一个用户的特定服务，使其拥有向 CAS Server 申请 PT 的能力</li><li>TGC<br>Ticket Granting Cookie，存放用户身份认证凭证的Cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输(Https)</li><li>PGTIOU<br>Proxy Granting Ticket I Owe You, 通过凭证检验时的应答信息由CAS Server返回给 CAS Client，同时，与该 PGTIOU 对应的 PGT将通过回调链接传给 Web 应用。 Web应用负责维护 PGTIOU 与 PGT之间映射关系的内容表。</li><li>TGT<br>Ticket Granting Ticket， 票据授权票据，由 KDC 的 AS 发放，即获取一张票据后，以后申请各种上其他服务票据 (ST) 将不必再向 KDC 提交身份认证信息;</li><li>AS<br>认证服务，索取 Credentials， 发放 TGT</li><li>TGS<br>票据授权服务，索取TGT，发放ST</li><li>KDC<br>Key Distribution Center, 密钥发放中心</li></ol><h3 id="4-2_CAS如何保障安全">4.2 CAS如何保障安全</h3><ol><li>TGC / PGT 安全性<br>TGC / PGT 通过 SSL方式进行传输， TGC的存活周期默认为120分钟</li><li>ST / PT 安全性<br>ST， 是通过Http传送的，而CAS通过以下几个方面使用ST变得更加安全：<ol><li>ST只能使用一次</li><li>ST在一段时间内失效，默认有效时间为5分钟</li><li>ST是基于随机数生成的</li></ol></li></ol><h3 id="4-3_CAS组成">4.3 CAS组成</h3><ol><li>CAS Server<ul><li>用户认证</li><li>SSO Session的生成，即TGT的生成， ST 是一个服务的Token</li></ul></li><li>CAS Client<ul><li>通过协议与 CAS Server 沟通</li></ul></li></ol><h3 id="4-4_CAS_Server支持的协议">4.4 CAS Server支持的协议</h3><ul><li>CAS(version 1, 2, 3)</li><li>SAML 1.1</li><li>OpenID</li><li>OAuth(1.0, 2.0)</li></ul><h3 id="4-5_整个流程">4.5 整个流程</h3><center><img src="/pics/CAS时序图.jpg" alt=""></center><p>注意 <code>SSO</code> 与 <code>Session</code> 共享是完全不一样的概念，当客户端拿着 <code>ST</code> 向登录服务器验证成功后，会在客户端本地生成 <code>Session</code>。例如两个Tomcat的应用的 <code>appX</code>, <code>appY</code>，当<code>appX</code> 通过登录服务器成功登录后，会在浏览器中存储 <code>TGC</code>，下次访问 <code>appY</code> 时，发现在 <code>appY</code> 中没有已经登录的相关信息，此时浏览器就会重定向到登录服务器，在访问登录服务器时，会带上 <code>TGC</code> ，登录服务器根据 <code>TGC</code> 找到对应的 <code>TGT</code>，然后在做相应的验证后，如果成功后，将返回一个 <code>ST</code>，此时的 <code>appY</code> 拿着 <code>ST</code> 验证成功后，将在 <code>Session</code> 记录已经登录的信息。</p><h3 id="4-6_CAS的可扩展点">4.6 CAS的可扩展点</h3><ol><li>可以将TGT用redis或者memcache进行缓存，这样就能解决只有一台服务器的热点问题</li></ol>]]></content>
      
      <categories>
          
          <category> J2ee </category>
          
      </categories>
      
      
        <tags>
            
            <tag> J2ee </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring MVC项目中抛出的</title>
      <link href="/Web/J2ee/Hibernate%E7%9A%84Spring%20MVC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84/"/>
      <url>/Web/J2ee/Hibernate%E7%9A%84Spring%20MVC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84/</url>
      <content type="html"><![CDATA[<h3 id="0-_LazyinitializationException">0. LazyinitializationException</h3><p>在Hibernate的工程中，会遇到LazyinitializationException。是因为在Controller和model层，通过JPA启用了延迟加载功能。在返前view层时，由于JPA Session已经关闭，导致这些延迟加载的数据访问异常。</p><h3 id="1-_解决方法">1. 解决方法</h3><p>在web.xml中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;openEntityManagerInViewFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;openEntityManagerInViewFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h3 id="2-_OpenEntityManagerInViewFilter">2. OpenEntityManagerInViewFilter</h3><ol><li>处理过程<ol><li>OpenEntityManagerInViewFilter拦截Servlet请求</li><li>OpenEntityManagerInViewFilter获取EntityManager并且将它绑定到当前线程</li><li>调用Controller</li><li>调用Service</li><li>创建一个新的事务，并从当前LocalThread中获取EntityManager,并且绑定到当前事务</li><li>Service处理一些业务，并且返回</li><li>事务拦截器刷新EntityManager并且提交事务</li><li>Controller准备View，返回</li><li>View创建成功</li><li>OpenEntityManagerInViewFilter关闭EntityManager并且与当前线程解绑</li></ol></li><li>存在的问题<ol><li>懒加载会导致产生多个事务，并影响到性能</li><li>懒加载会导致取数据的异常</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何让ets的数据不丢失？</title>
      <link href="/Erlang/Erlang/%E5%A6%82%E4%BD%95%E8%AE%A9ets%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
      <url>/Erlang/Erlang/%E5%A6%82%E4%BD%95%E8%AE%A9ets%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
      <content type="html"><![CDATA[<h3 id="0-_问题">0. 问题</h3><p>因为ets与创建进程相关联，当相关进程关闭时，ets中的数据也会随之删除，虽然进程可以重启，但是如何恢复ets的数据呢？</p><h3 id="1-_可选方案">1. 可选方案</h3><ol><li>指定一个继承者，即当相关进程关闭时，就将ets的相关进程指定为另一个Pid，然后下次再从某处再次得到ets，即设置 <code>heir</code> 属性</li><li>ets:give_away/3，当崩溃时，捕捉崩溃消息，然后将ets的相关进程指定为别一个进程，下次再次取数据</li><li>创建supervisor,然后在supervisor中创建ets，让supervisor拥有ets，并将ets的权限设置为public，这样其子进程就可以直接操作ets，但是子进程的崩溃，不会引起ets的数据的崩溃</li></ol><h3 id="2-_最终方案">2. 最终方案</h3><ol><li>创建一个 <code>supervisor</code>，并在 <code>supervisor</code> 中创建 <code>ets</code>，并不用将 <code>ets</code> 设置为 <code>public</code>，并将 <code>heir</code> 属性设置为<code>supervisor</code></li><li>然后创建子进程，然后将 <code>ets</code> 的拥有权交给子进程</li><li>当子进程崩溃时，会自动将 <code>ets</code> 的拥有权交给 <code>supervisor</code></li><li><code>supervisor</code> 再次启动子进程，再次将 <code>ets</code> 的权限交给子进程就可以达到恢复数据的目的</li></ol>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Erlang </tag>
            
            <tag> ets </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>A,B节点互联,我在A节点通过rpc call在B节点执行函数,如何让结果在B节点输出呢?</title>
      <link href="/Erlang/Erlang/%E8%8A%82%E7%82%B9%E9%97%B4%E4%BA%A4%E4%BA%92/"/>
      <url>/Erlang/Erlang/%E8%8A%82%E7%82%B9%E9%97%B4%E4%BA%A4%E4%BA%92/</url>
      <content type="html"><![CDATA[<h3 id="0-_问题">0. 问题</h3><p>A,B节点互联,我在A节点通过rpc call在B节点执行函数,如何让结果在B节点输出呢?</p><h3 id="1-_分析">1. 分析</h3><p>大家都清楚io:format，这个函数是将消息发送给group leader，然后再输出，如果我们将A节点的group leader设置成B节点的user(Erlang Shell的控制台的group leader)是不是就可以在B节点的控制台输出信息</p><h3 id="2-_步骤">2. 步骤</h3><ol><li><p>test.erl</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-module(test).</span><br><span class="line">-compile([export_all]).</span><br><span class="line">r() -&gt;</span><br><span class="line">   io:format(&quot;group leader:~p~n&quot;, [erlang:group_leader()]),</span><br><span class="line">   io:format(&quot;node:~p~n&quot;, [node()]),</span><br><span class="line">   erlang:group_leader(whereis(user), self()),</span><br><span class="line">   io:format(&quot;hello world~n&quot;).</span><br></pre></td></tr></table></figure></li><li><p>创建两个节点:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erl -sname t1</span><br><span class="line">erl -snmae t2</span><br></pre></td></tr></table></figure></li><li><p>在t1中执行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net_kernel:connect_node(&apos;t2@litao&apos;). % 此处写你主机的名字</span><br><span class="line">rpc:call(&apos;t2@litao&apos;, test, r, []).</span><br></pre></td></tr></table></figure></li><li><p>将会在t2看到 <code>hello world</code></p></li></ol>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Erlang </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远程接入Erlang控制台的方法</title>
      <link href="/Erlang/Erlang/%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%85%A5Erlang%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/Erlang/Erlang/%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%85%A5Erlang%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="一-_JCL">一. JCL</h3><ol><li>JCL，即 <code>Job Control Mode</code>，用于两个节点间，一个节点连接上另一个节点，并在另一个节点上执行操作</li><li><p>如何使用JCL：</p><ol><li>分别创建两个node</li><li><code>Ctrl+G</code></li><li><p>输入操作命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c [nn]            - connect to job</span><br><span class="line">i [nn]            - interrupt job</span><br><span class="line">k [nn]            - kill job</span><br><span class="line">j                 - list all jobs</span><br><span class="line">s [shell]         - start local shell</span><br><span class="line">r [node [shell]]  - start remote shell</span><br><span class="line">q                 - quit erlang</span><br><span class="line">? | h             - this message</span><br></pre></td></tr></table></figure></li></ol></li><li><p>例子</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%% 在JCL命令模式下的输入， hawk@dj，是另一个节点</span><br><span class="line">1. c hawk@dj</span><br><span class="line">2. j</span><br><span class="line">3. c 2</span><br></pre></td></tr></table></figure></li></ol><h3 id="二-_remsh参数">二. remsh参数</h3><p><code>erl -sname dd -remsh hawk@dj</code>  </p><p>注意： 此方法与JCL一样，所以关闭时，不能直接q(),必须再次进入到JCL中，输入q退出， 或者直接Ctrl+C</p><h3 id="三-_erl_call，_是基于erl_interface">三. erl_call， 是基于erl_interface</h3><ol><li><p>参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a 执行erlang:apply/3,需要提供的就是m f a,m是必须的,f默认值start,a默认值[].</span><br><span class="line">-c 执行cookie值如果没有指定就会使用 ~/.erlang.cookie 文件中定义的cookie</span><br><span class="line">-d 调试模式;所有的IO都会输出到~/.erl_call.out.Nodename文件,其中NodeName就是我们要处理的erlang节点名;</span><br><span class="line">-e 读一系列的Erlang表达式并返回最后一个表达式的结果,这些表达式用&apos;,&apos;分隔,&apos;.&apos;结束.</span><br><span class="line">-h HiddenName 隐藏erl_call代表的节点</span><br><span class="line">-m 读入并编译一个module</span><br><span class="line">-n -name -sname 这三个参数三选一,name和n是同样的含义是为了兼容依然保留,sname代码短名称</span><br><span class="line">-q 停止Erlang节点</span><br><span class="line">-r 为erl_call生一个随机name</span><br><span class="line">-s 必要的话启动一个Erlang的分布式节点,意思是自由第一个调用会启动一个Erlang节点后续的调用就会快很多.</span><br><span class="line">-v 多打印一些冗余信息</span><br><span class="line">-x ErlScript:指定Erlang启动脚本如果不指定就是用erl start-up脚本</span><br></pre></td></tr></table></figure></li><li><p>例子<br>热更新:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/erl/lib/erlang/lib/erl_interface-3.7.17/bin/erl_call -sname run -a &apos;release_handler unpack_release [&quot;server_1.0.2&quot;]&apos;</span><br><span class="line">/usr/local/erl/lib/erlang/lib/erl_interface-3.7.17/bin/erl_call -sname run -a &apos;release_handler install_release [&quot;1.0.2&quot;]&apos;</span><br><span class="line">/usr/local/erl/lib/erlang/lib/erl_interface-3.7.17/bin/erl_call -sname run -a &apos;release_handler make_permanent [&quot;1.0.2&quot;]&apos;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Erlang </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Erlang编译流程及中间形态</title>
      <link href="/Erlang/Erlang/Erlang%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B8%AD%E9%97%B4%E5%BD%A2%E6%80%81/"/>
      <url>/Erlang/Erlang/Erlang%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%B8%AD%E9%97%B4%E5%BD%A2%E6%80%81/</url>
      <content type="html"><![CDATA[<h3 id="0-_Erlang编译流程">0. Erlang编译流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Source code -&gt;  Core Erlang  -&gt; Virtual BEAM code  -&gt;  Opcode  -&gt;  Threaded code</span><br></pre></td></tr></table></figure><h3 id="1-_Core_Erlang">1. Core Erlang</h3><p>Core Erlang是由HIPE和OTP团队共同维护，项目地址是：<a href="http://www.it.uu.se/research/group/hipe/cerl/" target="_blank" rel="noopener">http://www.it.uu.se/research/group/hipe/cerl/</a></p><ol><li>将erl文件生成.core文件<br><code>c(ModuleName,[to_core]).</code></li><li>将.core文件生成.beam文件<br><code>c(ModuleName, [from_core]).</code></li></ol><h3 id="2-_Virtual_BEAM_code">2. Virtual BEAM code</h3><p>Erlang的中间汇编码, 如何生成：</p><ul><li>在Erlang Shell中：<br><code>c(ModuleName, [&#39;S&#39;]).</code></li><li>在非Erlang Shell中:<br><code>erlc Module.erl +&quot;&#39;S&#39;&quot;</code></li></ul><h3 id="3-_opcode">3. opcode</h3><p>opcode，即VM所识别的代码</p><ul><li>生成opcode<br><code>erts_debug:df(ModuleName).</code></li><li>查看所有的opcode的命令<br><code>rp(erts_debug:instructions()).  %在Erlang Shell中执行</code></li><li><p>例子:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-module(k).</span><br><span class="line">-export([test/0]).</span><br><span class="line">-compile(export_all).</span><br><span class="line">-author(&quot;Hawk&quot;).</span><br><span class="line">-define(TEST_NUM, 100).</span><br><span class="line">-record(student,&#123;</span><br><span class="line">class,</span><br><span class="line">id</span><br><span class="line">&#125;).</span><br><span class="line">-record(player,&#123;</span><br><span class="line">id = 0,</span><br><span class="line">name=[],</span><br><span class="line">level</span><br><span class="line">&#125;).</span><br><span class="line">test() -&gt;</span><br><span class="line">A = #student&#123;&#125;, </span><br><span class="line">B = #player&#123;&#125;,</span><br><span class="line">&#123;A, B&#125;.</span><br></pre></td></tr></table></figure><p>  执行步骤：</p><ol><li><p>生成中间码和opcode</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erlc k.erl +&quot;&apos;S&apos;&quot;  % 命令行</span><br><span class="line">erts_debug:df(k).  % Erlang Shell中</span><br></pre></td></tr></table></figure></li><li><p>会生成 <code>k.S</code> 和 <code>k.dis</code> 文件，<code>k.S</code> 是汇编中间码，而 <code>k.dis</code> 是opcode</p></li></ol></li></ul><h3 id="4-_Abstract_Format">4. Abstract Format</h3><p>Erlang代码被解析成的内部的形式，这个形式就称为Abstract Format，可以通过如下方式进行查看：</p><pre><code><span class="number">1</span>. 编译时加上 <span class="escape">`d</span>ebug_info<span class="escape">` </span>选项<span class="number">2</span>. 使用 <span class="escape">`b</span>eam_lib:chunks/<span class="number">2</span><span class="escape">` </span>查看</code></pre><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-module(k).</span><br><span class="line">-export([test/0]).</span><br><span class="line">-compile(export_all).</span><br><span class="line">-author(&quot;Hawk&quot;).</span><br><span class="line">-define(TEST_NUM, 100).</span><br><span class="line">-record(student,&#123;</span><br><span class="line">class,</span><br><span class="line">id</span><br><span class="line">&#125;).</span><br><span class="line">-record(player,&#123;</span><br><span class="line">id = 0,</span><br><span class="line">name=[],</span><br><span class="line">level</span><br><span class="line">&#125;).</span><br><span class="line">test() -&gt;</span><br><span class="line">A = #student&#123;&#125;, </span><br><span class="line">B = #player&#123;&#125;,</span><br><span class="line">&#123;A, B&#125;.</span><br></pre></td></tr></table></figure><p>执行步骤:</p><ul><li><code>erlc +debug_info k.erl</code></li><li><code>rp(beam_lib:chunks(k, [abstract_code])).</code></li></ul><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;ok,&#123;k,[&#123;abstract_code,</span><br><span class="line">&#123;raw_abstract_v1,</span><br><span class="line">[&#123;attribute,1,file,&#123;&quot;c:/Users/dell355/Desktop/k.erl&quot;,1&#125;&#125;,</span><br><span class="line"> &#123;attribute,1,module,k&#125;,</span><br><span class="line"> &#123;attribute,2,export,[&#123;test,0&#125;]&#125;,</span><br><span class="line"> &#123;attribute,3,compile,export_all&#125;,</span><br><span class="line"> &#123;attribute,4,author,&quot;Hawk&quot;&#125;,</span><br><span class="line"> &#123;attribute,8,record,</span><br><span class="line"> &#123;student,</span><br><span class="line"> [&#123;record_field,9,&#123;atom,9,class&#125;&#125;,</span><br><span class="line">  &#123;record_field,10,&#123;atom,10,id&#125;&#125;]&#125;&#125;,</span><br><span class="line"> &#123;attribute,13,record,</span><br><span class="line"> &#123;player,</span><br><span class="line"> [&#123;record_field,14,&#123;atom,14,id&#125;,&#123;integer,14,0&#125;&#125;,</span><br><span class="line">  &#123;record_field,15,&#123;atom,15,name&#125;,&#123;nil,15&#125;&#125;,</span><br><span class="line">  &#123;record_field,16,&#123;atom,16,level&#125;&#125;]&#125;&#125;,</span><br><span class="line"> &#123;function,19,test,0,</span><br><span class="line"> [&#123;clause,19,[],[],</span><br><span class="line">  [&#123;match,20,&#123;var,20,&apos;A&apos;&#125;,&#123;record,20,student,[]&#125;&#125;,</span><br><span class="line">   &#123;match,21,&#123;var,21,&apos;B&apos;&#125;,&#123;record,21,player,[]&#125;&#125;,</span><br><span class="line">   &#123;tuple,22,[&#123;var,22,&apos;A&apos;&#125;,&#123;var,22,&apos;B&apos;&#125;]&#125;]&#125;]&#125;,</span><br><span class="line"> &#123;eof,22&#125;]&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><p>Abstract Format的语法树，文档： <a href="http://www.erlang.org/doc/apps/erts/absform.html" target="_blank" rel="noopener">http://www.erlang.org/doc/apps/erts/absform.html</a></p>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Erlang </tag>
            
            <tag> Compile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Erlang优化</title>
      <link href="/Erlang/Erlang/Erlang%E4%BC%98%E5%8C%96/"/>
      <url>/Erlang/Erlang/Erlang%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="1-_进程标志设置：">1. 进程标志设置：</h3><ul><li>消息和binary内存<br><code>erlang:process_flag(min_bin_vheap_size, 1024*1024)</code>，减少大量消息到达或处理过程中产生大量binary时的gc次数</li><li>堆内存<br><code>erlang:process_flag(min_heap_size, 1024*1024)</code>，减少处理过程中产生大量term，尤其是list时的gc次数</li><li>进程优先级<br><code>erlang:process_flag(priority, high)</code>，防止特殊进程被其它常见进程强制执行reductions</li><li>进程调度器绑定<br><code>erlang:process_flag(scheduler, 1)</code>，当进程使用了port时，还需要port绑定支持，防止进程在不同调度器间迁移引起性能损失，如cache、跨numa、node拷贝等，当进程使用了port时，主要是套接字，若进程与port不在一个scheduler上，可能会引发严重的epoll fd锁竞争及跨numa node拷贝，导致性能严重下降</li></ul><h3 id="2-_虚拟机参数：">2. 虚拟机参数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+S X:X       ：启用调度器数量，多个调度器使用多线程，有大量锁争用</span><br><span class="line">-smp disable ：取消smp，仅使用单线程，16个 -smp_disabled 虚拟机性能高于 +S 16:16</span><br><span class="line">+sbt db      ：将scheduler绑定到具体的cpu核心上，再配合erlang进程和port绑定，可以显著提升性能，但是如果绑定错误，反而会有反效果</span><br></pre></td></tr></table></figure><h3 id="3-_消息队列">3. 消息队列</h3><p>消息队列长度对性能的影响主要体现在以下两个方面：<strong>进程binary堆的gc</strong> 和 <strong>进程内消息匹配</strong>，前者可以通过放大堆内存来减少gc影响，后者需要谨慎处理。若进程在处理消息时是通过消息匹配方式取得消息，同时又允许其它进程无限制投递消息到本进程，此时会引发灾难，匹配方式取得消息会引发遍历进程消息队列，如果此时仍然有其它进程投递消息，会导致进程消息队列暴涨，遍历过程也将增大代价，引发恶性循环。已知模式有：在gen_server中使用file:write（raw模式）或gen_tcp:send等，这些操作都是erlang虚拟机内部通过port driver实现的，均有内部receive匹配接收，对于这些操作，最好的办法是将其改写为nif，直接走进程堆进行操作，次之为将file:write或gen_tcp:send改写为两阶段，第一阶段为port_command，第二阶段由gen_server接收返回结果，这种异步化可能有些正确性问题，对于gen_tcp:send影响不大，因为网络请求本身要么同步化要么异步化，都需要内部的确认机制；对于file:write影响较大，file:write的错误通常为目录不存在或磁盘空间不足，确保这两个错误不造成影响即可，同时如果进程的其它部分需要使用file的其它操作，必须首先清空之前file:write产生的所有file的port消息，否则有可能产生消息序列紊乱的问题。对于套接字的接口调用，可以参考rabbitmq的两阶段套接字发送方法，而对于文件接口调用，可以参考riak的bitcask引擎将文件读写封装为nif的方法</p><h3 id="4-_内存及ets表">4. 内存及ets表</h3><p>ets表可以用于进程间交换大数据，或充当缓存，以及复杂匹配代理等，其性能颇高，并发读写可达千万级qps，并有两个并发选项，在建立表时设置，分别是{write_concurrency, true} | {read_concurrency, true}，以允许ets的并发读写 使用ets表可以绕过进程消息机制，从而在一定程度上提高性能，并将编程模式从面向消息模式变为面向共享内存模式</p><h3 id="5-_CPU密集型操作">5. CPU密集型操作</h3><p>erlang执行流程的问题：</p><ol><li>其指令都是由其虚拟机执行的，一条指令可能需要cpu执行3-4条指令，一些大规模的匹配或遍历操作会严重影响性能;</li><li>其bif调用执行过程类似于操作系统的系统调用，需要对传入参数进行转换，在大量小操作时损失性能较为严重</li><li>其port driver流程较为繁冗复杂，需要经历大量的回调等，一般的小功能操作，不要通过port driver实现</li></ol><p>建议：<br>   字符串匹配不要通过list进行，最好通过binary；单字节匹配，尤其是语法解析，如xmerl、mochijson2、lexx等，尽管使用binary，但是它们是一个字节一个字节匹配的，性能会退化到list的水平，应该尽量将其nif化；   对于一些小操作，反而应该去bif化、去nif化、去port driver化，因为进入erlang内部函数的执行代价也不小；已知的性能瓶颈：re、xmerl、mochijson2、lexx、erlang:now、calendar:local_time_to_universal_time_dst等</p><h3 id="6-_数据结构">6. 数据结构</h3><p>减少遍历，尽量使用API提供的操作，由于各种类型的变量实际可以当做c的指针，因此erlang语言级的操作并不会有太大代价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lists    ：reverse为c代码实现，性能较高，依赖于该接口实现的lists API性能都不差，避免list遍历，[||]和foreach性能是foldl的2倍，不在非必要的时候遍历list</span><br><span class="line">dict     ：find为微秒级操作，内部通过动态hash实现，数据结构先有若干槽位，后根据数据规模变大而逐步增加槽位，fold遍历性能低下</span><br><span class="line">gb_trees ：lookup为微秒级操作，内部通过一个大的元组实现，iterator+next遍历性能低下，比list的foldl还要低2个数量级</span><br></pre></td></tr></table></figure><p>其它常用结构：queue，set，graph等</p><h3 id="7-_计时器">7. 计时器</h3><p>erlang的计时器timer是通过一个唯一的timer进程实现的，该进程是一个gen_server，用户通过timer:send_after和timer:apply_after在指定时间间隔后收到指定消息或执行某个函数，每个用户的计时器都是一条记录，保存在timer的ets表timer_tab中，timer的时序驱动通过gen_server的超时机制实现。若同时使用timer的用户过多，则tiemr将响应不过来，成为瓶颈。更好的方法是使用erlang的原生计时器erlang:send_after和erlang:start_timer，它们把计时器附着在进程自己身上。</p><h3 id="8-_尾调用和尾递归">8. 尾调用和尾递归</h3><p>尾调用和尾递归是erlang函数式语言最强大的优化，尽量保持函数尾部有尾调用或尾递归</p><h3 id="9-_文件预读，批量写，缓存：">9. 文件预读，批量写，缓存：</h3><p> 这些方式都是局部性的体现</p><ul><li>预读：读空间局部性，文件提供了read_ahead选项</li><li>批量写：写空间局部性<br>对于文件写或套接字发送，存在若干级别的批量写：<ol><li>erlang进程级：进程内部通过list缓存数据</li><li>erlang虚拟机：不管是efile还是inet的driver，都提供了批量写的选项delayed_write|delay_send，它们对大量的异步写性能提升很有效</li><li>操作系统级：操作系统内部有文件写缓冲及套接字写缓冲</li><li>硬件级：cache等</li></ol></li><li>缓存：读写时间局部性，读写空间局部性，主要通过操作系统系统，erlang虚拟机没有内部的缓存</li></ul><h3 id="10-套接字标志设置">10.套接字标志设置</h3><ul><li>延迟发送：<code>{delay_send, true}</code>，聚合若干小消息为一个大消息，性能提升显著</li><li>发送高低水位：<code>{high_watermark, 128 * 1024} | {low_watermark, 64 * 1024}</code>，辅助 <code>delay_send</code> 使用，<code>delay_send</code> 的聚合缓冲区大小为 <code>high_watermark</code>，数据缓存到 <code>high_watermark</code> 后，将阻塞 <code>port_command</code>，使用 <code>send</code> 发送数据，直到缓冲区大小降低到 <code>low_watermark</code> 后，解除阻塞，通常这些值越大越好，但erlang虚拟机允许设置的最大值不超过128K</li><li>发送缓冲大小：<code>{sndbuf, 16 * 1024}</code>，操作系统对套接字的发送缓冲大小，在延迟发送时有效，越大越好，但有极值</li><li>接收缓冲大小：<code>{recbuf, 16 * 1024}</code>，操作系统对套接字的接收缓冲大小</li></ul><h3 id="11-_序列化/反序列化">11. 序列化/反序列化</h3><p>通常情况下，为了简化实现，一般将erlang的term序列化为binary，传递到目的地后，在将binary反序列化为term，这通常涉及到两个操作： <code>term_to_binary</code> 及 <code>binary_to_term</code>，这两个操作性能消耗极为严重，应至多只做一次，减少甚至消除它们是最正确的，例如直接构造binary进行跨虚拟机数据交换。 但对比与其它的序列化和反序列化方式，如利用 <code>protobuf</code> 等，<code>term_to_binary</code> 和 <code>binary_to_term</code> 的性能是高于这些方式的，毕竟是 <code>erlang</code> 原生格式，对于力求简单的应用，其序列化和反序列化方式推荐 <code>term_to_binary</code> 和 <code>binary_to_term</code></p><h3 id="12-_并发化">12. 并发化</h3><p>在一些场景下，如web请求、数据库请求、分布式文件系统等，单个接入接口已经不能满足性能需求，需要有多个接入接口，多个数据通道，等等，这要求所有请求处理过程必须是无状态的，或者状态更改同步进入一个公共存储，而公共存储也必须是支持并发处理的，如并发数据库、类hdfs、类dynamo存储等，若一致性要求较高，最好选用并发数据库，如mysql等，若在此基础上还要求高可用，最好选择同步多结点存储，mnesia、zk都是这方面的典型；若不需要较高的一致性，类hdfs、类dynamo这类no sql存储即可满足</p><h3 id="13-_hipe">13. hipe</h3><p>将erlang汇编翻译成机器码，减少一条erlang指令对应的cpu指令数</p>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optimize </tag>
            
            <tag> Erlang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Erlang-热更新</title>
      <link href="/Erlang/Erlang/Erlang-%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/Erlang/Erlang/Erlang-%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h3 id="1-_基本概念及热更新适用的范围">1. 基本概念及热更新适用的范围</h3><ol><li>系统组成<br><code>Target system &gt; release &gt; application &gt; module</code></li><li>代码热更新由 <code>SASL</code> 框架提供</li><li>热更新分为两种：<ol><li>simple code replacement<br>简单更新，仅仅通过模块的替换</li><li>synchronized code replacement<br>复杂更新，需要同步数据</li></ol></li><li>模块分类<ol><li>功能模块：<br>仅仅是执行一个功能</li><li>驻留模块：<br>使用了尾递归</li></ol></li><li>热更新的适用函数<ol><li>模块<br>可以直接更新</li><li>gen_server<ol><li>除了更新其内部的数据之外的，都可以直接用load_module进行更新</li><li>如果要更新gen_server的内部数据，则必须在它之上加上一个supervisor</li><li>不能更新gen_server的内部结构</li></ol></li></ol></li></ol><h3 id="2-_Release">2. Release</h3><p>是由许多application组成的一个系统</p><ol><li>Release的目录结构：<ol><li><code>lib</code><br>application的目录</li><li><code>erts-EVsn/bin</code><br>Erlang运行系统的可执行文件</li><li><code>release/Vsn</code><br><code>.rel</code> 文件，<code>start.boot</code> 文件，<code>relup</code>, <code>sys.config</code>文件</li><li><code>bin</code>, 最顶层的Erlang运行时系统</li></ol></li><li><p><code>release resource file</code>:(.rel文件)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    release,</span><br><span class="line">    &#123;RelName, Vsn&#125;,</span><br><span class="line">    &#123;erts, EVsn&#125;,</span><br><span class="line">    [</span><br><span class="line">        &#123;Application, AppVsn&#125; |</span><br><span class="line">        &#123;Application, AppVsn, Type&#125; |</span><br><span class="line">        &#123;Application, AppVsn, IncApps&#125; |</span><br><span class="line">        &#123;Application, AppVsn, Type, IncApps&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><ol><li>RelName: string, 是release的名字</li><li>Vsn: string, Release的版本号</li><li>EVsn: string, Erlang运行库的版本</li><li>Application, string, App名字</li><li>AppVsn:string, 应用程序的版本号</li><li>Type = permanent | transient | temporary | load | none:<ol><li>permanent | transient | temporary，Application将会直接加载并且启动</li><li>load, 只加载</li><li>none，即不加载，也不启动</li><li>默认为permanent</li></ol></li><li>IncApps = [atom()], 包含的App</li></ol></li><li>生成script，根据 <code>.rel</code> 文件： <code>systools:make_script(Name).</code></li><li>将 <code>release</code> 打包,根据 <code>.rel</code> 文件, <code>systools:make_tar(Name).</code></li></ol><h3 id="3-_Application">3. Application</h3><ol><li><p>Application的目录结构：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. src      : 源码 </span><br><span class="line">2. ebin: beam文件，.app文件也放在这里</span><br><span class="line">3. priv: app专属文件</span><br><span class="line">4. include: 包含的文件</span><br></pre></td></tr></table></figure></li><li><p>Application模板</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-behaviour(application).</span><br><span class="line">-export([start/2, stop/1]).</span><br><span class="line">start(_StartType, _StartArgs) -&gt;</span><br><span class="line">case &apos;TopSupervisor&apos;:start_link() of</span><br><span class="line">&#123;ok, Pid&#125; -&gt;</span><br><span class="line">&#123;ok, Pid&#125;;</span><br><span class="line">Error -&gt;</span><br><span class="line">Error</span><br><span class="line">end.</span><br><span class="line">stop(_State) -&gt;</span><br><span class="line">ok.</span><br></pre></td></tr></table></figure></li><li><p>Application的资源文件</p><ol><li>application(.app文件,文件的名字与app一致)</li><li><p>结构：<br> <code>{application, ApplicationName, [Opt1,...OptN]}</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Option:</span><br><span class="line">1. description             : 对应用的简单描述,，默认是&quot;&quot;.</span><br><span class="line">2. id                      : 产品的标识符.</span><br><span class="line">3. vsn                     : 版本号.</span><br><span class="line">4. modules                 : 这个application中的所有要用到的模块，至少有一个.</span><br><span class="line">5. maxP                    : 这个application中允许的最大的进程数.</span><br><span class="line">6. maxT                    : 这个app允许运行的最大时间，超过这个时间，自动停止(单位为ms).</span><br><span class="line">7. registered              : 这个app中所有的注册的名字.</span><br><span class="line">8. included_applications   : 这个app会用到的其它子app，只加载，但是不启动.</span><br><span class="line">9. env                     : 配置这个app运行的参数，可以使用application:get_env获取.</span><br><span class="line">10. mod                    : 指定app的回调模块，和启动app回调的start函数的参数(这里的参数是指start中的第二个参数).</span><br><span class="line">11. start_phases           : 指定启动阶段,子app，可以不是监控树的一部分.</span><br><span class="line">12. runtime_dependencies   : 声明运行时的最小依赖，如: kernel-3.0.</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一个Application中使用其它Application</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">primary  application: 不使用其它application</span><br><span class="line">included application：被其它app使用的app</span><br><span class="line">Application之间的同步，通过start_phases参数来定制</span><br></pre></td></tr></table></figure></li><li><p>分布式Application</p><ol><li><p><code>distributed</code> 配置文件：</p><ol><li><p>完整结构：注意PC名字不能有其它字符  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">kernel,</span><br><span class="line">[</span><br><span class="line">&#123;distributed, [&#123;myapp, 5000, [cp1@cave, &#123;cp2@cave, cp3@cave&#125;]&#125;]&#125;,</span><br><span class="line">&#123;sync_nodes_mandatory, [cp2@cave, cp3@cave]&#125;</span><br><span class="line">&#123;sync_nodes_timeout, 5000&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p><code>{distributed, [{Application, [Timeout], NodeDesc}]}</code>:</p><ol><li>Application: 表示应用的名称</li><li>Timeout<br>表示重新启动该应用的超时时间，即一个app优先在一个node上运行，但是这个node突然挂了              ，那么就要在另外一个节点去启动，但是如果想要在这个node去启动这个app，那么它就会先等待这个time，让这个app，在原先的node再次启动，如果启动失败，才在这个node上启动</li><li><code>NodeDesc, [firstNode, {....otherNodes}]</code><ul><li><code>firstNode</code><br> 表示优先在这个节点上启动应用</li><li><code>otherNodes</code><br> 表示优先的那个节点失败，则依赖在后面的节点中选择一个节点启动应用</li></ul></li></ol></li><li><code>{sync_nodes_mandatory, [cp2@cave, cp3@cave]}</code><ul><li><code>sync_nodes_mandatory</code><br>表示在启动这个节点前必须保证cp2@cave， cp3@cava已经启动</li></ul></li><li><code>{sync_node_timeout, 5000}</code><br>表示启动其它节点的超时时间，如果超过这个时间，要求的节点还没启动，则这个节点启动失败</li></ol></li><li>application的start函数中的StartType参数：<ol><li><code>{Failover, node()}</code>:<br>当一个app运行在first node(即优先级最高)，如果发生异常后，再次启动并且运行，就要用Failover</li><li><code>TakeOver</code>:<br>当一个app运行非first node上，如果firt node启动后，将会停止app,然后将其运行在first node上</li></ol></li></ol></li><li>其它:<ol><li>application:start的第二个参数<ol><li>temporary: 应用程序死掉会报错误出来但是其它应用程序不受影响(默认)</li><li>permanent: 应用程序终止之后所有其它的应用程序和运行时系统都会死掉</li><li>transient: 应用程序终止的原因是normal,这个消息会报出来但是其它应用程序不会重启,如果应用程序终止的原因不是normal,其他应用程序和运行时也会跟着死掉</li></ol></li></ol></li></ol><h3 id="4-_script">4. script</h3><p>release的启动脚本, 格式如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">script,</span><br><span class="line">&#123;Name, Vsn&#125;,</span><br><span class="line">[</span><br><span class="line">&#123;progress, loading&#125;,</span><br><span class="line">&#123;preLoaded, [Mod1, Mod2, ...]&#125;,</span><br><span class="line">&#123;path, [Dir1,&quot;$ROOT/Dir&quot;,...]&#125;.</span><br><span class="line">&#123;primLoad, [Mod1, Mod2, ...]&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;kernel_load_completed&#125;,</span><br><span class="line">&#123;progress, loaded&#125;,</span><br><span class="line">&#123;kernelProcess, Name, &#123;Mod, Func, Args&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;apply, &#123;Mod, Func, Args&#125;&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;progress, started&#125;</span><br><span class="line">]</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><p>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Name                    : string, 定义这个系统的名字</span><br><span class="line">2. Vsn                     : string, 定义这个系统的版本</span><br><span class="line">3. &#123;path, [Dir]&#125;           : 将Dir(string)加入系统搜索目录</span><br><span class="line">4. &#123;primLoad, [Mod]&#125;       : 从Path中加载module</span><br><span class="line">5. &#123;kernel_load_completed&#125; : 表明所有模块都必须加载</span><br><span class="line">1. 在交互模式下：在这之后的&#123;primLoad, [Mod]&#125;,就会按需加载，之前的就会全部加载</span><br><span class="line">2. 在嵌入模式下：忽略，因为本身就是全部加载</span><br><span class="line">6. &#123;kernelProcess, Name, &#123;Mod, Fun, Args&#125;&#125;, Name是&#123;Mod, Fun, Args&#125;这个进程的名字，如果这个进程崩溃，那么这个系统就会崩溃，所以一般不要轻易设置</span><br><span class="line">7. &#123;apply, &#123;Mod, Func, Args&#125;&#125;, 执行apply(Mod, Func, Args),如果执行失败，则整个启动过程就会失败，系统无法启动</span><br></pre></td></tr></table></figure><h3 id="5-_简单热更新">5. 简单热更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. compile:file(z)                : 编译新的代码</span><br><span class="line">2. sys:suspend(z)      : 挂起服务，此时只是接受系统消息，其它消息都不会接受</span><br><span class="line">3. code:purge(z)      : 清除旧代码，如果有些进程与该模块相关联的话，那么这些进程就会被杀死,</span><br><span class="line">4. code:load_file(z)      : 加载新代码，beam</span><br><span class="line">5. sys:change_code(z, z, &quot;0&quot;, []) : 更新代码</span><br><span class="line">6. sys:resume(z)      : 重启服务器</span><br></pre></td></tr></table></figure><h3 id="6-_复杂更新">6. 复杂更新</h3><p>先写出 <code>appup</code>(用于application的更新) 和 <code>relup</code>(用于release的更新) 文件后，执行更新</p><h4 id="6-1_relup文件">6.1 relup文件</h4><ol><li>模块：<ol><li>加载模块：<code>{load_module, Module}</code></li><li>更新模块：<ol><li><code>{update, Module, {advanced, Extra}}</code></li><li><code>{update, Module, supervisor}</code></li></ol></li><li>增加模块：<code>{add_module, Module}</code></li><li>删除模块：<code>{delete_module, Module}</code>，删除前必须先停止</li></ol></li><li>Application<ol><li>增加Application: <code>{add_application, Application}</code>，自动加载在”.app”文件中包含的modules中所有的模块</li><li>移除Application: <code>{remove_application, Application}</code>, 停止application,移除该application中包含的所有模块,再移除该application</li><li>重启Application: <code>{restart_application, Application}</code>, 先调用remove_application, 再调用add_application</li></ol></li><li>release handler<ol><li>调用一个函数：<code>{apply, {M, F, A}}</code></li><li>重启模拟器  ：<code>restart_new_emulator</code> (总是第一个被执行)， <code>restart_emulator</code></li></ol></li></ol><h4 id="6-2_appup文件">6.2 appup文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Vsn,</span><br><span class="line">[</span><br><span class="line">&#123;UpFromVsn1, InstructionU1&#125;&#125;,</span><br><span class="line">...,</span><br><span class="line">&#123;UpFromVsnK, InstructionUK&#125;&#125;</span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line">&#123;DownToVsn1, InstructionU1&#125;&#125;,</span><br><span class="line">...,</span><br><span class="line">&#123;DownToVsn1, InstructionUK&#125;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure><p>字段意义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vsn         : string(), 表示更新后的版本号</span><br><span class="line">UpFromVsn   : string(), 表示从什么版本向上升级</span><br><span class="line">DownFromVsn : string(), 表示向下升级到什么版本</span><br><span class="line">InstructionK: List, release handling instruction</span><br></pre></td></tr></table></figure><h4 id="6-3_安装Release,更新">6.3 安装Release,更新</h4><ol><li>解压：<code>release_handler:unpack_release(ReleaseName) =&gt; {ok, Vsn}</code></li><li>安装: <code>release_handler:install_release(Vsn) =&gt; {ok, FromVsn, []}</code><ol><li>如果安装失败，系统将用之前的版本进行重启</li><li>如果在安装成功后，如果发生什么异常，都会用都版本进行重启</li><li>如果是 <code>Downgrade</code>, 就需要再次调用该函数(实践表明只需要一次)</li></ol></li><li>设置为固定： <code>release_handler:make_permanent(Vsn) =&gt; ok</code><ol><li>设置为固定的话，如果发生异常，不会用老版本的代码进行重启</li><li>即标记某一个版本为Old</li></ol></li><li>删除: <code>release_handler:remove_release(Vsn) =&gt; ok</code>, 非 <code>permanent</code></li></ol>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Erlang </tag>
            
            <tag> 热更新 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Erlang-小知识点</title>
      <link href="/Erlang/Erlang/Erlang-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/Erlang/Erlang/Erlang-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="1-_Erlang的一些常量值">1. Erlang的一些常量值</h3><ol><li>每一个Erlang节点的ETS表的数量是有限制的,默认是 <code>1400</code> 个表</li><li>Erlang原子的个数为 <code>1048576</code>，超过这个数量，VM则直接关闭</li><li>让Erlang节点在不同主机间互通需要打开TCP和UDP的 <code>4369</code> 端口, <code>empd, (Erlang Port Mapper Daemon)</code>会使用这个端口</li><li>Erlang的最小堆的大小是 <code>233 words</code></li><li>一个新开的进程，如果没有使用SMP和HiPE，则使用 <code>309 words</code>个内存</li><li>如果二进制数据64 bytes会在进程内存储,如果超过 <code>64 bytes</code>二进制数据是在进程以外的独立的堆分配</li><li>默认的 <code>inline_size</code> 是 <code>24</code></li></ol><h3 id="2-_make_ref，创建一个唯一的标识符">2. <code>make_ref</code>，创建一个唯一的标识符</h3><p>通过将代码转换成 <code>opcode</code> ，会发现执行了 <code>recv_set</code> 和 <code>recv_mark</code> 的操作</p><ul><li><code>recv_set</code><br> 会在当前检查当前进程上下文中是否包含这个信息.如果找到这个信息,就会把消息队列中指向下一条要读消息的指针移动到之前记录的位置</li><li><code>recv_mark</code><br> 在进程上下文保存了队尾指针</li></ul><h3 id="3-_Inline编译">3. Inline编译</h3><ol><li><p>设置inline: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. -compile(&#123;inline [Fun/Arity]&#125;).</span><br><span class="line">2. -compile(&#123;inline_size, Size&#125;).</span><br></pre></td></tr></table></figure></li><li><p>inline_size，是指对一个函数进行计算，得出的权重，如果小于这个值就会才inline</p></li><li>默认的inline_size是 <strong>24</strong>，但是一般 <strong>30</strong> 可以达到最大的优化</li></ol><h3 id="4-_iolist">4. iolist</h3><ol><li>组成<ol><li>binary</li><li>[]</li><li>列表, 每个元素是int(0-255)或者binary或者iolist：<br> 1、其中binary是指 bitsize % 8 == 0 .<br> 2、int 是0-255</li></ol></li><li>iolist数据可以直接发向 port(socket也是一种特殊的port)，没有必要转换成binary</li></ol><h3 id="4-_SMP">4. SMP</h3><p>Symmetrical Multi Processor，多核调用，没有开启SMP时，Erlang VM只有一个 <code>Scheduler</code> 运行于主线程中，<code>Scheduler</code> 不断地从运行队列中取出需要处理的Erlang进程和IO-job，因为只存在一个 <code>Scheduler</code>所以并没有对数据加锁。当开启SMP后，Erlang VM中将会有1-1024个 <code>Scheduler</code>, 每一个 <code>Scheduler</code> 都是一个独立的操作系统进程，会存在对数据加锁的过程，但是能充分利用系统资源。</p><h3 id="5-_日期处理">5. 日期处理</h3><p>日期处理类是, <code>calendar</code>, 其格式是: <code>datetime = { {Year, Month, Day}, {Hour, Minute, Second} }</code>，以下是对日期的一些常用操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 获取时间：</span><br><span class="line">1. 本地时间：calendar:local_time().</span><br><span class="line">2. 世界时间：calendar:universal_time().</span><br><span class="line">2. 判断是否是润年：</span><br><span class="line">   calendar:is_leap_year</span><br><span class="line">3. 判断日期是否合法，是能判断年，月，日:</span><br><span class="line">calendar:valid_date ， 如: calendar:valid_date(&#123;2014, 12, 9&#125;).</span><br><span class="line">4. 计算某一天，是一周的第几天：</span><br><span class="line">calendar:day_of_the_week(2014, 12, 10).</span><br><span class="line">5. 计算某一年的某一个月有多少天:</span><br><span class="line">calendar:last_day_of_the_month(2014, 12).</span><br><span class="line">6. 将时间转换成秒:</span><br><span class="line">calendar:time_to_seconds(&#123;1,20,0&#125;).</span><br><span class="line">7. 将本地时间转换成世界时间(秒):</span><br><span class="line">calendar:datetime_to_gregorian_seconds</span><br><span class="line">8. 将世界时间(秒)转换成本地时间:</span><br><span class="line">calendar:gregorian_seconds_to_datetime</span><br><span class="line">9. 将本地时间转换成UTC标准时间:</span><br><span class="line">erlang:localtime_to_universaltime，如： erlang:localtime_to_universaltime(&#123; &#123;1996,11,6&#125;,&#123;14,45,17&#125; &#125;).</span><br><span class="line">10. 将UTC标准时间转换成本地时间:</span><br><span class="line">erlang:universaltime_to_localtime，如：erlang:universaltime_to_localtime(&#123; &#123;1996,11,6&#125;,&#123;14,18,43&#125; &#125;).</span><br></pre></td></tr></table></figure><h3 id="6-_二进制">6. 二进制</h3><p><code>binary</code> 和 <code>bitstring</code> 内部实现机制相同，仅仅是单位不一样而已</p><center><img src="/pics/Erlang-binary.jpg" alt=""></center><ul><li><code>refc binaries</code><ul><li><code>ProcBin</code><br> 存放在进程堆中，包含了一个二进制数据的元数据信息，二进制数据的位置和引用计数</li><li><code>binary object</code><br>进程堆以外的二进制对象，可以被任意数量的进程和任意数量的 <code>ProcBin</code> 引用，该对象包含了引用计数器，一旦计器归零就会被 GC</li></ul></li><li><code>heap binaries</code><br> 都是小块二进制数据，最大为 <code>64</code> 字节，直接存放在进程堆，垃圾回收和发送消息都是通过拷贝实现，不需要 GC 做特殊处理</li><li><code>sub binaries</code><br> 由 <code>split_binary</code> 产生，是另外一个进制数据的部分应用，仅仅是指向某一段数据，由于并没有拷贝所有binary的模式匹配成本很低</li><li><code>match contexts</code><br> 类似于 <code>sub binary</code>，但是针对二进制匹配做了优化，例如它包含一个直接指向二进制数据的指针，从二进制匹配出来字段值之后移动指针位置即可.</li></ul><h3 id="7-_proc_lib">7. proc_lib</h3><center><img src="/pics/Erlang-proc_lib.jpg" alt=""></center><ul><li><code>proc_lib:spawn</code> 与 <code>erlang:spawn</code> 的区别：<ol><li><code>proc_lib:spawn</code><ol><li>proc_lib创建的进程，在其进程的元数据的dictionary会增加一些数据</li><li>proc_lib创建的进程，在出错后，如果启动了sasl，则会收到一份crash report</li><li>proc_lib创建的进程，认为shutdown或者{shutdown, Term}是正常退出的</li><li>使用proc_lib创建的进程退出的原因不是normal也不是shutdown的时候,就会创建一个进程崩溃报告</li></ol></li><li><code>erlang:spawn</code><ol><li>erlang:spawn创建的进程，认为normal是才是正常退出的</li></ol></li></ol></li><li><p><code>proc_lib:start</code><br> 创建一个进程，并等待，直到由子进程通过调用 <code>proc_lib:init_ack</code> 来向父进程发送到已经完成初始化的消息为止(与gen_server的start_link与init关系是一样的)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">acceptor_init(Parent, Port, Module) -&gt;</span><br><span class="line">   State = #state&#123; </span><br><span class="line">     parent = Parent,</span><br><span class="line">     port = Port,</span><br><span class="line">     module = Module</span><br><span class="line">    &#125;,</span><br><span class="line">   error_logger:info_msg(&quot;Listening on port ~p~n&quot;, [Port]),</span><br><span class="line">   case (catch do_init(State)) of</span><br><span class="line">       &#123;ok, ListenSocket&#125; -&gt;</span><br><span class="line">           proc_lib:init_ack(State#state.parent, &#123;ok, self()&#125;),</span><br><span class="line">           acceptor_loop(State#state&#123;listener = ListenSocket&#125;);</span><br><span class="line">       Error -&gt;</span><br><span class="line">           proc_lib:init_ack(Parent, Error),</span><br><span class="line">           error</span><br><span class="line">   end.</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-_Group_Leader">8. Group Leader</h3><ul><li>Erlang的所有进程都属于一个组，而每一个组都会有一个 <code>group leader</code></li><li><code>init</code>进程，即 <code>&lt;0,0,0&gt;</code> 是最初的进程组的group leader</li><li><code>user</code>，是标准IO，也是Erlang Shell的group leader</li><li><p>相关操作:</p><ul><li><p>获取一个进程的group leader的值: </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. erlang:process_info(Pid).</span><br><span class="line">2. erlang:group_leader/0</span><br></pre></td></tr></table></figure></li><li><p>设置一个进程的group leader<br><code>erlang:group_leader/2</code></p></li></ul></li></ul><h3 id="9-_io:foramt">9. io:foramt</h3><p><code>io:foramt</code> 格式化时，会将消息按指定的格式发给 <code>group_leader</code> ，然后 <code>group_leader</code> 负责io请求和显示，控制字符格式:   </p><p><code>~F.P.PadModC</code>  </p><p>具体含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">F  : 表示输出的宽度</span><br><span class="line">P  : 表示输出的精度</span><br><span class="line">Pad: 表示填充字符</span><br><span class="line">Mod: 控制字符；</span><br><span class="line">1. t， 输出unicode字符</span><br><span class="line">    2. l,  停止</span><br><span class="line">    3. p/P,检测可打印字符</span><br><span class="line">C  ：表示输出什么类型的值</span><br><span class="line">    1. ~,用于转义</span><br><span class="line">    2. c，字符</span><br><span class="line">    3. f，浮点数</span><br><span class="line">    4. e，科学计数法</span><br><span class="line">    5. g，浮点(小于10000.00,大于等于0.1)或者科学计数</span><br><span class="line">    6. s，字符串</span><br><span class="line">    7. w，Erlang Term</span><br><span class="line">    8. p，美化版的w</span><br><span class="line">    9. W，类似于w，但是可以在输入后面加一个限制来表示一行可以打印的大小</span><br><span class="line">    10. P,类似于p，但是可以在输入后面加一个限制来表示一行可以打印的大小</span><br><span class="line">    11. B,输出某种进制下的Number值</span><br><span class="line">    12. X,类似于B,但是可以在输出后，加上一个前缀</span><br><span class="line">    13. #，类似于B，会自动加上该Number的进制</span><br><span class="line">    14. b，类似于B，但是会打印出小写字母</span><br><span class="line">    15. x，类似于X，但是会打印出小写字母</span><br><span class="line">    16. +，类似于#，但是会打印出小写字母</span><br><span class="line">    17. n，换行</span><br><span class="line">    18. i，忽略接下来的输入项</span><br></pre></td></tr></table></figure><p>更详细的内容，请看官网： <a href="http://erlang.org/doc/apps/stdlib/io_protocol.html" target="_blank" rel="noopener">http://erlang.org/doc/apps/stdlib/io_protocol.html</a></p><h3 id="10-_定时器">10. 定时器</h3><ol><li>定时器有三种实现方式<ol><li><code>timer:send_after</code></li><li><code>erlang:start_timer / erlang:send_after</code></li><li><code>receive ... after</code></li></ol></li><li>三者区别:<ol><li><code>receive ... after</code>:<br> after原语的本质就是一个定时器，因为加上了定时器，所以这个性能比不加after的性能要低</li><li>timer模块由一个进程来管理timer的，所以频繁的创建和关闭timer会使该进程过载，会出现问题</li><li>eralng定时器，是一种更高效的实现timer，整个定时器由 <code>bump_timer</code> 来驱动。<code>bump_timer</code> 是在 <code>schedule</code> 的时候不定期调用的。总之使用timer的时候要小心，因为 <code>timer</code> 是在 <code>scheduler</code> 的线程里面调用的，不能做非常耗时的操作，  否则会阻塞调度器</li></ol></li><li>erlang的send_after与start_timer的区别:<ol><li>它们的区别在于timer超时后发送的消息<ol><li><code>send_after</code> 发送的是Msg</li><li><code>start_timer</code> 发送的是 <code>{timeout, TimerRef, Msg}</code></li></ol></li><li>为何有这种区别，start_timer是后来加上的函数，是为了避免在timer超时后，能够正确地关闭timer：参考 <code>eralng:cancel_timer</code><ol><li>假如在超时前关闭timer，send_after与start_timer是一样的</li><li>假如在超时后关闭timer，因为send_after仅仅发送的是消息，根本不能得到TimerRef，就不能正常关闭</li></ol></li></ol></li></ol><h3 id="11-_list/ets/gb_tree的选择">11. list/ets/gb_tree的选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">元素个数 0~100个，    选list</span><br><span class="line">元素个数 100~10000个，选ets</span><br><span class="line">元素个数 10000个以上，选gb_tree</span><br></pre></td></tr></table></figure><h3 id="12-_为什么更愿意使用List">12. 为什么更愿意使用List</h3><ol><li>Erlang的单一赋值的，使其不可能更改外部的数据，而List却能动态增加数据</li><li>Erlang的List的数据添加操作是将数据添加在头部，能够保持原有list不被破坏：<br> 如： [1,2,3,4,5,6,7]    <ol><li>比如现在你执行这个列表的遍历到元素5,这时候如果我在头部添加一个元素，变成[0,1,2,3,4,5,6,7],你继续遍历后面的元素依然是6,7,这个行为的结果是可以预测的</li><li>如果我是在尾部添加0，则变成 [1,2,3,4,5,6,7,0]，你继续遍历最后的结果会多出一个0</li></ol></li></ol><h3 id="13-_堆控制">13. 堆控制</h3><ol><li><code>erl +h</code> 选项可以调整全局的 <code>min_heap_size</code></li><li>针对某个进程可以在创建的时候使用 <code>spawn_opt/4</code> 来指定 <code>min_heap_size</code> 注意:该参数使用的单位是字 <code>word</code></li></ol><h3 id="14-_公平调度">14. 公平调度</h3><ol><li>erlang函数调用,由于 <code>erlang</code> 的代码翻译成 <code>opcode</code>,由虚拟机执行，所以一次完整的函数调用为一个 <code>reduction</code> </li><li><code>bif</code> 的 <code>trap</code> 机制。简单的说就是 <code>bif</code> 会执行到大概几个 <code>reduction</code> 这样的时间片后放弃执行，把当前的执行情况记录下来，然后退出。等下次调度再执行的时候，会继续之前的位置往下。</li><li>IO的调度。 IO也是公平调度的，把IO的处理量换算成 <code>reduction</code> ，算在宿主进程的时间片里面。</li></ol><h3 id="15-_Erlang的Trap机制">15. Erlang的Trap机制</h3><ol><li>Trap机制，即将费时的操作分割来完成，为了达到公平调度的目的</li><li>作用：<ol><li>把费时操作分阶段做</li><li>延迟执行，比如send操作</li><li>主动放弃CPU yield</li></ol></li></ol><h3 id="16-_gen_tcp中的close，shutdown，exit_on_close的区别">16. gen_tcp中的close，shutdown，exit_on_close的区别</h3><ol><li>close<br>close的操作源于文件，因为在Linux中，Socket也是文件，所以close的操作，就是将这个Socket的文件描述符的引用减1，如果这个Socket被复制(dup)，那么close的操作，是不会释放socket资源的，只有当描述符的引用变为0时，才能释放资源</li><li>shutdown  <ol><li>关闭读<br>将自己Socket的读标志为关闭状态，如果对方写数据时，就会触发，去寻找这个标志，当发现是关闭时，则会关闭他们之间的连接</li><li>关闭写<br>如果关闭自己的写，从别一个方面来说，即对方再也不能接受数据了，所以会分别关闭他们的Socket</li></ol></li><li>exit_on_close<ol><li>exit_on_close对gen_tcp:shutdown(S, read)没有影响</li><li>exit_on_close仅仅影响gen_tcp:shutdown(S, write),<ol><li>true<br>如果A执行gen_tcp:shutdown(S, write)，则表明A不会发数据了，那么A与B之间的连接就会关闭，双方都会收到 <code>{tcp_closed, Socket}</code> 消息</li><li>false<br>这仅仅用于当对方的Socket的写关闭时，仍然向对方发送数据的场景，如果B的Socket设置为 <code>{exit_on_close, false}</code>, A执行 <code>gen_tcp:shutdown(S, write)</code>，则A不会收到任何消息，而B会收到 `{tcp_closed, Socket}消息，但是不会关闭Socket，B可以正常给A发消息，A也能正常接受</li></ol></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Erlang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Dog-Pile Effect</title>
      <link href="/Distributed/Distributed/Dog%20Pile%20Effect/"/>
      <url>/Distributed/Distributed/Dog%20Pile%20Effect/</url>
      <content type="html"><![CDATA[<h3 id="(一)_什么是_Dog_Pile_Effect？">(一) 什么是 Dog Pile Effect？</h3><p>在一个缓存系统中，同一时间段内，所有缓存同时失效，请求将穿透缓存层，直接访问数据库或者其它慢速设备，导致服务器卡顿甚至是宕机，这个现象被称为 <code>Dog Pile Effect</code></p><h3 id="(二)_解决方式">(二) 解决方式</h3><p>之所以出现这个现象，主要是因为许多缓存，设置了相同的过期时间，导致穿透缓存层的操作太多，使设备的负载过高。其解决方式一般有两种:</p><ol><li>通过锁操作，保证同一时间，只有一个请求去更新缓存</li><li>缓存更新的操作，只能由单独的线程或者进程去操作，请求只能读取缓存层数据    </li></ol>]]></content>
      
      <categories>
          
          <category> Distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Distributed </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务</title>
      <link href="/Database/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>/Database/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="一-_什么是数据库事务">一. 什么是数据库事务</h2><p>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p><h2 id="二-_事务的四个基本要素(ACID)">二. 事务的四个基本要素(ACID)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: 原子性 (Atomicity)</span><br><span class="line">C: 一致性 (Consistency)</span><br><span class="line">I: 隔离性 (Isolation)</span><br><span class="line">D: 持久性 (Durability)</span><br></pre></td></tr></table></figure><ol><li><p>原子性</p><p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节</p></li><li><p>一致性</p><p> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏，而且符合业务逻辑。</p></li><li><p>隔离性</p><p> 并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据，这称为隔离性。</p></li><li><p>持久性</p><p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</p></li></ol><h2 id="三-_数据库并发">三. 数据库并发</h2><h3 id="3-1_由于并发带来的异常">3.1 由于并发带来的异常</h3><ul><li><code>Lost update</code><br>更新丢失, 两个事务都同时更新一行数据但是第二个事务却中途失败退出导致对数据两个修改都失效了</li><li><code>Dirty Read</code><br>脏读, 一个事务开始读取了某行数据但是另外一个事务已经更新了此数据但没有能够及时提交</li><li><code>Non-repeatable Reads</code><br>不可重复读, 在一个事务中对同一行数据重复读取两次但是却得到了不同结果</li><li><code>Second lost update problem</code><br>两次更新问题,有两个并发事务同时读取同一行数据然后其中一个对它进行修改提交而另一个也进行了修改提交这就会造成第一次写操作失效</li><li><code>Phantom Reads</code><br>幻读,事务在操作过程中进行两次查询，第二次查询结果包含了第一次查询中未出现的数据。这是因为在两次查询过程中有另外一个事务插入数据造成的</li></ul><h3 id="3-2_如何解决并发问题">3.2 如何解决并发问题</h3><h3 id="3-2-1_锁">3.2.1 锁</h3><ul><li>排它锁（Exclusive Locks，即X锁）</li><li>共享锁（Share Locks，即S锁）</li><li>乐观锁与悲观锁</li></ul><h3 id="3-2-1-1_悲观锁">3.2.1.1 悲观锁</h3><p>每次操作数据前都会一直阻塞直到它拿到锁，操作完成后释放锁。根据锁的粒度不同，可以分为行锁、表锁、读锁、读写锁等。适合于读少写多情景。</p><h3 id="3-2-1-2_乐观锁">3.2.1.2 乐观锁</h3><p>操作数据前不会阻塞直到拿到锁，只要数据能够满足 <code>(之前的版本号 + 1 ) &gt; 现在的版本号</code>，则它就会更新数据，并且更新版本号(此处的版本号，是通过在表中增加一个字段<code>version</code> 用于记录)；否则它就会一直尝试重试操作，直至满足条件。由于 <code>retry</code> 是一个很费时的操作，所以乐观锁常常用于读多写少的情况。</p><p>例如：<br>假设有火车票100张, 当前数据库的版本号为1。线程1，直接去读数据，然后减10，得到90，然后更新数据时，发现<code>2(之前的版本号 + 1) 大于 1(数据库当前的版本号)</code>，所以更新数据。线程2读数据时，同时也读到了火车票100，版本号为1，然后减20，得到80，但是去更新数据时，发现<code>2(之前的版本号 + 1) 不大于 2(数据库当前的版本号)</code>，所以更新失败，然后必须retry</p><h3 id="3-2-2_设置隔离等级">3.2.2 设置隔离等级</h3><p>SQL标准中规定了四个隔离等级</p><ul><li><code>Read Uncommitted</code><br>未提交读，不允许更新失败，它允许读取已经被其它用户修改但尚未提交确定的数据。可能会发生脏读, 重复读,幻读。一般通过 <code>排它写锁</code>，使写的操作顺序，从而保证更新的成功。</li><li><code>Read Committed</code><br>提交读，只读取已经提交过的数据，但是并不会返回脏数据, 可能会发生重复读，幻读。可以通过 <code>瞬间共享读锁</code> 和 <code>排他写锁</code> 实现。</li><li><code>Repeatable Read</code><br>可重复读取，禁止不可重复读取和脏读取, 可能会发生幻读。这可以通过 <code>共享读锁</code> 和 <code>排他写锁</code> 实现。</li><li><code>Serialization</code><br> 串行读，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。能够有效避免异常。</li></ul><p>隔离等级越高，其数据库的性能越差，但是数据的安全性越高，常见数据库的默认隔离等级是 <code>Read Uncommitted</code> 和 <code>Read Committed</code></p><h3 id="3-3_常见数据库的默认隔离等级">3.3 常见数据库的默认隔离等级</h3><ul><li>MySQL，默认是 <code>Read Uncommitted</code></li><li>SQL Server， 默认是 <code>Read Committed</code></li><li>Postgresql ， 默认是 <code>Read Committed</code></li></ul>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据库范式</title>
      <link href="/Database/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
      <url>/Database/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="第一范式(1NF)">第一范式(1NF)</h3><p>无重复的列，即数据库表的每一列都是不可分割的原子数据项。</p><p>例如：</p><p>  在一列中，只能存储员工的某一个属性，而不能将员工的所有属性都放在一列。</p><h3 id="第二范式(2NF):">第二范式(2NF):</h3><p>其约束如下:</p><ul><li>必须满足第一范式</li><li>非主属性不能部分依赖于主关键字，即所有非主属性都完全依赖于主关键字，如果里面存在非主属性部分依赖于主关键字，则应该将其独立出来，单独成一张表</li></ul><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</span><br><span class="line">分析:</span><br><span class="line">     学号     --&gt; (姓名， 年龄)， 则表明非主属性部分依赖于主关键字，不满足，</span><br><span class="line">解决方案:</span><br><span class="line">     学号     --&gt; (姓名， 年龄),</span><br><span class="line">     课程Id   --&gt; (课程名称， 学分)</span><br><span class="line">     选课Id   --&gt; (学号， 课程Id, 成绩)</span><br></pre></td></tr></table></figure><h3 id="第三范式(3NF):">第三范式(3NF):</h3><p>其约束如下:</p><ol><li>必须满足第二范式</li><li>必须消除传递依赖</li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(学号)→ （姓名，年龄，性别，系别，系办地址、系办电话)</span><br><span class="line"></span><br><span class="line">分析:</span><br><span class="line">    学号 --&gt; 系别 --&gt; 系办地址 --&gt; 系办电话，这里存在传递依赖</span><br><span class="line">解决方案:</span><br><span class="line">    学号 --&gt; (姓名， 年龄， 性别)</span><br><span class="line">    系号 --&gt; (系办地址， 系办电话)</span><br></pre></td></tr></table></figure><h3 id="第四范式，巴斯-科德范式(BCNF)">第四范式，巴斯-科德范式(BCNF)</h3><p>其约束如下:</p><ol><li>必须满足第三范式</li><li>在主码的任何一个真子集都不能决定于主属性</li></ol><p>例如：</p><p>在关系<code>R</code>中，<code>U</code>为主码，<code>A</code>属性是主码中的一个属性，若存在<code>A-&gt;Y</code>，<code>Y</code>为主属性，则该关系不属性<code>BCNF</code></p>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>蓝绿部署、灰度发布/金丝雀发布、AB测试、滚动发布的概念</title>
      <link href="/DevOps/DevOps/%E5%90%84%E7%A7%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/DevOps/DevOps/%E5%90%84%E7%A7%8D%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="(一)_蓝绿部署（Blue/Green_Deployment）">(一) 蓝绿部署（Blue/Green Deployment）</h3><p>假设线上的有一个<code>AppA</code>版本号为<code>V1</code>的集群(<code>A</code>)，现在需要将<code>AppA</code>从版本<code>V1</code>升级到<code>V2</code>。蓝绿部署中的<strong>蓝</strong>指的是<code>AppA</code>的<code>V1</code>版本集群，而<strong>绿</strong>则指的是<code>AppA</code>的<code>V2</code>版本集群。首先会部署一套与集群<code>A</code>规模完全一样的集群<code>B</code>，在集群<code>B</code>上部署<code>AppA</code>的<code>V2</code>版本，然后将流量全量切换到集群<code>B</code>上。在任何时间，出现任何异常，因为<code>V1</code>版本集群没有删除，所以如果有必要，都可以直接回滚到<code>V1</code>版本。</p><h4 id="1-1_目的">1.1 目的</h4><p>​        用于安全稳定地发布新版本应用，并在必要时回滚。</p><h4 id="1-2_注意点:">1.2 注意点:</h4><p>​         需要关注当从版本<code>V2</code>回滚到<code>V1</code>后，有一部分新的数据，如何回滚?</p><h4 id="1-3_适用场景：">1.3 适用场景：</h4><ol><li>老版本、新版本可以共存的情况，例如代码升级、BUG更新。</li></ol><h3 id="(二)_灰度发布／金丝雀发布">(二) 灰度发布／金丝雀发布</h3><p>灰度发布又称为金丝雀发布。17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为瓦斯检测指标，以便在危险状况下紧急撤离。而金丝雀发布是一种能够平滑过渡的发布方式，增量发布的一种。是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”，测试新版本的性能和表现，根据反馈决定是否全量更新。</p><h4 id="3-1_目的">3.1 目的</h4><p>在保障整体系统稳定的情况下，尽早发现新版本的问题。</p><h4 id="3-2_适用场景">3.2 适用场景</h4><ol><li>新、旧版本能够共存，是灰度发布使用的前提</li><li>用于验证快速验证新功能。例如新开发一个功能，可以选择一部分用户尝试新版本，如果反馈很好，再推广到全体用户。</li></ol><h3 id="(三)_A/B_测试（A/B_Testing）">(三) A/B 测试（A/B Testing）</h3><p>A/B 测试是一种灰度发布方式，让一部分用户继续使用<strong>A版本</strong>，一部分用户开始用<strong>B版本</strong>，根据反馈，逐步扩大试用<strong>B版本</strong>的范围。通常用来测试应用新功能表现的方法，例如受欢迎程度等等。 </p><h4 id="2-1_目的">2.1 目的</h4><p>通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量可信。</p><h3 id="(四)_滚动发布（rolling_update）">(四) 滚动发布（rolling update）</h3><p>滚动发布，一种更加自动化的灰度发布。</p>]]></content>
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Release </tag>
            
            <tag> Deployment </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL语句中的in与exist的区别</title>
      <link href="/Database/Database/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84in%E4%B8%8Eexist%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/Database/Database/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84in%E4%B8%8Eexist%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="1-_sql语句中的in与exist的区别">1. sql语句中的in与exist的区别</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.id=B.id);</span><br></pre></td></tr></table></figure><p>对于以上两种情况，in是在内存里遍历比较，而exists需要查询数据库，所以当B表数据量较大时，exists效率优于in。</p><h2 id="2-_分析：">2. 分析：</h2><ol><li><p><code>IN</code> 语句内部工作原理<br> <code>IN</code> 只执行一次，它查出B表中的所有id字段并缓存起来。之后，检查A表的id是否与B表中的id相等，如果相等则将A表的记录加入结果集中，直到遍历完A表的所有记录。它的查询过程类似于以下过程：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List resultSet = &#123;&#125;;</span><br><span class="line">Array A = (select * from A);</span><br><span class="line">Array B = (select id from B);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i].id == B[j].id) &#123;</span><br><span class="line">        resultSet.add(A[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resultSet;</span><br></pre></td></tr></table></figure></li><li><p><code>EXISTS()</code> 语句内部工作原理<br> <code>exists()</code> 会执行 <code>A.length</code> 次，它并不缓存 <code>exists()</code> 结果集，因为 <code>exists()</code> 结果集的内容并不重要，重要的是其内查询语句的结果集空或者非空，空则返回 <code>false</code>，非空则返回 <code>true</code>。它的查询过程类似于以下过程：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List resultSet = &#123;&#125;;</span><br><span class="line">Array A = (select * from A);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(exists(A[i].id) &#123;  <span class="comment">//执行select 1 from B where B.id=A.id是否有记录返回</span></span><br><span class="line">       resultSet.add(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resultSet;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-_总结：">3. 总结：</h2><p>可以发现，无论是 <code>in</code> 还是 <code>exist</code> 都是一个双循环，而从底层的角度去看，外面的循环如果比里面循环多的话，相对于外面的循环比里面的循环少，效率更高，这是一方面。另一方面， <code>in</code> 是将结果查询出来，而 <code>exist</code> 仅仅用于查询数据是否存在，同等情况下，当然 <code>exist</code> 效率更高。</p><ol><li>当A与B数据相同时，使用 <code>exist</code> 效率高一点</li><li>当A比B大时，使用 <code>in</code> 效率高</li><li>当A比B小时，使用 <code>exist</code> 效率高</li></ol>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Postgresql-窗口函数</title>
      <link href="/Database/Database/Postgresql-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/Database/Database/Postgresql-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="0-_场景">0. 场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE empsalary(</span><br><span class="line">depname varchar,  -- 部门名称</span><br><span class="line">empno bigint,     -- 员工号</span><br><span class="line">salary int        -- 工资</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------|-------|------</span><br><span class="line">AAAA   |  1    |  10</span><br><span class="line">AAAA   |  2    |  11</span><br><span class="line">AAAA   |  3    |  12</span><br><span class="line">BBBB   |  4    |  7</span><br><span class="line">BBBB   |  5    |  6</span><br><span class="line">CCCC   |  6    |  5</span><br></pre></td></tr></table></figure><ul><li><p>计算平均工资<br><code>select avg(salary) FROM empsalary</code><br>结果为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">avg</span><br><span class="line">--------------------</span><br><span class="line"> 8.5000000000000000</span><br></pre></td></tr></table></figure></li><li><p>计算每个部门的平均工资<br><code>select depname, avg(salary) from empsalary group by depname;</code><br>结果为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> depname |         avg</span><br><span class="line">---------+---------------------</span><br><span class="line"> AAAA    | 11.0000000000000000</span><br><span class="line"> BBBB    |  6.5000000000000000</span><br><span class="line"> CCCC    |  5.0000000000000000</span><br></pre></td></tr></table></figure></li><li><p>计算每个部门的平均工资及每个在各自部分的工资排名<br><code>select empno, depname, avg(salary) OVER (PARTITION BY depname), row_number() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary;</code><br>结果为:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> empno | depname |         avg         | row_number</span><br><span class="line">-------+---------+---------------------+------------</span><br><span class="line">     3 | AAAA    | 11.0000000000000000 |          1</span><br><span class="line">     2 | AAAA    | 11.0000000000000000 |          2</span><br><span class="line">     1 | AAAA    | 11.0000000000000000 |          3</span><br><span class="line">     4 | BBBB    |  6.5000000000000000 |          1</span><br><span class="line">     5 | BBBB    |  6.5000000000000000 |          2</span><br><span class="line">     6 | CCCC    |  5.0000000000000000 |          1</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-_窗口函数">1. 窗口函数</h3><p>窗口函数类似于聚合函数，但是不会将聚合后的结果输出一行而是每一行都是分开的，但是与整体又是有关系的，而且 <code>整体</code> 的粒度也是可以控制的。</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function_name ([expression [, expression ... ]]) OVER ( window_definition )</span><br><span class="line">function_name ([expression [, expression ... ]]) OVER window_name</span><br><span class="line">function_name ( * ) OVER ( window_definition )</span><br><span class="line">function_name ( * ) OVER window_name</span><br></pre></td></tr></table></figure><p><strong>window_definition</strong> 可以是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ existing_window_name ]</span><br><span class="line">[ PARTITION BY expression [, ...] ]</span><br><span class="line">[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS &#123; FIRST | LAST &#125; ] [, ...] ]</span><br><span class="line">[ frame_clause ]</span><br><span class="line"></span><br><span class="line">PARTITION BY 将数据进行分组</span><br><span class="line">ORDER BY 将某一个分组中的数据进行排序</span><br></pre></td></tr></table></figure><p><strong>frame_clause</strong> 可以是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ RANGE | ROWS ] frame_start</span><br><span class="line">[ RANGE | ROWS ] BETWEEN frame_start AND frame_end</span><br></pre></td></tr></table></figure><p><strong>frame_start</strong> 和 <strong>frame_end</strong> 可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UNBOUNDED PRECEDING  : 从分区中的第一行开始</span><br><span class="line">value PRECEDING      : 从当前行之前指定的行数启动，只针对ROWS模式</span><br><span class="line">CURRENT ROW          : 当前行，如果不设置 frame_end，默认为 CURRENT ROW</span><br><span class="line">value FOLLOWING      : 从当前行之后指定的行数结束，只针对ROWS模式</span><br><span class="line">UNBOUNDED FOLLOWING  : 以分区中的最后一行作为结束</span><br></pre></td></tr></table></figure><h3 id="2-_常见函数">2. 常见函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- row_number()                                        从当前开始，不间断,如1，2，3，4，5，6</span><br><span class="line">- rank()                                              从当前开始，会间断，如1，2，2，4，5，6</span><br><span class="line">- dense_rank()                                        从当前开始不间断，但会重复，如1，2，2，3，4，5</span><br><span class="line">- percent_rank()                                      从当前开始，计算在分组中的比例，如0，0.25，0.25，0.75，1，0，1 从0-1不断地循环</span><br><span class="line">- cume_dist()                                         当前行的排序除以分组的数量,如分组有4行，则值为0.25，0.5，0.75，1</span><br><span class="line">- ntile(num_buckets integer)                          从1到当前值，除以分组的的数量，尽可能使分布平均</span><br><span class="line">- lag(value any [, offset integer [, default any ]])  偏移量函数，取滞后值,如lag(column_name,2,0)表示字段偏移量为2，没有则用default值代替，这里是0，不写默认是null</span><br><span class="line">- lead(value any [, offset integer [, default any ]]) 偏移量函数，取提前值,类上</span><br><span class="line">- first_value(value any)                              返回窗口框架中的第一个值</span><br><span class="line">- last_value(value any)                               返回窗口框架中的最后一个值</span><br><span class="line">- nth_value(value any, nth integer)                   返回窗口框架中的指定值，如nth_value(salary,2),则表示返回字段salary的第二个窗口函数值</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Postgresql-问题及方案</title>
      <link href="/Database/Database/Postgresql-%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
      <url>/Database/Database/Postgresql-%E9%97%AE%E9%A2%98%E5%8F%8A%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="1-_客户端远程连接配置">1. 客户端远程连接配置</h3><ul><li>编辑 /etc/postgresql/9.4/main/postgresql.conf文件，将<code>listen_addresses = &#39;localhost&#39;</code>改成<code>listen_addresses = &#39;*&#39;</code></li><li><p>编辑 /etc/postgresql/9.4/main/pg_hba.conf 文件, 其中有一行注释:<br> <code># TYPE DATABASE USER ADDRESS METHOD</code></p><ul><li>TYPE<br>连接类型, local / host / hostssl / hostnossl, local表示Unix下的套接字， host表示可能是一个普通的套接字或者一个SSL加密的TCP/IP套接字， hostssl，是一个SSL加密的TCP/IP套接字， hostnossl是一个普通套接字。</li><li>DATABASE<br>可以使用的数据库名，连接上的用户可以使用的数据库名字。也可以使用“all”来允许用户访问所有数据库。多个数据库之间，使用逗号分隔。</li><li>USER<br>连接时，使用的数据库中的用户</li><li>ADDRESS<br>地址，允许连接的地址， 采用CIDR的方式，格式为“地址/网络前缀所占的比特数”, 如“192.168.2.255/24”。</li><li>METHOD<br>验证方法， trust / reject / md5 / password / gss / sspi / ident / peer / pam / ldap / radius / cert， password，会以明文进行传输，md5则是一种更好的加密方式</li></ul><p>只需要根据以上的规则添加一条数据就好</p></li></ul>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL问题及解决方案</title>
      <link href="/Database/Database/MySQL%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/Database/Database/MySQL%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h3 id="1-_win7下忘记了本地mysql密码应该怎么找回">1. win7下忘记了本地mysql密码应该怎么找回</h3><ol><li>首先以系统管理员身份登陆系统</li><li>停止mysql服务<br><code>net stop mysql</code></li><li>到mysql的安装路径，打开dos窗口，并运行：<br><code>mysqid --skip-grant-tables</code></li><li>然后另外打开一个命入令行窗口，执行mysql，此时无需密码</li><li><p>更改之前的密码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET Password = password(&apos;newpassword&apos;) WHERE User = &apos;root&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li><li><p>结束mysqld进程，重启mysql，即可</p></li></ol><h3 id="2-_MySQL提示_“You_are_using_safe_update_mode_and_you_tried_to_update_a_tablewithout_a_WHERE_clause_that_uses_a_KEY_column-”">2. MySQL提示 “You are using safe update mode and you tried to update a tablewithout a WHERE clause that uses a KEY column.”</h3><blockquote><p>  执行一下<code>SET SQL_SAFE_UPDATES = 0;</code></p></blockquote><h3 id="3-_调整MySQL执行SQL长度的限制">3. 调整MySQL执行SQL长度的限制</h3><p>默认的SQL的长度为1M， 可以通过修改 <code>my.ini</code> 中的 <code>max_allowed_packet</code></p><h3 id="4-_执行命令时，提示Ignoring_query_to_other_database">4. 执行命令时，提示<code>Ignoring query to other database</code></h3><p>在连接mysql时没有使用<code>-u</code>指定用户导致的</p>]]></content>
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>配置中心选型</title>
      <link href="/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/Config/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/"/>
      <url>/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/Config/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="(一)_背景">(一) 背景</h3><h4 id="为什么需要配置中心">为什么需要配置中心</h4><p>传统的基于文件的配置方式，存在很多问题，诸如: 修改配置需要重新部署，权限控制、不同的环境需要重新编译等等。配置中心将所有的配置集中控制，提供方便的配置方式、热部署、修改配置后代码自动感知，能提供便利的同时，减少开发的复杂度。公司的项目越来越多，配置中心则变成越来越急迫。</p><h4 id="已有zookeeper、etcd还需要引入吗？">已有zookeeper、etcd还需要引入吗？</h4><p><code>zookeeper</code>、<code>etcd</code>并没有方便的UI管理工具，且缺乏权限、审核等机制，使用并不方便，最重要的是，<code>etcd</code>和<code>zookeeper</code>通常定义为服务注册中心，并非配置中心。</p><h4 id="有哪些开源配置中心">有哪些开源配置中心</h4><ul><li><p>spring-cloud/spring-cloud-config<br>  <a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a><br>  spring出品，可以和spring cloud无缝配合</p></li><li><p>淘宝 diamond<br>  <a href="https://github.com/takeseem/diamond" target="_blank" rel="noopener">https://github.com/takeseem/diamond</a><br>  已经不维护</p></li><li><p>disconf<br>  <a href="https://github.com/knightliao/disconf" target="_blank" rel="noopener">https://github.com/knightliao/disconf</a><br>  java开发，蚂蚁金服技术专家发起，在百度、滴滴等大公司内广泛使用</p></li><li><p>ctrip apollo<br>  <a href="https://github.com/ctripcorp/apollo/" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/</a><br>  Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</p></li></ul><h3 id="我们需要的功能有哪些">我们需要的功能有哪些</h3><ol><li>可以在界面上配置</li><li>通过Http请求获取最新配置</li><li>支持多环境</li><li>配置变更，通过http请求接受到通知</li><li>提供API接口，用于修改参数</li><li>权限、审计功能完善</li><li>高可用、健壮</li><li>活跃度高</li></ol><h3 id="(二)_配置中心如何选择？">(二) 配置中心如何选择？</h3><p>基于公司的情况，我们首先会排除<code>spring-cloud-config</code>和<code>diamond</code>，<code>spring-cloud-config</code>是<code>spring cloud</code>和<code>spring boot</code>的一部分，这将限制其语言只能是<code>java</code>和<code>spring</code>框架，而我们公司项目所使用的语言很多，不仅仅有<code>Java</code>还有<code>Go</code>、<code>php</code>，所以会排除<code>spring-cloud-config</code>。而<code>diamond</code>现在已经不开源，在<code>github</code>的项目大多是很早之前<code>diamond</code>开源出来时而<code>fork</code>出来的分支，所以<code>diamond</code>也不考虑。接下来，从各个方面深入比较<code>disconf</code>和<code>apollo</code>项目。</p><table><thead><tr><th>功能点</th><th>优先级</th><th>disconf</th><th>apollo</th></tr></thead><tbody><tr><td>可以在界面上配置</td><td>高</td><td>支持</td><td>支持</td></tr><tr><td>通过Http请求获取最新配置</td><td>高</td><td>支持</td><td>支持</td></tr><tr><td>支持多环境</td><td>高</td><td>支持</td><td>支持</td></tr><tr><td>配置变更，通过http请求接受到通知</td><td>高</td><td>不支持</td><td>不支持</td></tr><tr><td>提供API接口，用于修改参数</td><td>中</td><td>支持</td><td>支持</td></tr><tr><td>权限、审计功能完善</td><td>中</td><td>不支持</td><td>支持</td></tr><tr><td>高可用、健壮</td><td>高</td><td>高可用</td><td>高可用</td></tr><tr><td>活跃度高</td><td>高</td><td>活跃度不高，在github上最新一次修改是2年前</td><td>活跃度很高，最近一次修改在2018年10月10号</td></tr><tr><td>依赖项</td><td>高</td><td>依赖于mysql、tomcat、nginx、zookeeper、redis</td><td>依赖于mysql、eureka</td></tr><tr><td>客户端的支持</td><td>高</td><td>只支持Java客户端</td><td>客户端支持Java、php、Go、.Net等，Java和.Net是官方支持的，其它是社区开发</td></tr></tbody></table><h4 id="Disconf的优点"><code>Disconf</code>的优点</h4><p>项目出现比较早，经过了很多大公司的实践，高可用和稳定性方面都是毋庸置疑的</p><h4 id="Disconf的缺点"><code>Disconf</code>的缺点</h4><ol><li>项目很久没有更新，即是缺点也是优点，说明该项目很稳定，但是同时，如果有新的功能，也只能是自己开发</li><li>功能比较基础，无权限、审计功能，界面也很简单</li><li>依赖项比较多，不仅仅依赖于<code>zookeeper</code>，还依赖于<code>redis</code>，而且<code>redis</code>必须为集群</li><li>部署麻烦，依赖于<code>tomcat</code>、<code>nginx</code></li></ol><h4 id="Apollo的优点"><code>Apollo</code>的优点</h4><ol><li>使用该项目的公司越来越多</li><li>功能强大: 权限、审计、灰度、版本控制，几乎你能想到，并且实际可用的功能都已经有了</li><li>文档完整</li><li>部署简单，部署的包都是<code>jar</code></li><li>仅仅只是依赖于<code>mysql</code>和<code>eureka</code>，并且<code>eureka</code>已经集成到<code>jar</code>中，并不需要自己维护</li></ol><h4 id="Apollo的缺点"><code>Apollo</code>的缺点</h4><p>虽然越来越多的公司接入<code>Apollo</code>，但是<code>Apollo</code>相对于<code>Disconf</code>而言，还是更年轻，并且版本并不稳定，更新频率比较高。</p><p>最终的还是选择<strong><code>Apollo</code></strong>项目。</p><h3 id="(三)_如何解决配置变更，通过Http请求通知相应服务？">(三) 如何解决配置变更，通过Http请求通知相应服务？</h3><p>初步打算通过<code>QBus</code>的订阅功能实现转发。</p>]]></content>
      
      <categories>
          
          <category> 配置中心 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>银行家算法</title>
      <link href="/Computer/Computer/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
      <url>/Computer/Computer/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-_安全状态">1. 安全状态</h3><p>是指系统能按某种进程顺序（P1，P2, P2…）（安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求。</p><h3 id="1-_安全性算法">1. 安全性算法</h3><ol><li>设置两个变量<ul><li>Work: 它表示系统可提供给进程继续运行所需的各类资源数目</li><li>Finish: 表示系统是否有足够的资源分配给进程，使之运行完成</li></ul></li><li>找到一个能满足下面要求的进程：<ol><li>Finish[i] = false</li><li>Need[i, j] &lt;= Work[j], 若找到，则执行（3），否则执行（4）</li></ol></li><li><p>分配资源</p><pre><code>Work<span class="string">[j]</span> = Work<span class="string">[j]</span> + Allocation<span class="string">[i, j]</span>Finish<span class="string">[i]</span> = truego to step2</code></pre></li><li>表明系统处于不安全状态</li></ol><h3 id="2-_银行家算法">2. 银行家算法</h3><ul><li><p>数据结构：</p><ul><li>Available, 可利用资源</li><li>Max,  最大需求矩阵</li><li>Allocation， 分配矩阵</li><li>Need，需求矩阵</li></ul></li><li><p>算法：</p><ul><li>如果Request[j] &lt;= Need[i, j], 则转向（2），否则，其需要的资源数已超过它所宣布的最大需求</li><li>如果 Request[j] &lt;= Available[j], 则转向（3），否则，无法满足其需求</li><li><p>系统分配资源，并修改值</p><pre><code>Available<span class="string">[j]</span> ＝ Available<span class="string">[j]</span> - Request<span class="string">[j]</span>;Allocation<span class="string">[i, j]</span> = Allocation<span class="string">[i, j]</span> + Request<span class="string">[j]</span>;Need<span class="string">[i, j]</span> = Need<span class="string">[j]</span> - Request<span class="string">[j]</span></code></pre></li></ul></li><li><p>执行安全性算法</p></li></ul>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Unicode编码</title>
      <link href="/Computer/Computer/Unicode%E7%BC%96%E7%A0%81/"/>
      <url>/Computer/Computer/Unicode%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h3 id="1-_Unicode">1. Unicode</h3><p>统一码、万国码、单一码、标准万国码，是计算机科学领域里的一项业界标准，用以统一地体现和处理世界上大部分的文字系统，并为其编码，即规定什么数字代表了什么字符，但是却没有规定用多少个字节去表现一个数字，因此Unicode的实现方式有多种。</p><ul><li>UCS，<code>Universal Character Set</code>，UCS 是所有其他字符集标准的一个超集</li><li>UTF，<code>Unicode Transformation Format</code>，Unicode转换格式。</li><li>中文编码: <code>GB2312</code></li><li>GBK， 汉字内码扩展规范， 大于GB2312</li><li>中文的Unicode范围是: <code>4e00 ~ 9fff</code></li></ul><h3 id="2-_UTF-8编码">2. UTF-8编码</h3><p>UTF-8采用变长字节存储 <code>Unicode</code>。分以下两种情况:</p><ul><li>针对 <code>7位ASCII字符</code> 仍用 <code>7位编码</code> 表示，占用一个字节（首位补0）</li><li>针对Unicode字符混合的情况，将按一定算法转换，每个字符使用 <code>1-3</code> 个字节编码，并利用首位标记符进行识别</li></ul><p>这样对以7位ASCII字符为主的西文文档就大大节省了编码长度，能够避免造成资源浪费。编码范围如下:</p><center><img src="/pics/UTF8-范围.jpg" alt=""></center><p>编码过程如下:</p><ol><li>获取待编码字符的Unicode码</li><li>根据上面的UTF-8的编码范围，UTF-8字节流模板</li><li>将Unicode转换成二进制，然后依次填入字节流模板中，高位不足的，用0代替</li></ol><p>例如:</p><p>将汉字中的“严”编码成UTF-8</p><ol><li><code>严</code>的Unicode编码是<code>4E25(100111000100101)</code></li><li>根据上表，可得知其字节流模板是第三个，<code>1110xxxx 10xxxxxx 10xxxxxx</code></li><li>将Unicode的二进制码依次填入其中即可，是在高位补0，即可得 <code>11100100 10111000 10100101</code>(十六进制的 <code>E4B8A5</code>)</li></ol><h3 id="3-_BOM的意义">3. BOM的意义</h3><p><code>BOM</code>， <code>byte-order mark</code>，出现在字节流首部，通常用于<code>UTF-16</code>和`UTF-32，用于标识字节序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EF BB BF,                         UTF-8</span><br><span class="line">FF FE UTF-16 aka UCS-2,           little endian</span><br><span class="line">FE FF UTF-16 aka UCS-2,           big endian</span><br><span class="line">00 00 FF FE UTF-32 aka UCS-4,     little endian.</span><br><span class="line">00 00 FE FF UTF-32 aka UCS-4,     big-endian.</span><br></pre></td></tr></table></figure><p>UTF-8以字节为编码单元，没有字节序的问题, 所以通常用<code>BOM</code>来表示<strong>编码顺序</strong>，但是没有<code>BOM</code>的<code>UTF-8</code>才是标准的<code>UTF-8</code>，带<code>BOM</code>的<code>UTF-8</code>是微软的标准。</p>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>哈希</title>
      <link href="/Computer/Computer/%E5%93%88%E5%B8%8C/"/>
      <url>/Computer/Computer/%E5%93%88%E5%B8%8C/</url>
      <content type="html"><![CDATA[<h2 id="1-_Hash构造">1. Hash构造</h2><ul><li>直接定址法<br>哈希函数为关键字的线性函数, 如H(key) = a * key + b</li><li>数字分析法<br>假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。通常根据字段的频率，来组合，从而避免冲突。</li><li>平方取中法<br>以关键字的平方值的中间几位作为存储地址</li><li>折叠法<br>将关键字分割成若干部分，然后取它们的叠加和为哈希地址</li><li>除留余数法<br>取模，根据余数来Hash</li><li>随机数法<br>哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数</li></ul><h2 id="2-_冲突解决">2. 冲突解决</h2><ul><li>开放定址法<ul><li>方法<br>使用某种探测技术在散列表中形成一个探测序列, 沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址为止查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。探测函数:<br><code>Hi = ( H(key) +di ) MOD m</code>,<br>(m是整个散列表的长度, H(key)表明是其hash结果, di则是某一个值，用来遍历整个散列表)</li><li>特点: 快速，并且能充分利用空间</li></ul></li><li>再哈希法<ul><li>方法<br>构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发生。即：Hi=Rhi(key) i=1,2,……k，其中：Rhi表示不同的哈希函数</li><li>特点：计算时间增加</li></ul></li><li>链地址法<ul><li>方法：如果冲突，则在当前Hash值下创建一个链表，不断地往下加数据</li><li>特点：能有效解决冲突，并且能实现扩容</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浮点数在内存中的表示形式及浮点数应该注意的地方</title>
      <link href="/Computer/Computer/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E5%8F%8A%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/Computer/Computer/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E5%8F%8A%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      <content type="html"><![CDATA[<h3 id="一-_进制转换">一. 进制转换</h3><ol><li>整数部分：<ol><li>反复除以进制数，并记录余数</li><li>将余数以逆序输出</li></ol></li><li>小数部分：<ol><li>反复乘以进制数，并记录整数部分</li><li>顺序输出</li></ol></li></ol><h3 id="二-_浮点数在内存中的表示形式">二. 浮点数在内存中的表示形式</h3><p>目前C/C++编译器所采用的都是IEEE所制定的标准浮点格式，即为二进制科学表示法, 即：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;V = (<span class="number">-1</span>) ^ s * M * <span class="number">2</span> ^ N</span><br><span class="line">&gt;s : 符号位, <span class="number">0</span>(正数)， <span class="number">1</span>（负数）</span><br><span class="line">&gt;M : 阶码, 表示有效数字，大于<span class="number">1</span>，小于<span class="number">2</span></span><br><span class="line">&gt;E : 尾数, <span class="number">2</span>^E，表示指数位</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这仅仅是二进制科学表示法，而在内存中一个浮点数由三个部分组成</p><ul><li>符号位<br>1位，0表示正数，1表示负数</li><li>阶码<br>8 / 11位，这是一个无符号整数(unsigned int)。这意味着，如果Ｅ为8位，它的取值范围为0~255；如果Ｅ为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出 现负数的，所以IEEE规定，阶码Ｅ的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。针对Ｅ有三种情况：<ol><li>E不全为0或不全为1<br>指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</li><li>E全为0<br>浮点数指数E等于1-127(或者1-1023)，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数,这样做是为了表示±0,以及接近于0的很小的数字。</li><li>E全为1<br>如果有效数字M全为0，表示±无穷大(正负取决于符号位s);如果有效数字M不全为0，表示这个数不是一个数(NaN)</li></ol></li><li>尾数<br>23 / 52位，因为1 &lt;= M &lt; 2，所以M可以写成1.xxxxxx的形式，为了方便，就规定把第一个<code>1</code>去掉，表示成“xxxxxx”，读取数据时，再加上<code>1</code>即可。</li></ul><h3 id="三-_例子">三. 例子</h3><ol><li><p>为什么0x00000009还原成浮点数，就成了0.000000？<br>首先，将0x00000009拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M=000 0000 0000 0000 0000 1001，由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：<code>V=(-1)^0x0.00000000000000000001001x2^(-126)=1.001x2^(-146)</code>显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。</p></li><li><p>请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？<br>首先，浮点数9.0等于二进制的1001.0，即1.001x2^3。那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。所以，写成二进制形式，应该是s+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个32位的二进制数，还原成十进制，正是1091567616。</p></li></ol><h3 id="四-_测试">四. 测试</h3><ol><li><p>pre<br>(int&amp;)a，这个表示将a的值在内存中的表示，直接解析成int，如上述的9.0，在内存中表示转换成16进制后，结果就为输出的41100000，如果转换成10进制后，则会输出 <code>109156761</code>。</p></li><li><p>code</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">9.0f</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;hex&lt;&lt; (<span class="keyword">int</span>&amp;)a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"addr:"</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span> &lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; ( (<span class="keyword">int</span>)a == (<span class="keyword">int</span>&amp;)a ) &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;hex&lt;&lt; (<span class="keyword">int</span>&amp;)b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"addr:"</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">" "</span> &lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; ( (<span class="keyword">int</span>)b == (<span class="keyword">int</span>&amp;)b ) &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;hex&lt;&lt; (<span class="keyword">int</span>&amp;)c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"addr:"</span>&lt;&lt;&amp;c&lt;&lt;<span class="string">" "</span> &lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; ( (<span class="keyword">int</span>)c == (<span class="keyword">int</span>&amp;)c ) &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> d = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;hex&lt;&lt; (<span class="keyword">int</span>&amp;)d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"addr:"</span>&lt;&lt;&amp;d&lt;&lt;<span class="string">" "</span> &lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; ( (<span class="keyword">int</span>)d == (<span class="keyword">int</span>&amp;)d ) &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果为：</p></li></ol><center><img src="/pics/Computer-float.jpg" alt=""></center><h3 id="五-_浮点数的比较：_应该用一个精度来表示:">五. 浮点数的比较： 应该用一个精度来表示:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相等： `|a - b| &lt;= DOUBLEEPSION`</span><br><span class="line">大于： `a - b &gt; DOUBLEEPSION`</span><br><span class="line">小于： `a - b &lt;（-DOUBLEEPSION）`</span><br><span class="line">DOUBLEEPSION表示精度</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程原则</title>
      <link href="/Coding/Coding/%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
      <url>/Coding/Coding/%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h3 id="KISS原则">KISS原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keep It Simple, Stupid</span><br></pre></td></tr></table></figure><h3 id="DRY">DRY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Don’t repeat yourself</span><br></pre></td></tr></table></figure><h3 id="TED">TED</h3><ul><li><code>Terse</code>，简洁</li><li><code>Expressive</code>，具有表达力</li><li><code>Do one thing</code>, 只做一件事</li></ul><h3 id="编程习惯">编程习惯</h3><ul><li>在一个函数内，只能改变局部的变量，而需要改变外面的变量时，必须通过相应的接口，而不是直接修改其数据</li><li>对数据的操作，一定得独立出来</li><li>尽量使用目录结构使整个项目清晰明了</li><li>每个函数完成的功能尽量单一</li><li>使用异常时，只在最外面捕捉异常，在内部不用管，方便找出程序的bug</li><li>拒绝注释，用代码来阐述注释</li><li>拒绝魔数</li></ul>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CPU架构标准</title>
      <link href="/Computer/Computer/CPU%E6%9E%B6%E6%9E%84/"/>
      <url>/Computer/Computer/CPU%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="一-_常见的CPU架构">一. 常见的CPU架构</h3><p>CPU架构根据其指令的复杂程序可以分为两类:</p><ul><li>CISC<br><code>Complex Instruction Set Computer</code>，复杂指令集计算机，<code>X86系列</code> 都为 <code>CISC</code></li><li>RISC<br><code>Reduced Instruction Set Computer</code>，精简指令集计算机，<code>ARM</code>, <code>MIPS</code>, <code>Power PC</code>, <code>SPARC</code>等现在主流CPU都为 <code>RISC</code></li></ul><p>相对而言，<code>RISC</code> 具有如下特点:</p><ol><li>更加简单的指令集<br><code>RISC</code> 指令集只提供很有限的操作，指令字等长，效率高，功耗低，并发性高</li><li>Load-Store结构<br>在RISC 中，CPU并不会对内存中的数据进行操作，所有的计算都要求在寄存器中完成。而寄存器和内存的通信则由单独的指令来完成。而在CSIC中，CPU是可以直接对内存进行操作的</li><li>更多的寄存器<br>大部分指令操作指令都存储在寄存器中，提高了处理速度</li></ol><h3 id="二-_X86架构标准">二. X86架构标准</h3><p>如果需要了解X86架构，那就不得不说一下 <code>Intel</code> 和 <code>AMD</code> 的关系了。<code>AMD</code> 之前是帮 <code>Intel</code> 生产CPU的，后来得到了X86架构的授权可以单独生产，后来成为 <code>Intel</code> 的竞争对手。所以它们的生产的CPU架构标准是一样的。X86是所有 <code>i386</code>, <code>i486</code>, …, <code>i686</code> 系列架构的统称，又被称为 <code>IA32</code>, <code>Intel Architecture 32</code>, Intel32位架构</p><ol><li>i386 : Intel 80386架构</li><li>i486 : Intel 80486架构</li><li>i586 : Pentium架构</li><li>i686 : Pentium Pro架构</li><li>x86_64/AMD64 ：X86架构的64位版</li></ol><h3 id="三-_X86_64/AMD64的联系与区别?">三. X86_64/AMD64的联系与区别?</h3><p>在面对64位架构时，有两种选择：</p><ul><li>兼容32位，同时支持64位</li><li>全新的64位指令</li></ul><p>AMD公司，设计实现了兼容32位，同时支持64位的CPU，被称为 <code>AMD64</code>。而 Intel公司，完全抛弃了32位指令，设计实现了全新的64位指令的CPU，称为 <code>IA-64</code>。但是后来 <code>IA-64</code> 并没有得到大众的认可。Intel不得不在落后的情况下，也开始支持AMD64指令集，但是换了一个名字，称为 <code>X86_64</code>(最早称为 <code>IA-32e</code> 或者 <code>EM64T</code>)。</p><h3 id="四-_ARM">四. ARM</h3><p><code>Advanced RISC Machine</code>，是一个32位精简指令集处理器架构。其被广泛地使用在嵌入式系统中。价格低，能耗低。ARM占据了全世界32架构的大部分。</p><h3 id="五-_MIPS">五. MIPS</h3><p><code>Microprocessor without interlocked piped stages</code>, 无内部互锁流水级的微处理器，其机制是尽量利用软件办法避免流水线中的数据相关问题。MIPS是世界上很流行的一种RISC处理器。</p><h3 id="六-_PowerPC">六. PowerPC</h3><p>PowerPC是一种精简指令集架构的中央处理器。PowerPC处理器有非常强的嵌入式表现，它具有优异的性能、较低的能量损耗以及较低的散热量。</p><h3 id="七-_SPARC">七. SPARC</h3><p><code>Scalable Processor Architecture</code>，可扩充处理器架构，是RISC微处理器架构之一。</p><h3 id="八-_常见的CPU指令集">八. 常见的CPU指令集</h3><ol><li>Intel<ol><li>X86 : 32位指令集</li><li>MMX : <code>Multi Media eXtension</code>, 多媒体扩展指令集</li><li>SSE/SSE2/SSE3/SSE4 : <code>Streaming SIMD Extension</code>, 单指令多数据流扩展</li><li>EM64T : 64位指令集</li><li>VT-x : 虚拟化</li></ol></li><li>AMD<ol><li>X86 : 32位指令集</li><li>3D Now : 针对多媒体的扩展</li><li>amd64 : 扩展的64位指令集</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Base64</title>
      <link href="/Computer/Computer/Base64/"/>
      <url>/Computer/Computer/Base64/</url>
      <content type="html"><![CDATA[<h2 id="一-_原理">一. 原理</h2><ul><li>将3个8位的二进制数据，转换成4个6位的二进制数据。</li><li>6位就有64个可能的字符</li><li>64个字符<ol><li>31个大写字母</li><li>31个小写字母</li><li>加上10个数字</li><li><code>+</code>, <code>/</code></li></ol></li></ul><h2 id="二-_步骤">二. 步骤</h2><ol><li>按3个字符进行分组(24位)</li><li>对每一组字符，分成4个6位的字符，然后根据数组转换成相应的字符</li><li>需要的数据，就用零补充。补充的零的个数除以8，结果就是转码后的增加几个“=”<ol><li>0, 即需要转换的字符串的个数，刚好</li><li>1, 即还差2个字符，才能构成3个字符</li><li>2, 即还差1个字符，才能构成3个字符</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CRC校验</title>
      <link href="/Computer/Computer/CRC%E6%A0%A1%E9%AA%8C/"/>
      <url>/Computer/Computer/CRC%E6%A0%A1%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h2 id="一-_CRC">一. CRC</h2><ul><li><p>本质<br>CRC检验本质即在一个P位的二进制序列之后附加一个R位检验码，从而构成一个总长为N=P+R位的二进制。</p></li><li><p>基本原理<br>附加的R位检验码与数据序列之间存在某种特定的关系，如果内容中的某一位数据改变，就会导致这种关系被破坏。因为通过检查这个关系，从而实现数据正确性的检验。</p></li><li><p>基本概念</p></li></ul><ol><li>帧检验序列FCS(Frame Check Sequence)<br>为了进行差错检验而添加的冗余码</li><li>多项式模2运算<br>实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1</li><li>生成多项式(generator polynomial)<br>当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作G（x）。生成多项式的最高位与最低位必须是1。</li></ol><ul><li>常见的CRC检验多项式<ul><li>CRC8=X8+X5+X4+1</li><li>CRC-CCITT=X16+X12+X5+1</li><li>CRC16=X16+X15+X5+1</li><li>CRC12=X12+X11+X3+X2+1</li><li>CRC32=X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+1</li><li>CRC8=X8+X5+X4+1</li><li>CRC-CCITT=X16+X12+X5+1</li><li>CRC16=X16+X15+X5+1</li><li>CRC12=X12+X11+X3+X2+1</li><li>CRC32=X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+1</li></ul></li></ul><h2 id="二-_CRC步骤">二. CRC步骤</h2><ol><li>数据分组</li><li>对每一个数据，向左移动(R-1)位</li><li>对每一个数据，进行模2除法(异或), 除数为R位的多项式数据，将得到(R-1)位的余数(不足位，用0填充)</li><li>将数据放在拼接在原数据后面</li></ol><h2 id="三-_错误检测">三. 错误检测</h2><p>接受方，在接受到数据后，直接与检验多多项式生成除数相除，如果余额为0，则表示数据正确，否则数据错误。</p><h2 id="四-_示例">四. 示例</h2><ol><li>检验多项式<br>R(x)=X5+X4+X2+1  ==》 除数为 110101, 即多项的X，确定除数中1的位置</li><li>原始的数据为1010001101</li><li>此处就不分组了，直接进行模2运算，即异或操作<ol><li>先将原数据向左移R-1位，R是除数的位数，将得到101000110100000</li><li>将101000110100000与110101进行异或操作，将得到商为1101010110, 余数为01110(如果位数不够直接用0进行填充)</li></ol></li><li>最终的序列就是原数据+余数，即101000110101110</li><li>接受方将接受到101000110101110，与除数110101，相异或，余数为0，表示数据正确</li></ol>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
            <tag> CRC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源协议</title>
      <link href="/Computer/Coding/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/Computer/Coding/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<ol><li>GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费</li><li>LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。</li></ol><h3 id="1-_Apache">1. Apache</h3><p>允许使用者修改和重新发布代码(以其他协议形式)，允许闭源商业发布和销售，鼓励代码共享和尊重原作者的著作权。使用Apache Licence协议，需要遵守以下规则：</p><ol><li>需要给代码的用户一份Apache Lience；</li><li>如果你修改了代码，需要在被修改的文件中说明；</li><li>在延伸的代码中（修改或衍生的代码）需要带有原来代码中的协议、商标、专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含了Notice文件，则需要在Notice文件中带有Apache Lience。你可以在Notice中增加自己的许可，但不可以表现为对Apache Lience构成更改。</li></ol><h3 id="2-_BSD开源协议">2. BSD开源协议</h3><p><code>Berkerley Software Distribution</code>, BSD允许使用者修改和重新发布代码(以其他协议形式)，允许闭源商业发布和销售。需要遵守以下规则：</p><ol><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议；</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档那个和版权声明中包含原来代码中的BSD协议；</li><li>不可以用开源代码的 <code>作者/机构的名字</code> 或 <code>原来产品的名字</code> 做市场推广。</li></ol><h3 id="3-_GPL">3. GPL</h3><p><code>GNU General Public License</code>，GPL的出发点是代码的开源/免费使用和引用/修改以及衍生代码的开源/免费使用，但不允许修改后和衍生的代码作为闭源的商业软件发布和销售。</p><h3 id="4-_LGPL">4. LGPL</h3><p><code>GNU Library or &quot;Lesser&quot; General Public License</code>，与GPL的强制性开源不同的是，LGPL允许商业软件通过类库引用(link)的方式使用LGPL类库而不需要开源商业软件的代码。但是如果修改 <code>LGPL</code> 协议的代码或者衍生,则所有修改的代码,涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。</p><h3 id="5-_MIT">5. MIT</h3><p>源自麻省理工学院(<code>Massachusetts Institute of Technology</code>)，和BSD一样，作者只想保留版权,而无任何其他了限制。也就是说,你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的</p><h3 id="6-_MPL">6. MPL</h3><p><code>Mozilla Public License 1.1</code>，协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用的。</p><h3 id="7-_EPL">7. EPL</h3><p><code>Eclipse Public License 1.0</code>, 允许 <code>Recipients</code> 任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p>]]></content>
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编译器对C++的（++a, --a）的优化</title>
      <link href="/C-C/C:C++/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9C++%E7%9A%84%EF%BC%88++a,--a%EF%BC%89%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/C-C/C:C++/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9C++%E7%9A%84%EF%BC%88++a,--a%EF%BC%89%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="1-_测试">1. 测试</h3><p>我们先看两个例子</p><ul><li><p>例子1：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 9;</span><br><span class="line">cout &lt;&lt; a-- &lt;&lt; &quot; &quot; &lt;&lt; --a &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果为：<code>8 7</code></p></li><li><p>例子2：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 9;</span><br><span class="line">cout &lt;&lt; --a &lt;&lt; &quot; &quot; &lt;&lt; --a &lt;&lt; &quot; &quot; &lt;&lt; --a &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果为: <code>6 6 6</code></p></li><li><p>例子3：<br>通过上面的例子，我想我们可以发现很多不寻常的地方，比如针对第一个例子，如果按我们的理解，结果是不是应该是 <code>9 7</code>，但是结果却是 <code>8 7</code>，第二个例子我们也认为结果是 <code>8 7 6</code>，但是结果却为 <code>6 6 6</code>，但是如果我们分别在 <code>int a = 9</code>，这个例子前面加上关键字 <code>volalite</code>，我们会发现：更改后第一个例子的结果是：<code>8 8</code></p></li><li><p>例子4：<br>更改后的第二个例子的结果是： <code>6 7 8</code><br>后来我又做了以下测试：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 9;</span><br><span class="line">cout &lt;&lt; a-- &lt;&lt; &quot; &quot; &lt;&lt; a-- &lt;&lt; &quot; &quot; &lt;&lt; a-- &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果为：<code>7 8 9</code></p></li><li><p>例子5：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 9;</span><br><span class="line">cout &lt;&lt; ++a &lt;&lt; &quot; &quot; &lt;&lt; ++a &lt;&lt; &quot; &quot; &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  结果为：<code>12 12 12</code></p></li></ul><h3 id="2-_总结">2. 总结</h3><ol><li><code>&lt;&lt;</code> 的结合性是从右到左的，即从最后一个开始进行计算，这是一个推论，也许不正确，我也怀疑可能是因为 <code>cout</code> 的调动协议是 <code>_stdcall</code>，那么它的入栈顺序是从右到左；</li><li>如果在一个计算中，如果既存在前置的 <code>++</code>，或者 <code>--</code> 则会做优化，即将相同的运算积累到一次，而且输出的是最后一次的结果（测试一，则输出最后一次的ａ的结果），而后置的 <code>++</code>，<code>--</code> 则不会做此优化。</li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++命名的返回值优化</title>
      <link href="/C-C/C:C++/%E5%91%BD%E5%90%8D%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"/>
      <url>/C-C/C:C++/%E5%91%BD%E5%90%8D%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="1-_命名的返回值优化">1. 命名的返回值优化</h3><p>NRVO, <code>Named Return Value optimization</code>，针对返回一个局部的变量的优化，可以直接用返回的结果对象直接替代局部变量，从而减少了一个复制拷贝，从而提高效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X bar()</span><br><span class="line">&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    // .. 处理xx</span><br><span class="line">    return xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在编译器看来则是如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 此处的 _result是一个在调用该函数时产生的一个临时对象, 然后将该对象传入，用以接受结果</span><br><span class="line">void bar(X &amp; __result)</span><br><span class="line">&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    // 调用xx的构造函数</span><br><span class="line">    xx.X::X();</span><br><span class="line">    // .. 处理xx</span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">   _result.X::X(xx);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是没有采用NRVO优化的，下面是优化后的代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void bar(X &amp; __result)</span><br><span class="line">&#123;</span><br><span class="line">    // 拷贝构造函数,直接用__result替换掉局部变量</span><br><span class="line">    // 从而提高了效率</span><br><span class="line">    __result.X::X();</span><br><span class="line"> </span><br><span class="line">    // ....  对xx的处理，变成了对__result的处理</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_demo">2. demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   Base()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Base()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Base test()</span><br><span class="line">&#123;</span><br><span class="line">    Base a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在centos中用g++编译后输出的结果为：</p><center><img src="/pics/NRVO.png" alt=""></center><p>其实结果应该有两个 <code>构造函数</code> 与 <code>析构函数</code> 的输出，因为在test函数中，有一个局部变量的生成，还有一个返回值，应该生成一个对象，然后返回，但是在结果中， 我们只看到了一对，所以是采用了NRVO优化的。在《深度探索C++对象模型》这本书中说，需要是 <code>copy constructor（拷贝构造函数）</code> 才说激活NRVO，但是在这个程序中没有生成 <code>copy constructor</code> 却也行，所以表示怀疑。</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Optimize </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数副作用</title>
      <link href="/Coding/Coding/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8/"/>
      <url>/Coding/Coding/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="0-_函数的副作用">0. 函数的副作用</h2><p>指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p><h2 id="1-_概念">1. 概念</h2><ul><li><p>纯函数 ( Pure Function )<br>输入输出数据流全是显式（Explicit）的。 显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道就是 <strong>参数</strong> 和 <strong>返回值</strong> ，函数从函数外部接受的所有输入信息都通过参数传递到该函数内部。函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p></li><li><p>非纯函数 ( Impure Function )<br>与之相反, 隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如读取/修改全局变量</p></li><li><p>引用透明 ( Referential Transparent )<br>引用透明的概念与函数的副作用相关，且受其影响。 如果程序中两个相同值得表达式能在该程序的任何地方互相替换，而不影响程序的动作，那么该程序就具有引用透明性。</p></li></ul><h2 id="2-_例子">2. 例子</h2><p>以下示例说明了引用透明与函数副作用的结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result1 = (fun(a) + b) / (fun(a) -c);</span><br><span class="line">temp = fun(a);</span><br><span class="line">result2 = (temp + b) / (temp -c);</span><br></pre></td></tr></table></figure><p>如果函数没有副作用，那么result1和result2将是等价的。然而如果fun有副作用，比如让b或c加1，那么result1和result2将不相等。因此，副作用违背了引用透明性。</p>]]></content>
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++类型转换时的对象切割</title>
      <link href="/C-C/C:C++/C:C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2/"/>
      <url>/C-C/C:C++/C:C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2/</url>
      <content type="html"><![CDATA[<h3 id="1-_代码">1. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A :: Func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Serialize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A :: Serizalize"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B :: Serizalize"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line">B * pB = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"#1 : "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">b.Func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"#2 : "</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">((A*)(&amp;b))-&gt;Func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"#3 : "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pB-&gt;Func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"#4 : "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">((A)b).Func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b的地址："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b转换后的地址为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;((A)b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：  </p><center><img src="/pics/C++对象切割.jpg" alt=""></center><h3 id="2-_分析">2. 分析</h3><p>我们知道将指针的向上或者向下转换，是可以的。但是针对一个对象的转换就需要注意了。对象的转换时，如果由派生类向基类转，则会发生对象的切割，当对象切割后，会导致对象的不完整性。由于((A)b).Func()这个操作是传值而非传址操作，编译器以所谓的拷贝构造函数把A的内容复制一份，所以会调用A的Serialize函数。</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Object-oriented </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++继承关系中的内存申明顺序</title>
      <link href="/C-C/C:C++/C:C++%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%94%B3%E6%98%8E%E9%A1%BA%E5%BA%8F/"/>
      <url>/C-C/C:C++/C:C++%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%94%B3%E6%98%8E%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="1-_例子">1. 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;b.a &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//此时在类b中的基类成员变量在最上面，然后才是子类的成员变量;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;b.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;(b.A::b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>    <center><img src="/pics/C++继承关系中的内存申明顺序.jpg" alt=""></center></p><h3 id="2-_总结">2. 总结</h3><p>基类的变量放在子类的变量的上面</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的类型转换</title>
      <link href="/C-C/C:C++/C:C++%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/C-C/C:C++/C:C++%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h3 id="一-_static_cast">一. static_cast</h3><p>static_cast适合于静态的强制类型转换，相当于C中的强制类型转换，即可以用于对象实体，也可以用于指针，但是不能替代C中的强制类型转换。</p><ol><li><p>代码</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">void</span> * p =(<span class="keyword">void</span> *)&amp;i;</span><br><span class="line"><span class="keyword">int</span>  z = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>C语言中就可以实现</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">void</span> * p =(<span class="keyword">void</span> *)&amp;i;</span><br><span class="line">   <span class="keyword">int</span> j = (<span class="keyword">int</span>)(p);</span><br></pre></td></tr></table></figure></li></ol><h3 id="二-_dynamic_cast">二. dynamic_cast</h3><p>多于动态类型转换，即多用于指针，而且这些指针都是一些类指针，并且有着继承或者其它的关系，因为它采用了一种动态类型识别技术，所以它多于用基类与派生类的相互转换。有三种转换， <code>子类转父类（向上转）</code>, <code>父类转子类（向下转）</code>, <code>横向转型</code></p><ol><li>类图：<br> <center><img src="/pics/C++Type-Transform.jpg" alt=""></center><br> 如：Base1与Base2是一种兄弟关系。</li><li><p>代码  </p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Base2 *pBase2 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base1 *pBase1 = <span class="keyword">dynamic_cast</span>&lt;Base1&gt;(pBase2);<span class="comment">//这就是横向转换</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="三-_const_cast">三. const_cast</h3><p>去掉其const特性<br>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br></pre></td></tr></table></figure><h3 id="四-_reinterpret_cast">四. reinterpret_cast</h3><p>转换类型只能是指针，引用，算术类型，函数指针，成员指针  </p><p>代码:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncPtr)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//FuncPtr ptr = &amp;func;编译出错</span></span><br><span class="line">FuncPtr ptr = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;func);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>typeid的使用注意项</title>
      <link href="/C-C/C:C++/typeid%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E9%A1%B9/"/>
      <url>/C-C/C:C++/typeid%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h3 id="1-_typeid">1. typeid</h3><ol><li>typeid是一个运算符，不是函数</li><li>typeid是依赖于 <code>RTTI</code>, <code>Runtime type information</code>(运行期型态消息), 而 <code>RTTI</code> 又依赖于 <code>VFT</code>, <code>Virtual Function Table</code>, 简称虚表, 因为RTTI存放在VFT中</li></ol><h3 id="2-_demo">2. demo</h3><p>typeid是根虚表进行判断的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base&amp; b = d;</span><br><span class="line">cout &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为: <code>class Base</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~Base()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base&amp; b = d;</span><br><span class="line">cout &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为: <code>class Derived</code></p><h3 id="3-_注">3. 注</h3><p>如果使用typeid时，传入的参数是指针的话，其结果将会有所不同，所以使用时最好解引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Derived d;</span><br><span class="line">cout &lt;&lt; typeid(&amp;d).name() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为： <code>class Derived *</code></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++小知识点</title>
      <link href="/C-C/C:C++/C:C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/C-C/C:C++/C:C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="1-_#include_尖括号与双引号的区别">1. #include 尖括号与双引号的区别</h3><ul><li>尖括号<br>在指定的目录去查找文件。指定的目录包括VS或者VC的include目录。</li><li>双引号<br>首先在你的工程中去找是否存在这样一个文件，然后再去VS或者VC的include目录下去查找。</li></ul><h3 id="2-_各种类型的范围">2. 各种类型的范围</h3><center><img src="/pics/C++类型范围.jpg" alt=""></center><ol><li>[]，表示可以省略。</li><li><code>char 、 signed char、 unsigned char</code>是不同的类型。</li><li>整型前缀 h 表示 <code>short</code>，l 表示 <code>long</code>。</li><li>输入输出 <code>short/unsigned short</code>时，不建议直接使用int的格式符 <code>%d</code> / <code>%u</code> 等，要加前缀h。</li><li>注意 <code>long int</code> 与 <code>long long int</code> 的位数上的区别，一个是32位，而一个是64位。</li></ol><h3 id="3-_重载、覆盖、隐藏">3. 重载、覆盖、隐藏</h3><ul><li>重载：<ol><li>相同的范围（在同一个类中）；</li><li>函数名字相同；</li><li>参数不同；</li><li>virtual 关键字可有可无。</li></ol></li><li>覆盖:<ol><li>不同的范围（分别位于派生类与基类）；</li><li>函数名字相同；</li><li>参数相同；</li><li>基类函数必须有virtual 关键字。</li></ol></li><li>隐藏：<ol><li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</li><li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</li></ol></li></ul><p>demo:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *pDerived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">110</span>;</span><br><span class="line">    <span class="comment">/**&lt; 因为此处隐藏了基类的函数，所以出错 */</span></span><br><span class="line">    pDerived-&gt;Print(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-_运算符">4. 运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.   ()    []    .    -&gt;</span><br><span class="line">2.   !   ~    -（负号）   ++   --    &amp;（取变量地址）  *   （type）(强制类型)    sizeof </span><br><span class="line">3.   *  /   %</span><br><span class="line">4.   +    -</span><br><span class="line">5.   &gt;&gt;    &lt;&lt;</span><br><span class="line">6.   &gt;   &gt;=    &lt;    &lt;=</span><br><span class="line">7. ==   !=</span><br><span class="line">8 &amp;</span><br><span class="line">9 ^</span><br><span class="line">10 |</span><br><span class="line">11 &amp;&amp;</span><br><span class="line">12 ||</span><br><span class="line">13 ?:</span><br><span class="line">14 =   +=   -=   *=   /=    %=   |=   ^=    &amp;=    &gt;&gt;=    &lt;&lt;=</span><br><span class="line">15 ，</span><br></pre></td></tr></table></figure><h3 id="5-_头文件的重复包含的问题">5. 头文件的重复包含的问题</h3><ul><li>方法一：<br><code>#program once</code></li><li><p>方法二：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __XX_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XX_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-_一个类的四个默认函数">6. 一个类的四个默认函数</h3><ol><li>构造函数</li><li>析构函数</li><li>复制构造函数(返回与传值都要使用引用)</li><li>operator=操作</li></ol><h3 id="7-_常量数值的后缀表示">7. 常量数值的后缀表示</h3><p>分为整数常量，浮点数常量</p><ul><li><p>整数常量<br>默认是以 signed int 类型存储的。(在定义一个常量时需要注意该常量是否会超过个数值的最大值)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前缀:</span><br><span class="line"><span class="number">0</span>前缀表示是  <span class="number">8</span> 进制</span><br><span class="line"><span class="number">0</span>x表示是    <span class="number">16</span> 进制</span><br><span class="line"></span><br><span class="line">后缀:</span><br><span class="line">u/U :      <span class="keyword">unsigned</span></span><br><span class="line">l/L :　　  <span class="keyword">long</span></span><br><span class="line">u/U 与 l/L组合： ul, uL, Ul, UL</span><br></pre></td></tr></table></figure></li><li><p>浮点数常量<br>默认是以 double 类型存储的, 浮点数有两种表示方式： 科学计数法, 小数点形式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f/F : float</span><br><span class="line">l/L : double</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-_C_struct_与_C++_struct区别">8. C struct 与 C++ struct区别</h3><ol><li>C语言中的struct仅仅表示的是一个数据的集合，在里面，不能有函数。</li><li><p>C++中的struct中可以有函数，类似于C++中的类，但是与C++中的类有区别。<br>在纯C语言中，不能存在以下的输入：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">void PrintInfo()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Info testing....&quot;);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>C++struct中的默认为 <code>public</code>，而在类里面默认为 <code>private</code></p></li></ol><h3 id="9-_为什么C不支持重载，而C++支持重载？">9. 为什么C不支持重载，而C++支持重载？</h3><p>在编译过程中需要将 <code>obj</code> 文件进行 <code>link</code>，<code>link</code> 负责将每一个 <code>obj</code> 中的符号表中的东西转换为一个地址，这个地址就是最后编译完成后的 <code>exe</code> 文件的函数对应这个函数的入口地址。</p><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Test();</span><br><span class="line"></span><br><span class="line">1. 按C语言方式的命名方式(cdecl)：Test </span><br><span class="line">2. 按C++方式的命名（_stdcall） ：?Test@@YAHXZ</span><br><span class="line">1. ? 和 @@YAH 是用来表示调用协议的, 其中的H为返回值是int;</span><br><span class="line">2. X 表示没有参数;</span><br><span class="line">3. Z 是函数名称结束修饰</span><br></pre></td></tr></table></figure><p>通过看在编译器转换成的函数名字就可以明白，为什么C++支持重载，因为C++是将参数加入进去的，而C则没有，所以不支持重载。</p><h3 id="10-_class与Typename的区别">10. class与Typename的区别</h3><ul><li>相同点<br>在模板定义时的 <code>class</code> 和 <code>typename</code> 是没有区别的</li><li><p>不同点<br><code>typename</code> 可以表示一个嵌套依赖类型名 <code>nested dependent type name</code>，但是在基类列表和成员初始化列表时，可以不用 <code>typename</code>，代码：　</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Base&gt;               // 此处可以用typename替换</span><br><span class="line">class A : public Base::B           // 基类列表</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> </span><br><span class="line">typedef typename Base::B info_type;</span><br><span class="line"> </span><br><span class="line">A() : Base&lt;T&gt;::B               // 成员初始化列表           </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="keyword">*</span><span class="keyword">*</span>嵌套依赖类型名<span class="keyword">*</span><span class="keyword">*</span>：  针对该代码，我们可以发现，在编译时是无法知道 `Base` 的具体实现的，那么 `Base::B`，我们则无法判断是一个类型的静态成员，还是一个类的成员函数，那么此处就会产生歧义，这种情况下，编译器默认 <span class="keyword">*</span><span class="keyword">*</span>如果解析器在一个 template（模板）中遇到一个 nested dependent name（嵌套依赖名字），它假定那个名字不是一个 type（类型），除非你用其它方式告诉它<span class="keyword">*</span><span class="keyword">*</span>，此时我们就需要`typename`，来声明 `Base::B` 为一个类型，但是在基类列表与成员初始化列表中可以省略。</code></pre><h3 id="11-_不常用的关键字">11. 不常用的关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">asm              : 嵌入汇编代码</span><br><span class="line">auto             : 用于变量声明前，表示该变量具有本地范围，或者块作用域，在一个函数中默认为auto</span><br><span class="line">const_cast       : 将一个常量、常量指针、常量引用，转换为非常量、非常量指针、非常量引用</span><br><span class="line">dynamic_cast     : 关键字dynamic_cast强制将一个类型转化为另外一种类型，并且在执行运行时时检查它保证它的合法性。如果你想在两个互相矛盾的类型之间转化时，cast的返回值将为NULL.</span><br><span class="line">reinterpret_cast : 操作能把一种数据类型改变成另一种.它应当被用在两种不可调和的指针类型之间.</span><br><span class="line">static_cast      : 用来在两个不同类型之间进行强制转换,并且没有运行时间检查.</span><br><span class="line">explicit         : 当构造函数被指定为explicit的时候,将不会自动把构造函数作为转换构造函数,这仅仅用在当一个初始化语句参数与这个构造函数的形参匹配的情况.</span><br><span class="line">extern           ： extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见</span><br><span class="line">friend           ： 声明友元</span><br><span class="line">inline           ： 内联</span><br><span class="line">mutable          ： 可在const函数中进行修改操作</span><br><span class="line">perator          ： 用于重载操作符</span><br><span class="line">register         ： 声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中</span><br></pre></td></tr></table></figure><h3 id="12-_const用法">12. const用法</h3><p>用const修饰的变量或者函数，表明其不可更改。</p><ol><li><p>两个容易混淆的const指针写法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a; <span class="comment">// 此处表明，a指针的不可修改，但是其内容可以修改</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a; <span class="comment">// 此处表明，a指针可以修改，但是其内容不可以修改</span></span><br></pre></td></tr></table></figure></li><li><p>在使用typedef时容易写错的const语法:</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * pStr;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">4</span>] = <span class="string">"bbc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="built_in">string</span>;  <span class="comment">//1式</span></span><br><span class="line"><span class="keyword">const</span> pStr p2 = <span class="built_in">string</span>;   <span class="comment">//2式</span></span><br><span class="line">p1++;</span><br><span class="line">p2++;</span><br></pre></td></tr></table></figure><p> 分析：<br> 此时的 <code>p2++</code> 会报错，因为 <code>typedef</code>，是将整个作为一个类型，而不是类似于 <code>#define</code>，仅仅是一个文字的替换，所以在 <code>const pStr p2 = string;</code>这句话，表明的是其指针不可修改，所以报错。</p></li></ol><h3 id="13-_explicit关键字">13. explicit关键字</h3><p>用来修饰构造函数，表明该构造函数是显示的，既然有 <code>显式</code> 那么什么是隐式的呢？如果C++的构造函数只有一个参数，那么在编译时就会有一个缺省的转换操作：将该构造函数对应的类型转成该对象，然后再赋值，</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A b = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       相当于经过了下面的转换</span></span><br><span class="line"><span class="comment">       A b(5);</span></span><br><span class="line"><span class="comment">       A c = b;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>隐式的转换：即编译器先将一个对象生成，然后再将这个临时的对象赋给其它对象</li><li>而explicit则是将这个转换变成显示，或者说不能通过隐形转换。</li><li>用法：在构造函数前面加上explicit关键字。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;; <span class="comment">// 这样就不能通过A a = 5;这样来赋值了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="14-_mutalbe关键字">14. mutalbe关键字</h3><p>mutable也是为了突破const的限制而设置的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　ClxTest();</span><br><span class="line">　　~ClxTest();</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">　　<span class="function"><span class="keyword">int</span> <span class="title">GetOutputTimes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">　<span class="keyword">private</span>:</span><br><span class="line">　　<span class="keyword">mutable</span> <span class="keyword">int</span> m_iTimes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ClxTest::ClxTest()</span><br><span class="line">&#123;</span><br><span class="line">　m_iTimes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClxTest::~ClxTest()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ClxTest::Output() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">　<span class="built_in">cout</span> &lt;&lt; <span class="string">"Output for test!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">　m_iTimes++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ClxTest::GetOutputTimes() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">　<span class="keyword">return</span> m_iTimes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputTest</span><span class="params">(<span class="keyword">const</span> ClxTest&amp; lx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="built_in">cout</span> &lt;&lt; lx.GetOutputTimes() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">　lx.Output();</span><br><span class="line">　<span class="built_in">cout</span> &lt;&lt; lx.GetOutputTimes() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数器m_iTimes被mutable修饰，那么它就可以突破const的限制，在被const修饰的函数里面也能被修改。</p><h3 id="15-_volatile关键字">15. volatile关键字</h3><p>编译器会优化一些数据。而volatile则是禁止这种优化。</p><ul><li><p>demo:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> k = i;</span><br></pre></td></tr></table></figure><ol><li><code>volatile</code> 告诉编译器i是随时可能发生变化的，每次使用它的时候必须从 <code>i</code> 的地址中读取，因而编译器生成的可执行码每次都会重新从 i 的地址读取数据。</li><li>而编译器的优化做法是：由于编译器发现两次从i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在k中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问，不会出错。</li></ol></li><li>使用场景<br> 一个定义为 <code>volatile</code> 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：<ol><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li><li>多线程应用中被几个任务共享的变量</li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++的参数压栈顺序</title>
      <link href="/C-C/C:C++/C:C++%E7%9A%84%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/"/>
      <url>/C-C/C:C++/C:C++%E7%9A%84%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="0-_函数调用的过程">0. 函数调用的过程</h3><ol><li>调用者把参数入栈</li><li>调动函数</li><li>函数去读取栈中数据，作为参数，并进行计算</li><li>函数结束后，调用者、或者函数本身修改栈，使栈恢复成函数调用之前（因为很多函数共用一个堆栈）</li></ol><h3 id="1-_入栈方式">1. 入栈方式</h3><ul><li><p><code>__stdcall</code>  </p><ul><li>又称为 <code>PASCAL</code> 调用约定，Microsoft C++系列的C/C++编译器中，默认用 <code>PASCAL</code> 宏来声明这个调用约定，类似的宏还有 <code>WINAPI</code> 和 <code>CALLBACK</code></li><li>函数本身清理堆栈，从右到左压栈</li><li>函数名自动加前导的下划线，后面紧跟一个@符号 ，其后紧跟着参数的尺寸(所有参数的总共大小)，<code>eg: int __stdcall function(int a,int b)  ==&gt;  _function@8</code></li></ul></li><li><p><code>__cdecl</code>  </p><ul><li>调用者清理堆栈</li><li>从右到左压栈</li><li>是C/C++默认的调动方式</li><li>函数名仅仅在前面加下划线， eg:  <code>int __cedecl function(int a, int b)  ==&gt;  _function</code></li></ul></li><li><code>__fastcall</code><ul><li>函数本身清理堆栈</li><li>第一和第二个DWORD参数通过ECX和EDX传递(从左到右)，其它的参数从右到左压栈</li><li>函数名修改规则如 <code>__stdcall</code></li><li>函数名的规则是在函数名前面与后面都加上“@”,然后再在后面加上所有的参数的字节数， <code>eg:  @function@8</code></li></ul></li><li><code>__thiscall</code><ul><li><code>thiscall</code>，不是关键字</li><li>它是C++类成员函数缺省的调用约定</li><li>参数从右向左入栈</li><li>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。</li><li>对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈</li></ul></li><li><code>naked</code><ul><li>编译器不会给这种函数增加初始化和清理代码</li><li>不能用return返回返回值，只能用插入汇编返回结果</li><li>一般用于实模式驱动程序设计</li></ul></li></ul><h3 id="2-_函数调用约定导致的常见问题">2. 函数调用约定导致的常见问题</h3><ol><li>函数原型声明和函数体定义不一致</li><li><p>DLL导入函数时声明了不同的函数约定<br>如：<br>在dll中声明了一种如下的函数：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__declspec(dllexport) int func(int a, int b);     //注意，这里没有stdcall，使用的是cdecl</span><br><span class="line">typedef int (*WINAPI DLLFUNC) func(int a, int b);  // WINAPI指的是stdcall调用约定</span><br><span class="line">hLib = LoadLibrary(...);</span><br><span class="line">DLLFUNC func = (DLLFUNC) GetProcAddress(...)　　　// 这里修改了调用约定</span><br><span class="line">result = func(1,2);//导致错误</span><br></pre></td></tr></table></figure><p>上述代码将会导致堆栈被破坏。</p></li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++模板中的Policy和Trait</title>
      <link href="/C-C/C:C++/C:C++%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84Policy%E5%92%8CTrait/"/>
      <url>/C-C/C:C++/C:C++%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84Policy%E5%92%8CTrait/</url>
      <content type="html"><![CDATA[<h3 id="1-_Policy">1. Policy</h3><p>Policy，根据参数不同，而调用不同的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//这一部分是Trait</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AccumulateTrait;</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class AccumulateTrait&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef int AccT;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class AccumulateTrait&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef int AccT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这一部分是Policy</span><br><span class="line">class SumPolicy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">static void Accumulate(T1&amp; sum, T2 const&amp; data)</span><br><span class="line">&#123;</span><br><span class="line">    sum += data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class MultiPolicy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">static void Accumulate(T1&amp; sum,  T2 const&amp; data )</span><br><span class="line">&#123;</span><br><span class="line">    sum *= data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//这是个计算类</span><br><span class="line">template &lt;typename T, typename Policy = SumPolicy, typename Traits = AccumulateTrait&lt;T&gt;&gt;</span><br><span class="line">class Accum</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef typename AccumulateTrait&lt;T&gt;::AccT AccT;</span><br><span class="line">static AccT Accumulate(T const* begin, T const* end)</span><br><span class="line">&#123;</span><br><span class="line">    AccT total = AccT();</span><br><span class="line">    while(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        Policy::Accumulate(total, *begin);</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int test[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">char chartest[] = &quot;templates&quot;;</span><br><span class="line">int r = Accum&lt;int&gt;::Accumulate(test,test + 5);</span><br><span class="line">int r2 = Accum&lt;char&gt;::Accumulate(chartest, chartest + sizeof(chartest));</span><br><span class="line">printf(&quot;r is %d\n&quot;,r);</span><br><span class="line">printf(&quot;r2 is %d\n&quot;,r2);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_Trait">2. Trait</h3><p>指的是其返回值根据传入参数的类型而定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class AccumulateTrait;</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class AccumulateTrait&lt;char&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef int AccT;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class AccumulateTrait&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef int AccT;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">typename AccumulateTrait&lt;T&gt;::AccT Accumulate(T const* begin , T const* end)</span><br><span class="line">&#123;</span><br><span class="line">typedef typename AccumulateTrait&lt;T&gt;::AccT AccT;</span><br><span class="line">AccT sum = AccT();</span><br><span class="line">while(begin != end)</span><br><span class="line">&#123;</span><br><span class="line">    sum += (*begin);</span><br><span class="line">    begin++;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int test[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">char chartest[] = &quot;templates&quot;;</span><br><span class="line">int r = Accumulate(test,test + 5);</span><br><span class="line">int r2 = Accumulate(chartest, chartest + sizeof(chartest));</span><br><span class="line">printf(&quot;r is %d\n&quot;,r);</span><br><span class="line">printf(&quot;r2 is %d\n&quot;,r2);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意typename的使用，还有它与class的区别，typename大多数都与class相同，在模版方面，但是有一点，那就是如果是类中的类型的话，就必须使用typename</p><h3 id="3-_Policy与Trait的总结">3. Policy与Trait的总结</h3><ol><li>以下为Trait的特征和适用场景:<ol><li>Trait表述了模板参数的一些自然的额外 <strong>属性</strong>。</li><li>Trait可以是固定Trait，也就是说， 不需要通过模板参数进行传递。</li><li>Trait参数通常都具有很自然的缺省值，该缺省值很少会被改写，或者说是根本就不能被改写。</li><li>Trait参数可以紧密依赖于一个或多个主参数。</li><li>Trait通常都是用Trait模板来实现的。</li></ol></li><li>下面是Policy的特征和应用场景：<ol><li>Policy表述了泛型函数和泛型类的一些可配置 <strong>行为</strong>。</li><li>如果不以模板参数的形式进行传递的话，Policy Class几乎不起作用。</li><li>Policy参数并不需要具有缺省值，而且通常都是显示指定这个参数，尽管许多泛型组件都配置了使用频率很高的缺省Policy。</li><li>Policy参数和属于同一个模板的其他参数通常都是正交的。</li><li>Policy class一般都包含了成员函数。</li><li>Policy即可以用普通类来实现，也可以用模板类来实现</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ｃ++字符串常量</title>
      <link href="/C-C/C:C++/C:C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/"/>
      <url>/C-C/C:C++/C:C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="1-_字符串常量">1. 字符串常量</h3><ol><li>字符串常量的位置在静态数据区，是一个未命名的静态数据。</li><li>字符串常量的值相同，则所有的常量共用一个地址，如：</li></ol><h3 id="2-_例子">2. 例子</h3><ol><li><p>代码</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p2 = Test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Ok"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果为： </p></li></ol><center><img src="/pics/C++Constant.jpg" alt=""></center>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++数组负数下标</title>
      <link href="/C-C/C:C++/C:C++%E6%95%B0%E7%BB%84%E8%B4%9F%E6%95%B0%E4%B8%8B%E6%A0%87/"/>
      <url>/C-C/C:C++/C:C++%E6%95%B0%E7%BB%84%E8%B4%9F%E6%95%B0%E4%B8%8B%E6%A0%87/</url>
      <content type="html"><![CDATA[<ol><li><p>代码</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p = &amp;a[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">-4</span>; i &lt;= <span class="number">0</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果为：</p></li></ol><center><img src="/pics/C++数组负数下标.jpg" alt=""></center>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++内存对齐</title>
      <link href="/C-C/C:C++/C:C++%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/C-C/C:C++/C:C++%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      <content type="html"><![CDATA[<h3 id="1-_原因">1. 原因</h3><p>如果读取未对齐的数据时，处理器需要进行两次访存，而对齐的数据只需要进行一次，有利于提高效率。</p><h3 id="2-_修改内存对齐的方式">2. 修改内存对齐的方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#program pack (align_size)   <span class="comment">// align_size，即为新的对齐的大小</span></span></span><br></pre></td></tr></table></figure><h3 id="3-_规则">3. 规则</h3><ol><li>变量按声明的顺序在内存中排列。</li><li>对齐的大小，是根据是否是 <code>align_size</code>（系统默认为4）的整数倍 ，如果你的结构体中有 <code>double</code>，则可能最大的可能为8，如果你的struct中包含有其它的结构是，我们只需要看它的内置类型的最大宽度。</li></ol><h3 id="4-_测试">4. 测试</h3><ol><li><p>代码</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在结构体A中，其大小为12，但是其对齐的方式，4字节，在结构体B中，对齐的字节是8字节，所以选择8字节作为基准</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;       <span class="comment">//此处为8</span></span><br><span class="line">    <span class="keyword">double</span> a;    <span class="comment">//此处为8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">c</span>;</span>  <span class="comment">//此处对齐8，所以为16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A\t%d\n"</span>,<span class="keyword">sizeof</span>(struct A));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"B\t%d\n"</span>,<span class="keyword">sizeof</span>(struct B));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果为：  </p> <center><img src="/pics/C++内存对齐.jpg" alt=""></center></li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memorty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++元计算初探</title>
      <link href="/C-C/C:C++/C:C++%E5%85%83%E8%AE%A1%E7%AE%97%E5%88%9D%E6%8E%A2/"/>
      <url>/C-C/C:C++/C:C++%E5%85%83%E8%AE%A1%E7%AE%97%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h3 id="1-_例子">1. 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 模板</span><br><span class="line">template &lt;int N&gt;</span><br><span class="line">class Fib</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum &#123;Result = Fib&lt;N-1&gt;::Result+Fib&lt;N-2&gt;::Result&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//模板的特化</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class Fib&lt;0&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum &#123;Result = 0&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//模板的特化</span><br><span class="line">template &lt;&gt;</span><br><span class="line">class Fib&lt;1&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum &#123;Result = 1&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int res = Fib&lt;10&gt;::Result;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_总结">2. 总结</h3><ol><li>元计算就是利用模板的特化，这样就导致将计算的时间花在编译上，从而程序真正计算时减少时间，从而提高效率。</li><li>一定得注意模板的特化的形式</li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++初始化列表</title>
      <link href="/C-C/C:C++/C:C++%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/C-C/C:C++/C:C++%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-_构造函数初始化列表">1. 构造函数初始化列表</h3><p>以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。</p><h3 id="2-_什么时候使用初始化成员列表：">2. 什么时候使用初始化成员列表：</h3><ol><li>const初始化</li><li>引用初始化</li></ol><h3 id="3-_针对一个成员变量是一个类时，使用初始化成员列表进行赋值与在构造函数赋值的区别">3. 针对一个成员变量是一个类时，使用初始化成员列表进行赋值与在构造函数赋值的区别</h3><p>类的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成，所以使用初始化列表的效率高一些，但是如果是内置类型时，则性能没有多大变化</p><h3 id="4-_注意：">4. 注意：</h3><p>初始化成员列表的初始化顺序是与变量的声明顺序相关，而与其在初始化成员列表中的位置无关。</p><h3 id="2-_例子">2. 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span> &#123;</span></span><br><span class="line">    CMyClass(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">CMyClass::CMyClass(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_y(y), m_x(m_y)<span class="comment">//m_x是一个不可预测的值</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:<br>你可能以为上面的代码将会首先做 <code>m_y=y</code>，然后做 <code>m_x=m_y</code>，最后它们有相同的值。但是编译器先用 <code>m_y</code> 的值初始化 <code>m_x</code>，然后是用 <code>y</code> 的值初始化 <code>m_y</code>，因为它们是按这样的顺序声明的，于是可以这样解释，如果一个变量先声明，则在初始列表初始时，就先初始化。结果是m_x将有一个不可预测的值。有两种方法避免它</p><ol><li>总是按照你希望它们被初始化的顺序声明成员</li><li>如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。</li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++前置与后置操作符重载</title>
      <link href="/C-C/C:C++/C:C++%E5%89%8D%E7%BD%AE%E4%B8%8E%E5%90%8E%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/C-C/C:C++/C:C++%E5%89%8D%E7%BD%AE%E4%B8%8E%E5%90%8E%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h3 id="1-_例子">1. 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Base() : m_Data(0)&#123;&#125;</span><br><span class="line">//前缀，无参数</span><br><span class="line">Base&amp; operator++()</span><br><span class="line">&#123;</span><br><span class="line">    m_Data++;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line">//后缀，有一个参数</span><br><span class="line">Base operator++(int data)</span><br><span class="line">&#123;</span><br><span class="line">    Base temp = *this;</span><br><span class="line">    //调用前置++</span><br><span class="line">    ++(*this);</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">void setData(int a)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;m_Data = a;</span><br><span class="line">&#125;</span><br><span class="line">int getData()</span><br><span class="line">&#123;</span><br><span class="line">    return m_Data;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_Data;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Base a;</span><br><span class="line">a.setData(3);</span><br><span class="line">Base temp = a++;</span><br><span class="line">cout &lt;&lt; &quot;Pre: &quot; &lt;&lt; temp.getData() &lt;&lt; &quot; Now: &quot; &lt;&lt; a.getData() &lt;&lt; endl;</span><br><span class="line">Base temp2 = ++a;</span><br><span class="line">cout &lt;&lt; &quot;Pre: &quot; &lt;&lt; temp2.getData() &lt;&lt; &quot; Now: &quot; &lt;&lt; a.getData() &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_总结：">2. 总结：</h3><ul><li>前缀操作，无参数，且自 <code>+</code> 后，返回自身，返回值为引用</li><li>后缀操作，有一个参数，直接调用前缀的方法，然后返回一个临时对象，所以返回值，不应该是引用，而是一个普通对象</li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布--04</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--04/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--04/</url>
      <content type="html"><![CDATA[<h3 id="1-_菱形继承（无虚继承）">1. 菱形继承（无虚继承）</h3><ol><li><p>类图 </p><center><img src="/pics/C++内存分布-04-01.jpg" alt=""></center></li><li><p>类的实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        int ib;</span><br><span class="line">        char cb;</span><br><span class="line">public:</span><br><span class="line">    B():ib(0),cb(&apos;B&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf() &#123; cout &lt;&lt; &quot;B::Bf()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B1 :  public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ib1;</span><br><span class="line">    char cb1;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B1():ib1(11),cb1(&apos;1&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B1::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f1() &#123; cout &lt;&lt; &quot;B1::f1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf1() &#123; cout &lt;&lt; &quot;B1::Bf1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B2:  public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ib2;</span><br><span class="line">    char cb2;</span><br><span class="line">public:</span><br><span class="line">    B2():ib2(12),cb2(&apos;2&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B2::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f2() &#123; cout &lt;&lt; &quot;B2::f2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf2() &#123; cout &lt;&lt; &quot;B2::Bf2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public B1, public B2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int id;</span><br><span class="line">    char cd;</span><br><span class="line">public:</span><br><span class="line">    D():id(100),cd(&apos;D&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;D::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f1() &#123; cout &lt;&lt; &quot;D::f1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f2() &#123; cout &lt;&lt; &quot;D::f2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Df() &#123; cout &lt;&lt; &quot;D::Df()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><center><img src="/pics/C++内存分布-04-02.jpg" alt=""></center></li><li><p>内存分布</p><center><img src="/pics/C++内存分布-04-03.jpg" alt=""></center></li></ol><h3 id="2-_总结">2. 总结</h3><p>在B1与B2中都保留了一份B，如果直接在D类中调用在B类的方法或者变量，将导致二义性， 不知道是B1，还是B2中的方法与变量。<br>因为存在重复数据，所以有了虚继承的概念</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布--02</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--02/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--02/</url>
      <content type="html"><![CDATA[<h3 id="1-_一般虚函数_+_覆盖">1. 一般虚函数 + 覆盖</h3><ol><li><p>类的关系图（f()函数是一个虚函数）</p> <center><img src="/pics/C++内存分布-02-01.jpg" alt=""></center></li><li><p>内存分布</p><center><img src="/pics/C++内存分布-02-02.jpg" alt=""></center></li><li><p>总结：</p><ul><li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li><li>没有被覆盖的函数依旧</li></ul></li></ol><h3 id="2-_一般继承+成员变量">2. 一般继承+成员变量</h3><ol><li><p>类图</p> <center><img src="/pics/C++内存分布-02-03.jpg" alt=""></center></li><li><p>类的实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    public:</span><br><span class="line">        int iparent;</span><br><span class="line">        Parent ():iparent (10) &#123;&#125;</span><br><span class="line">        virtual void f() &#123; cout &lt;&lt; &quot; Parent::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void g() &#123; cout &lt;&lt; &quot; Parent::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">            virtual void h() &#123; cout &lt;&lt; &quot; Parent::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    class Child : public Parent &#123;</span><br><span class="line">    public:</span><br><span class="line">            int ichild;</span><br><span class="line">        Child():ichild(100) &#123;&#125;</span><br><span class="line">        virtual void f() &#123; cout &lt;&lt; &quot;Child::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void g_child() &#123; cout &lt;&lt; &quot;Child::g_child()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void h_child() &#123; cout &lt;&lt; &quot;Child::h_child()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    class GrandChild : public Child&#123;</span><br><span class="line">    public:</span><br><span class="line">        int igrandchild;</span><br><span class="line">        GrandChild():igrandchild(1000) &#123;&#125;</span><br><span class="line">        virtual void f() &#123; cout &lt;&lt; &quot;GrandChild::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void g_child() &#123; cout &lt;&lt; &quot;GrandChild::g_child()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void h_grandchild() &#123; cout &lt;&lt; &quot;GrandChild::h_grandchild()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Fun)(void);</span><br><span class="line">GrandChild gc;</span><br><span class="line">int** pVtab = (int**)&amp;gc;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;[0] GrandChild::_vptr-&gt;&quot; &lt;&lt; endl;</span><br><span class="line">for (int i=0; (Fun)pVtab[0][i]!=NULL; i++)&#123;</span><br><span class="line">    pFun = (Fun)pVtab[0][i];</span><br><span class="line">    cout &lt;&lt; &quot;    [&quot;&lt;&lt;i&lt;&lt;&quot;] &quot;;</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;[1] Parent.iparent = &quot; &lt;&lt; (int)pVtab[1] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;[2] Child.ichild = &quot; &lt;&lt; (int)pVtab[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;[3] GrandChild.igrandchild = &quot; &lt;&lt; (int)pVtab[3] &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><center><img src="/pics/C++内存分布-02-04.jpg" alt=""></center></li><li><p>内存分布</p><center><img src="/pics/C++内存分布-02-05.jpg" alt=""></center></li></ol><h3 id="3-_总结">3. 总结</h3><ul><li>虚函数表在最前面的位置,即pVtab[0]就是子类的虚表</li><li>成员变量根据其继承和声明顺序依次放在该虚表的后面</li><li>在单一的继承中，被overwrite的虚函数在虚函数表中得到了更新</li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布--06</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--06/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--06/</url>
      <content type="html"><![CDATA[<h3 id="1-_基础">1. 基础</h3><ol><li>虚表是多态的基础</li><li>虚表放在类的内存地址的开始的位置,即[0]</li></ol><h3 id="2-_虚表在继承体系中的体现">2. 虚表在继承体系中的体现</h3><p>这里讨论的虚表是指最下层的子类，在子类中包含了基类的信息</p><ol><li>单一继承<ol><li>在子类中，包含了基类的信息，当然也包含了基类的虚表，子类的虚表与基类的虚表合成一个表，放在基类的虚表中，在内存上，仍然在子类中</li><li>在虚函数下面将是类的成员变量的地方，其分布是先是基类的成员变量，然后再是子类的成员变量，在同一个类中，是按声明的顺序排列的</li><li>子类的函数如果覆盖基类的函数，那么因为子类的虚表放在基类的虚表中，但是这个位置还是在子类的内存中，只是在子类的内存中包含了基类，而子类的虚放在，所以会用子类的函数地址覆盖基类的函数地址。这样就能体现出多态</li></ol></li><li>多继承<ol><li>基类按声明的顺序排序在子类中</li><li>如果子类覆盖每一个基中的不同的函数，则在该子类中包含的每一个基类的虚表中，都会将相就的函数进行替换</li><li>如果是多继承，即基类有多个，则有多个虚表，如果是多重继承，即父类只有一个，但父类，又有父类，这样的话，在最下层的子类中只会有一个虚表</li></ol></li><li>菱形继承<br>这是一种特殊的多继承，在该继承体系中，根据在前面提到的，会在每一个基类的虚表中，包含一个相同的共同基类的数据，所以会造成内存浪费，这是虚继承的前提。</li><li>虚继承<ol><li>会在最终的子类中存在一份实例，而在中间类上仅仅存在是一个指针</li><li>最上层的基类，仅仅保存在最下层的子类中，且在该子类的成员变量之后</li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布-01</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-01/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-01/</url>
      <content type="html"><![CDATA[<h4 id="1-_虚函数">1. 虚函数</h4><p>虚函数（Virtual Function）是通过一张虚函数表 （Virtual Table）来实现的。简称为V-Table</p><ol><li><p>例子</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">        virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125;</span><br><span class="line">        virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Fun)(void);</span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = NULL;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;   //注意这里是指针的的指针</span><br><span class="line">// Invoke the first virtual function</span><br><span class="line">pFun = (Fun)*((int*)*(int*)(&amp;b));</span><br><span class="line">pFun();</span><br></pre></td></tr></table></figure></li><li><p>结果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚函数表地址：0012FED4</span><br><span class="line">虚函数表 — 第一个函数地址：0044F148</span><br><span class="line">Base::f</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-_结论">4. 结论</h4><p>内存分布：  </p><center><img src="/pics/C++内存分布-01.jpg" alt=""></center>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布--05</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--05/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--05/</url>
      <content type="html"><![CDATA[<h3 id="1-_虚继承（菱形继承）">1. 虚继承（菱形继承）</h3><ol><li><p>类图</p><center><img src="/pics/C++内存分布-05-01.jpg" alt=""></center></li><li><p>类图</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ib;</span><br><span class="line">    char cb;</span><br><span class="line">public:</span><br><span class="line">    B():ib(0),cb(&apos;B&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf() &#123; cout &lt;&lt; &quot;B::Bf()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B1 : virtual public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ib1;</span><br><span class="line">    char cb1;</span><br><span class="line">public:</span><br><span class="line">    B1():ib1(11),cb1(&apos;1&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B1::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f1() &#123; cout &lt;&lt; &quot;B1::f1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf1() &#123; cout &lt;&lt; &quot;B1::Bf1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B2: virtual public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ib2;</span><br><span class="line">    char cb2;</span><br><span class="line">public:</span><br><span class="line">    B2():ib2(12),cb2(&apos;2&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;B2::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f2() &#123; cout &lt;&lt; &quot;B2::f2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Bf2() &#123; cout &lt;&lt; &quot;B2::Bf2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public B1, public B2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int id;</span><br><span class="line">    char cd;</span><br><span class="line">public:</span><br><span class="line">    D():id(100),cd(&apos;D&apos;) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;D::f()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f1() &#123; cout &lt;&lt; &quot;D::f1()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void f2() &#123; cout &lt;&lt; &quot;D::f2()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void Df() &#123; cout &lt;&lt; &quot;D::Df()&quot; &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>B1的内存分布</p><center><img src="/pics/C++内存分布-05-02.jpg" alt=""></center></li><li><p>测试结果</p><center><img src="/pics/C++内存分布-05-03.jpg" alt=""></center></li></ol><h3 id="2-_总结">2. 总结</h3><p>共同的基类只有一份实例（类B），该实例仅仅包含在最下面的子类，即D，而不是B1与B2，共同的基类放在D的类的成员变量的后面</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++--内存分布--03</title>
      <link href="/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--03/"/>
      <url>/C-C/C:C++/C:C++--%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83--03/</url>
      <content type="html"><![CDATA[<h3 id="1-_多继承">1. 多继承</h3><ol><li><p>类图</p><center><img src="/pics/C++内存分布-03-01.jpg" alt=""></center></li><li><p>类的实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Base1 &#123;</span><br><span class="line">public:</span><br><span class="line">    int ibase1;</span><br><span class="line">    Base1():ibase1(10) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void g() &#123; cout &lt;&lt; &quot;Base1::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void h() &#123; cout &lt;&lt; &quot;Base1::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 &#123;</span><br><span class="line">public:</span><br><span class="line">    int ibase2;</span><br><span class="line">    Base2():ibase2(20) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;Base2::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void g() &#123; cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void h() &#123; cout &lt;&lt; &quot;Base2::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base3 &#123;</span><br><span class="line">public:</span><br><span class="line">    int ibase3;</span><br><span class="line">    Base3():ibase3(30) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;Base3::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void g() &#123; cout &lt;&lt; &quot;Base3::g()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void h() &#123; cout &lt;&lt; &quot;Base3::h()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base1, public Base2, public Base3 &#123;</span><br><span class="line">public:</span><br><span class="line">    int iderive;</span><br><span class="line">    Derive():iderive(100) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;Derive::f()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void g1() &#123; cout &lt;&lt; &quot;Derive::g1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><center><img src="/pics/C++内存分布-03-02.jpg" alt=""></center></li><li><p>内存分布</p><center><img src="/pics/C++内存分布-03-03.jpg" alt=""></center></li></ol><h3 id="2-_总结">2. 总结</h3><ul><li>每个父类都有自己的虚表</li><li>子类的成员函数被放到了第一个父类的表中</li><li>内存布局中，其父类布局依次按声明顺序排列</li><li>每个父类的虚表中的f()函数都被 <code>overwrite</code> 成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路----Floyd</title>
      <link href="/Algorithm/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF----Floyd/"/>
      <url>/Algorithm/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF----Floyd/</url>
      <content type="html"><![CDATA[<h2 id="1-_Floyd(弗洛伊德)算法：">1. Floyd(弗洛伊德)算法：</h2><ol><li>思想： 假设存在一个点(C)，可以使A-&gt;C-&gt;B的距离之和小于A-&gt;B的距离</li><li><p>步骤：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//针对i-&gt;j距离，假设会存在一个k，使i-&gt;k-&gt;j的距离小于i-j的距离</span><br><span class="line">for(int k = 1; k &lt;= 节点个数; k++)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= 节点个数; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= 节点个数; j++)</span><br><span class="line">&#123;</span><br><span class="line">if(Map[i][k] + Map[k][j] &lt; Map[i][j])</span><br><span class="line">&#123;</span><br><span class="line">Map[i][j] = Map[i][k] + Map[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意点：</p><ol><li>因为Floyd适合于无向图，所以给线一条边赋值时，需要双向赋值，即A-&gt;B的距离为len, 而且B -&gt; A的距离为len</li><li>一个点到本身的距离是为0的，所以初始化时，Map[i][i] = 0</li></ol></li></ol><h2 id="2-_例子">2. 例子</h2><ul><li>题目: <code>http://acm.hdu.edu.cn/showproblem.php?pid=1874</code></li><li>代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define CITY 205</span><br><span class="line">#define MAX 99999999</span><br><span class="line"></span><br><span class="line">int Map[CITY][CITY];</span><br><span class="line"></span><br><span class="line">int Floyd(int nCity, int Start, int End)</span><br><span class="line">&#123;</span><br><span class="line">    for(int k = 0; k &lt; nCity; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; nCity; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; nCity; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(Map[i][k] + Map[k][j] &lt; Map[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    Map[i][j] = Map[i][k] + Map[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Len = Map[Start][End];</span><br><span class="line">    if(Len != MAX) return Len;</span><br><span class="line">    else           return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCity, nRoad;</span><br><span class="line">    int Start, End;</span><br><span class="line">    int s, t, len;</span><br><span class="line"></span><br><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;nCity, &amp;nRoad) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; nCity; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 0; j &lt; nCity; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i == j) Map[i][j] = 0;</span><br><span class="line">                else       Map[i][j] = MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= nRoad; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;len);</span><br><span class="line">            //请注意此处，因为第一次可以输入1 2 4, 第二次也可以输入1 2 5, 当然我们就取小的</span><br><span class="line">            if(len &lt; Map[s][t])</span><br><span class="line">            &#123;</span><br><span class="line">                Map[s][t] = Map[t][s] = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;Start, &amp;End);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; Floyd(nCity, Start, End) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最短路----Dijkstra</title>
      <link href="/Algorithm/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF----Dijkstra/"/>
      <url>/Algorithm/Algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF----Dijkstra/</url>
      <content type="html"><![CDATA[<h2 id="1-_Dijkstra">1. Dijkstra</h2><p>是用来求单源最短路，即已知某一个起点，求到任意一个点的最短路</p><h2 id="2-_Dijkstra算法的假设：">2. Dijkstra算法的假设：</h2><p>如果A–&gt;B–&gt;C–&gt;D，是A–&gt;D的最短路，那么其前一站也是最短的，即A–&gt;C也是最短的</p><h2 id="3-_步骤">3. 步骤</h2><ol><li>在一个数组dis[N]中存储一个点到其它点的最短路距离，初始化时，原点为0，其它点，为相邻的路径</li><li>从dis[N]中找出一个距离最短的点，作为从下一步选择的节点</li><li>更新dis[N]， 再跳转到第二步，直到找不出最短路</li></ol><h2 id="4-_例子">4. 例子</h2><ul><li>题目： <code>http://acm.hdu.edu.cn/showproblem.php?pid=2544</code></li><li>代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define N 110</span><br><span class="line">#define MAX 999999</span><br><span class="line">int  Map[N][N];</span><br><span class="line">int  Dis[N];</span><br><span class="line">bool IsUsed[N];</span><br><span class="line"></span><br><span class="line">int Dijkstra(int nCrossing, int Start, int End)</span><br><span class="line">&#123;</span><br><span class="line">    // 1、初始化dis[N]</span><br><span class="line">    for(int i = 2; i &lt;= nCrossing; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Dis[i] = Map[Start][i];</span><br><span class="line">        IsUsed[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dis[Start] = 0;</span><br><span class="line">    IsUsed[Start] = true;</span><br><span class="line"></span><br><span class="line">    for(int i = 1; i &lt;= nCrossing; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = MAX;</span><br><span class="line">        int Pos = Start;</span><br><span class="line">        //2、找出最短路</span><br><span class="line">        for(int j = 1; j &lt;= nCrossing; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!IsUsed[j] &amp;&amp; Dis[j] &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = Dis[j];</span><br><span class="line">                Pos  = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(temp == MAX) break;</span><br><span class="line"></span><br><span class="line">        IsUsed[Pos] = true;</span><br><span class="line">        //3、更新dis[N]，直到temp==MAX</span><br><span class="line">        for(int j = 1; j &lt;= nCrossing; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!IsUsed[j] &amp;&amp; Dis[j] != MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                int NewLen = Dis[Pos] + Map[Pos][j];</span><br><span class="line">                if(NewLen &lt; Dis[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    Dis[j] = NewLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4、返回最短路</span><br><span class="line">    return Dis[End];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCrossing, nPath;</span><br><span class="line">    int Start, End, Len;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;, &amp;nCrossing, &amp;nPath) &amp;&amp; (nCrossing + nPath))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt;= nCrossing; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= nCrossing; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                Map[i][j] = MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; nPath; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;Start, &amp;End, &amp;Len);</span><br><span class="line">            //此处是为了避免重复输入一路径,如果1 2 3， 1 2 1， 我们取后者</span><br><span class="line">            if(Len &lt; Map[Start][End])</span><br><span class="line">            &#123;</span><br><span class="line">                Map[Start][End] = Map[End][Start] = Len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;,  Dijkstra(nCrossing, 1, nCrossing));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/Algorithm/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/Algorithm/Algorithm/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="1-_概念">1. 概念</h2><ul><li>生成树：<br>n个项点的连通图的生成树有n个项点、（ｎ-１）条边。</li><li>最小生成树<ol><li>必须使用该图中的边来构造最小生成树</li><li>必须使用且仅使用(n-1)条边来连接图中的n个点</li><li>不能产生回路</li></ol></li></ul><h2 id="2-_算法">2. 算法</h2><p>以下的代码是针对一道oj题做的，<code>http://acm.hdu.edu.cn/showproblem.php?pid=1233</code></p><h3 id="2-1-_Kruskal（克鲁斯卡尔算法）">2.1. Kruskal（克鲁斯卡尔算法）</h3><ul><li><p>思路：</p><ol><li>将图中的边按长度进行排序（从小到大）</li><li>将每一个点都认为是一个独立的连通分量（即这个点的父母节点为它本身）</li><li>依次从排序好的边中任意取出一个点，再根据并查集的思想，如果这两个点没有公共的父结点，则将这条边加入到最小生成树中</li></ol></li><li><p>代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_POINT = 105;</span><br><span class="line">const int MAX_EDGE  = 5050;</span><br><span class="line"></span><br><span class="line">int Father[MAX_POINT];</span><br><span class="line"></span><br><span class="line">typedef struct _edget</span><br><span class="line">&#123;</span><br><span class="line">    int Start;</span><br><span class="line">    int End;</span><br><span class="line">    int Len;</span><br><span class="line"></span><br><span class="line">    bool operator&lt;(const struct _edget &amp;temp) const</span><br><span class="line">    &#123;</span><br><span class="line">        return Len &lt; temp.Len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line">Edge graph[MAX_EDGE];</span><br><span class="line"></span><br><span class="line">void InitFather(int nPoint)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 1; i &lt;= nPoint; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindFather(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if ( x == Father[x])</span><br><span class="line">    &#123;</span><br><span class="line">        return Father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Father[x] = FindFather(Father[x]);</span><br><span class="line">        return Father[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Kruskal(int nPoint, int nEdge)</span><br><span class="line">&#123;</span><br><span class="line">    int fA, fB;</span><br><span class="line">    int sum = 0;</span><br><span class="line"></span><br><span class="line">    InitFather(nPoint);　　　　//在查询的过程，再利用并查集</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nEdge; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fA = FindFather(graph[i].Start);</span><br><span class="line">        fB = FindFather(graph[i].End);</span><br><span class="line"></span><br><span class="line">        if( fA != fB )</span><br><span class="line">        &#123;</span><br><span class="line">            Father[fA] = fB;</span><br><span class="line">            sum += graph[i].Len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCity, nEdge;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;nCity), nCity != 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        nEdge = nCity*(nCity-1)/2;</span><br><span class="line">        for (int i = 0; i &lt; nEdge; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;graph[i].Start, &amp;graph[i].End, &amp;graph[i].Len);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(graph, graph+nEdge);</span><br><span class="line">        printf(&quot;%d\n&quot;, Kruskal(nCity, nEdge));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2_Prime算法">2.2 Prime算法</h3><ul><li><p>思路：</p><ol><li>随机选一个点作为起点（x）</li><li>找出以x点为起点到其它点的最小距离</li><li>将最小的距离的点加入最小生成树中</li><li>循环，直到找到n-1条边</li></ol></li><li><p>代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_POINT = 105;</span><br><span class="line">const int INF = (1&lt;&lt;30)-1;</span><br><span class="line"></span><br><span class="line">int  graph[MAX_POINT][MAX_POINT];</span><br><span class="line">int  dis[MAX_POINT];</span><br><span class="line">bool flag[MAX_POINT];</span><br><span class="line"></span><br><span class="line">int Prime(int nPoint, int nEdge)</span><br><span class="line">&#123;</span><br><span class="line">    // 将1作为起始点</span><br><span class="line">    for (int i = 1; i &lt;= nPoint; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = graph[1][i];</span><br><span class="line">        flag[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[1] = true;</span><br><span class="line"></span><br><span class="line">    int MinLen, index = 1;</span><br><span class="line">    int sum = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nPoint-1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        MinLen = INF;</span><br><span class="line">        for (int j = 1; j &lt;= nPoint; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!flag[j] &amp;&amp; dis[j] &lt; MinLen)</span><br><span class="line">            &#123;</span><br><span class="line">                MinLen = dis[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(MinLen == INF) return -1;   //此处表示图中存在着独立的点</span><br><span class="line"></span><br><span class="line">        sum += MinLen;</span><br><span class="line">        flag[index] = true;</span><br><span class="line"></span><br><span class="line">        for (int j = 1; j &lt;= nPoint; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            /*</span><br><span class="line">            *  从没有被选入最小生成树中结点中找出一个点来。要注意dis[j] &gt; graph[index][j]这句</span><br><span class="line">            ＊ 话，因为dis记录的是最前面距离其它未被访问点的最小距离，如图示</span><br><span class="line">            */</span><br><span class="line">            if(!flag[j] &amp;&amp; dis[j] &gt; graph[index][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = graph[index][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCity, nEdge;</span><br><span class="line">    int Start, End, Len;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;nCity), nCity != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        nEdge = nCity*(nCity-1)/2;</span><br><span class="line">        for (int i = 0; i &lt; nEdge; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;Start, &amp;End, &amp;Len);</span><br><span class="line">            graph[Start][End] = Len;</span><br><span class="line">            graph[End][Start] = Len;   //从这可以看出prime是针对无向图的，而kruskal都可以</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;, Prime(nCity, nEdge));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>针对代码中的  dis[j] &gt; graph[index][j]，的图解</p> <center><img src="/pics/最小生成树-demo.jpg" alt=""></center><p> 在这个图中，我们在以A为起点，然后在第一次的查找过程中，因为我们每次都是找以A为起点的最短边，那么我们将选择B点，如果我们以B点为起点再去找的话将会这样将会丢失A－C，这条线的距离，因为我们的dis保存的就是前面（不仅仅是前面一个点，而是前面所有点的最小距离），所以我们就用dis[j]与graph[index][j]比较，这样就会保证dis永远是最小的。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>博弈问题</title>
      <link href="/Algorithm/Algorithm/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"/>
      <url>/Algorithm/Algorithm/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-_巴什博弈">1. 巴什博弈</h2><ul><li>问题<br>  有一堆石子，石子个数为n，两人轮流从石子中取石子出来，最少取一个，最多取m个。最后不能取的人输，问你最后的输赢情况。</li><li>思路<br>  只要保证在一轮中两人取的石子和为(1+m)，如果是 n 是（1+m）的整数倍，那么第二个人输，否则第一个人输</li></ul><h2 id="2-_威佐夫博弈">2. 威佐夫博弈</h2><ul><li>问题<br>  有两堆石子，石子数目分别为n和m,现在两个人轮流从两堆石子中拿石子，每次拿时可以从一堆石子中拿走若干个（无上限），也可以从两中拿走相同数量的石子，拿走最后一刻石子的人赢。</li><li>思路<ol><li>用 (a, b)来表示某个状态，a表示第一堆石子的个数，b表示第二堆石子的个数。</li><li>奇异状态：也称为失败状态，即如果你的状态为奇异状态，那么如果你的对手足够聪明的话，那么你将输掉比赛。</li><li>如果一个状态无论如何都会进入到下一个失败状态，那么该状态也将会是一个失败状态（奇异状态）</li></ol></li><li><p>通过实践，我们可以发现如下的失败状态： </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">(0, 0) : ”拿走最后一刻石子的人赢“，那么此状态下必输  </span><br><span class="line">(1, 2) :</span><br><span class="line"></span><br><span class="line">    可以取的方法：  </span><br><span class="line">    1. 从第一堆中取1个==&gt; (0, 2) ==&gt; 必输</span><br><span class="line">    2. 从第二堆中取1个==&gt; (1, 1) ==&gt; 必输</span><br><span class="line">    3. 从第二堆中取2个==&gt; (1, 0) ==&gt; 必输</span><br><span class="line">    4. 同时从第一堆和第二堆中取1个==&gt;(0, 1)==&gt;必输</span><br><span class="line">    ----&gt; 必输</span><br><span class="line"></span><br><span class="line">(3, 5) :</span><br><span class="line"></span><br><span class="line">    可以取的方法：</span><br><span class="line">    如果（3，5）一定会变成（1，2），那么则说明（3，5）是一个失败状态，所以此时，我们应该考虑尽可能避免让对手、把自己给逼到下一个失败状态，所以在此处我们不会从第一堆中取2个，因为取了2个，那对手从第二堆中取4个就将你逼到了失败态，也不从第二堆中取3，所以在下面就不直接罗列了）</span><br><span class="line">    1. 从第一堆中取1个==&gt;（2，5）==&gt;对手从第二堆中取4个==&gt;(2, 1)＝＝&gt;(1,2)  ==&gt;必输</span><br><span class="line">    2. 从第二堆中取1个==&gt;(3, 4) ==&gt;对手同时从第一和第二堆中取2个            ==&gt;必输</span><br><span class="line">    3. 从第二堆中取2个==&gt;(3, 3) ==&gt;对手同时从第一和第二堆中取3个            ==&gt;必输</span><br><span class="line">    4. 同时从第一和第二堆中取1个==&gt;(2, 4)==&gt;对手从第二堆中取3个             ==&gt;必输</span><br><span class="line">    5. 同时从第一和第二堆中取2个==&gt;(1, 3)==&gt;对手从第二堆中取1个             ==&gt;必输</span><br><span class="line">    ----&gt; 必输</span><br><span class="line"></span><br><span class="line">(4, 7) :</span><br><span class="line"></span><br><span class="line">    可以取的方法：</span><br><span class="line">    1. 从第二堆中取1个==&gt;(4,6)==&gt;对手同时从第一和第二堆中取1个==&gt;（3，5）  ==&gt;必输</span><br><span class="line">    2. 同时取1个==&gt;(3, 6) ==&gt;从第二堆中取2个 ==&gt;(3, 5)                     ==&gt;必输</span><br><span class="line">    3. 同时取2个==&gt;(2, 5) ==&gt;从第二堆中取4个 ==&gt;(2,1)                      ==&gt;必输</span><br><span class="line">    4. 同时取3个==&gt;(1, 4) ==&gt;从第二堆取2个   ==&gt;(1, 2)                     ==&gt;必输</span><br><span class="line">    ----&gt; 必输</span><br><span class="line"></span><br><span class="line">(6, 10):</span><br><span class="line"></span><br><span class="line">    可以取的方法：</span><br><span class="line">    1. 从第一堆中取1个==&gt;(5, 10)==&gt;从第二堆中取7个==&gt;(5, 3)                ==&gt;必输</span><br><span class="line">    2. 从第二堆中取1个==&gt;(６,９)==&gt;同时取2个==&gt;(4, 7)                      ==&gt;必输</span><br><span class="line">    3. 从第二堆中取2个==&gt;(6,  8)==&gt;同时取3个==&gt;(3, 5)                      ==&gt;必输</span><br><span class="line">    4. 同时取1个==&gt;(5, 9)==&gt;从第二堆中取6个==&gt;(5,2)                        ==&gt;必输</span><br><span class="line">    ----&gt; 必输</span><br><span class="line"></span><br><span class="line">(8, 13):</span><br><span class="line"></span><br><span class="line">    也可以用同样的方法，去检查。</span><br><span class="line">    通过观察这些数列可以得出下列一个公式：</span><br><span class="line">        b[i] = a[i] + i;</span><br><span class="line">        b[i] :  表示第i个失败状态下，第二堆的个数</span><br><span class="line">        a[i] :  表示第i个失败状态下，第一堆的个数</span><br><span class="line">        i    :  表示第i个失败状态</span><br><span class="line">    有一个公式可以求a[i] = [ i * (1+√5)/2 ]  ([]，这里的括号表示取整)</span><br><span class="line">    ----&gt;</span><br><span class="line">        如果有一个状态（a, b）如何判断是否是一个必败或者必胜的状态</span><br></pre></td></tr></table></figure><p>  代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   void Judge(int &amp;a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">if (a &gt; b) swap(a, b);</span><br><span class="line">int temp = a - b;</span><br><span class="line">if( b == temp * (1+sqrt(5))/2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;必败&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;必胜&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-_尼姆博奕（Nimm_Game）">3. 尼姆博奕（Nimm Game）</h2><ul><li>问题<br>  有三堆各若干个物品,两个人轮流从某一堆取任意多的物品,规定每次至少取一个,多者不限,最后取光者得胜。</li><li>前提<br>  （a, b, c）表示当前的状态</li><li><p>结论</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果 a ^ b ^ c = 0，则为失败的状态，非0则为必胜状态</span><br><span class="line">如何将失败状态转换成成功状态：</span><br><span class="line">如果 a ^ b &lt; c，  则从第三堆中取走 c - (a^b)个</span><br><span class="line">如果 a ^ c &lt; b,   则从第二堆中取走 b - (a^c)个</span><br><span class="line">如果 b ^ c &lt; a,   则从第一堆中取走 a - (b^c)个</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分布式一致性</title>
      <link href="/Distributed/Distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/Distributed/Distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      <content type="html"><![CDATA[<h3 id="一、CAP定律">一、CAP定律</h3><p>鲁尔定理（Brewer’s theorem），是埃里·布鲁尔（Eric Brewer）于1998年提出的一个假设。在2002年，麻省理工学院的赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）又完成了布鲁尔假说的证明：</p><p>对一个分布式计算系统来讲，不能同时满足以下三点：</p><ul><li><code>Consistency</code><br><br>一致性, 在同一时间具有相同的数据</li><li><code>Availability</code><br><br>可用性, 保证对于每个请求的成功或者失败都有响应</li><li><code>Partition tolerance</code><br><br>即分布式系统遇到某节点或网络分区故障时，仍然能够对外提供服务</li></ul><h3 id="二、BASE模型">二、BASE模型</h3><p>通过<code>CAP</code>理论可以了解，无法同时满足三个条件，最多只能保证同时保证两个条件，那同时保证哪两个条件呢？<code>BASE</code>模型就提出一个解决方案，使系统能够尽可能去兼顾一致性、可用性、分区容忍性。</p><ul><li>Basicially Available<br><br>基本可用，是指系统能够基本运行、始终提供服务</li><li>Soft-state<br><br>软件状态，是指系统可以在不同步的状态下，稳定运行一段时间</li><li>Eventually consistent<br><br>最终一致性</li></ul><p>一致性可以分如下几类:</p><ul><li>强一致性<br><br>即时一致性，当A写入，A、B、C都将返回最新值</li><li>弱一致性<br><br>A写入，不能保证A、B、C立即能读取到最新值</li><li>最终一致性<br><br>最终一致性是弱一致性的特例，是指系统需要在某一段时间后才能达到一致性要求</li></ul><p>BASE模型是CAP理论结合实际问题的产物，主要强调基本的可用性，最终达到一致性的要求。但是如何保证最终一致性呢？如果保证强一致性呢？</p><p>通常保证强一致性有如下的方案:</p><ul><li><code>2PC</code></li><li><code>3PC</code></li><li><code>TCC</code></li></ul><p>通常保证最终一致性有如下方案:</p><ul><li>基于消息队列，实现状态转移</li></ul><h3 id="三、2PC">三、2PC</h3><p><code>Two-phase Commit</code>，二阶段提交，在该过程中存在两个角色: 协调者和参与者。分两个阶段: 准备阶段和提交阶段。准备阶段用于锁住资源，并执行完大部分的逻辑，提交阶段用于提交或者回滚资源。准备阶段相对于提交阶段用时更长，会尽可能保证提交阶段的逻辑简单、迅速。</p><center><img src="/pics/二阶段提交.png" alt=""></center><p>整体逻辑如上，一旦任意一个参与者出现异常，协调者将会提交回滚请求给所有参与者。2PC存在如下的缺点:</p><ul><li>同步阻塞问题<br><br>所有参与者在整个过程，必须听从协调者的安排，整个过程需要阻塞</li><li>单点故障<br><br>协调者是一个单点</li><li>数据不一致<br><br>当协调者发出提交命令之后，如果协调者出现故障和局部网络异常，将会导致一部分服务器执行了提交命令，而另一部分命令没有被执行，会导致数据不一致</li></ul><p>由由<code>X/Open</code>组织提出的分布式事务的规范<code>XA</code>，就是基于<code>2PC</code>设计的，其中存在着两个角色：<code>TM(事务管理器)</code>和<code>RM(资源管理器)</code>。在<code>Java</code>中提出了<code>JTA（Java Transaction API）</code>规范，用于提供对<code>XA</code>的支持。</p><h3 id="四、3PC">四、3PC</h3><p><code>Three-phase Commit</code>，三阶段提交，<code>3PC</code>主要用于解决<code>2PC</code>中的问题。其在<code>2PC</code>的基础上，主要在<code>2PC</code>的提交阶段前，增加了一个<code>CanCommit</code>阶段，该阶段很轻，只是用于检查状态。同时还引入了超时机制。超时机制主要作用于不同的阶段作用不一样:</p><ul><li><code>CanCommit</code><br><br>当任意一个参与者超时，协调者将会将向所有参与者发出关闭请求从而关闭整个事务</li><li><code>PreCommit</code><br><br>当任意一个参与者超时，协调者将会将向所有参与者发出回滚请求从而关闭整个事务释放所有资源</li><li><code>doCommit</code><br><br>此阶段中，如果协调者一直不能发出提交或者回滚的请求，参与者默认会执行提交操作</li></ul><center><img src="/pics/三阶段提交.png" alt=""></center><p>相对于<code>2PC</code>，<code>3PC</code>主要有如下改进:</p><ol><li>在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的</li><li>同时在协调者和参与者中都引入超时机制，能够解决协调者单点问题，减少同步阻塞的问题，但是还不能从基本上解决不一致的问题，因为默认是执行提交操作，如果协调者发出的是回滚操作，只成功向部分参与者发出请求，那么会导致部分参与者会执行提交操作，出现不一致。</li></ol><h3 id="五、TCC">五、TCC</h3><p><code>Try-Confirm-Cancel</code>模式，要求服务提供如下三个接口:</p><ul><li><code>Try</code><br><br>完成所有业务检查(一致性)，预留必须业务资源(准隔离性)</li><li><code>Confirm</code><br><br>真正执行业务，不做任何业务检查，只使用Try阶段预留的业务资源，需要满足幂等性</li><li><code>Cancel</code><br><br>释放Try阶段预留的业务资源，必须满足幂等性</li></ul><p>与<code>2PC</code>的区别:</p><ol><li>位于业务层而非资源层</li><li>没有单独的准备阶段，<code>Try</code>兼具资源操作与准备能力</li><li><code>Try</code>操作可以灵活选择业务资源的锁定粒度，而不整个资源，提高了并发度</li><li>较高开发成本</li><li>资源隔离</li><li>虽然保留了协调者的概念在里面，但其实在业务场景上，就是其主业务，不必单独开发，而且通常主业务都是分布式的，并不存在单点的问题</li></ol>]]></content>
      
      <categories>
          
          <category> Distributed </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java内存、GC、JVM参数</title>
      <link href="/Java/Java/Java%E5%86%85%E5%AD%98%E4%B8%8EGC/"/>
      <url>/Java/Java/Java%E5%86%85%E5%AD%98%E4%B8%8EGC/</url>
      <content type="html"><![CDATA[<h3 id="一、Java内存区域">一、Java内存区域</h3><center><img src="/pics/Java-memory.jpg" alt=""></center><ul><li><p>程序计数器<br><br>用于指明当前线程需要执行的字节码行；<strong>线程私有</strong>；如果是Java方法，则记录虚拟机字节码指令地址，如果为<code>native</code>方法，则为<code>Undefined</code></p></li><li><p>虚拟机栈<br><br>每一个方法执行时，都将创建一个栈帧，用于记录局部变量、操作栈、动态链接、方法出口等，当方法被调用时，栈帧入栈，执行完成后，出栈。<strong>线程私有</strong>。</p></li><li><p>本地方法栈<br><br>与虚拟机栈类似，唯一的区别就是：虚拟机栈保存Java方法栈帧，而本地方法栈保存native方法栈帧。<strong>线程私有</strong>。</p></li><li><p>堆区<br><br>GC的主要区域，由<strong>所有线程共享</strong>，在虚拟机启动时创建，用于存储对象实例。</p></li><li><p>Metaspace<br><br>各个线程共享的区域，用于存储已经被虚拟机加载的类信息、final常量、静态变量、编译器即时编译的代码等。</p></li><li><p>直接内存<br><br>不受JVM管理的内存。</p></li></ul><h3 id="二-_Java堆">二. Java堆</h3><p>在<code>Java</code>的内存中，程序能够管理的内存主要是堆。<code>Metaspace</code>是一块连续内存，由虚拟机管理，可以通过JVM参数调整其最大值。</p><center><img src="/pics/Java-Hotspot-GC-generation.jpg" alt=""></center><ul><li><p>Young Generation<br><br>Eden 用于存储新创建的对象，From Space 和 To Space 统称为Survive区，用于存储 Minor GC 后仍然存活的对象。Minor GC，是指专门针对Young Generation区域进行GC，每一次Minor GC过程，将会清空From Space 和 Eden区，并将存活的对象放在 To Space。其实 From Space、To Space是一个相对的概念，例如当前这一次某一个Survive分区为 From Space，那么下次就成为了 To Space，彼此交替。From Space 和 To Space 通常一样大。比例是8:1:1</p></li><li><p>Old Generation<br><br>当 To Space 不能已经不能再存储对象时，就将对象存储到 Old Generateion。当对此分区进行GC时，被称为 Major GC / Full GC。</p></li><li><p>Permanent Gneration<br><br>久代主要存放类定义，字节码，和常量等很少会变更的信息。并且永久代不会发生垃圾回收，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full Gc）。而在java8中，已经移除了永久代，新加了一个叫做元数据区的native内存区。</p></li></ul><h3 id="4-_常见的GC算法">4. 常见的GC算法</h3><ul><li><p>Reference Counting<br><br>引用计数法，对于一个对象A，只要任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数减1。只要对象A的引用计数器的值为0，则对象A就不可以再被使用。无法解决循环引用。</p></li><li><p>Mark-Sweep<br><br>标记-清除算法，先通过根节点，标记所有从根节点开始的较大对象。在清除阶段，清除所有未被标记的对象。会导致大量的内存碎片。</p></li><li><p>Copying<br><br>复制算法，将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。使用内存空间变少。</p></li><li><p>Mark-Compact<br><br>标记-压缩算法，节点开始对所有的可达对象做一次标记，但是之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。避免了碎片的产生，又不需要两块相同的内存空间。其性价比比较高。</p></li><li><p>Incremental Collecting<br><br>增量算法，垃圾收集维和只收集一小片区域的内存空间，接着切换到应用程序线程。能够减少系统的停顿时间，但是，因为线程切换和上下文转换的消耗，会使垃圾回收的总体成本上升，造成系统吞吐量的下降。</p></li><li><p>Generational Collecting<br><br>分代，垃圾回收对象的特性，将对象分成不同的代，比如新生代和老年代，新生代具有存活率低的特点，所以采用高效的复制算法，而老年代具有存活率高的特点，所以采用标记-压缩算法。这样根据不同阶段使用合适的算法，将最大化GC的效率。</p></li></ul><h3 id="5-_各个分代的GC策略">5. 各个分代的GC策略</h3><ul><li><p>Young Generation<br><br>在此分区上的对象，具有生命周期短的特点，通常采用 <strong>停止-复制</strong>的算法。</p></li><li><p>Old Generation<br><br>此分区上的对象具有数量多，对象大的特点，通常采用 <strong>标记-整理</strong>的算法。</p></li><li><p>Permanent Gneration<br><br>对于无用的类进行回收，必须保证3点：</p><ol><li>类的所有实例都已经被回收</li><li>加载类的ClassLoader已经被回收</li><li>的Class对象没有被引用（即没有通过反射引用该类的地方）</li></ol></li></ul><h3 id="6-_垃圾收集器">6. 垃圾收集器</h3><p>针对新生代有如下算法 :  <code>Serial</code>, <code>ParNew</code>, <code>Parallel Scavenge</code>, <code>G1</code></p><p>针对老年代有如下算法 :  <code>CMS</code>, <code>Serial Old(MSC)</code>, <code>Parallel Old</code>, <code>G1</code></p><ul><li><p>Serial<br><br>新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。</p></li><li><p>ParNew<br><br>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。</p></li><li><p>Parallel Scavenge<br><br>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</p></li><li><p>Serial Old<br><br>老年代收集器，单线程收集器，使用标记整理的策略，单线程GC，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>Parallel Old<br><br>老年代，多线程收集器，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>CMS<br><br>Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</p><ol><li>初始标记， 仅仅标记一下GC Roots能直接关联到的对象</li><li>并发标记， 进行GC Roots Tracing的过程</li><li>重新标记， 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>并发清除， 标记某一个对象不可用</li></ol><p>初始标记与重新标记仍然需要停止其它工作线程。其主要的2个过程，都采用并发的操作，能够保证与工作线程一起运行。但是该算法对CPU资源很敏感，CPU越多，越快；无法处理浮动垃圾，即在一次GC过程中，可能又会出现一些垃圾，需要下次GC去处理，因为它没有停止工作线程；会产生大量内存碎片，没有整理。</p></li><li><p>G1<br><br>基于“标记-整理”算法实现的收集器，不会产生空间碎片。G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ul><h3 id="七、JVM参数">七、JVM参数</h3><p>查看默认值 <code>java -XX:+PrintFlagsFinal -version</code></p><h4 id="7-1_内存参数">7.1 内存参数</h4><p>针对一个4核8G的机器，可以如下进行配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms4096M</span><br><span class="line">-Xmx4096M</span><br><span class="line">-Xmn1536M</span><br><span class="line">-Xss228K</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">-XX:+AlwaysPreTouch</span><br><span class="line">-XX:AutoBoxCacheMax=20000</span><br></pre></td></tr></table></figure><p>通常的初始堆（<code>Xms</code>）与最大堆（<code>Xmx</code>）一样，并且年轻代（<code>Xmn</code>）占堆大小的八分之三，<code>Eden</code>区与<code>Survivor</code>的比例为8。</p><p>在jdk8中还有一个<code>Metaspace</code>，通常可以不用配置。</p><h4 id="7-2_推荐GC算法配置">7.2 推荐GC算法配置</h4><p>通常会使用<code>CMS</code>+<code>ParNewGC</code>的组合，以达到降低系统延迟的目的。配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=50</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure><ul><li><code>-XX:+ExplicitGCInvokesConcurrent</code><br><br>当执行<code>System.gc()</code>方法时，并不会执行一次<code>Full GC</code>，而是执行一次<code>CMS GC</code></li><li><code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code><br><br>当执行<code>System.gc()</code>方法时，并不会执行一次<code>Full GC</code>，而是执行一次<code>CMS GC</code>并且卸载类。</li></ul><p>针对堆内存大于等于<strong>6G</strong>的应用，可以使用<code>G1</code>算法。</p><h4 id="7-3_推荐GC日志配置">7.3 推荐GC日志配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-Xloggc:/data/logs/XXXX</span><br></pre></td></tr></table></figure><ul><li><code>-XX:+PrintGCApplicationConcurrentTime</code><br><br>是否打印从上次由于GC引起的暂停到现在的时间间隔，默认是关闭</li><li><code>-XX:+PrintGCApplicationStoppedTime</code><br><br>是否打印此次由于GC引起的暂停持续时间</li><li><code>-XX:+PrintTenuringDistribution</code><br><br>打印数据经过的年纪，即经过多次的<code>YGC</code></li></ul><h4 id="7-4_OOM时堆栈日志">7.4 OOM时堆栈日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/data/logs/XXXX</span><br></pre></td></tr></table></figure><h4 id="7-5_JVM异常日志">7.5 JVM异常日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ErrorFile=/data/logs/XXX</span><br></pre></td></tr></table></figure><p>如果写入指定的文件失败，默认会写到<code>/tmp</code>目录下</p><h4 id="7-6_JMX开启">7.6 JMX开启</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Djava.rmi.server.hostname=127.0.0.1 </span><br><span class="line">-Dcom.sun.management.jmxremote.port=9999</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br></pre></td></tr></table></figure><h4 id="7-7_行为选项">7.7 行为选项</h4><ul><li><code>-XX:-AllowUserSignalHandlers</code><br><br>  限于Linux和Solaris,默认不启用允许为java进程安装信号处理器.Java信号处理相关知识,详见 <a href="http://kenwublog.com/java-asynchronous-notify-based-on-signal" target="_blank" rel="noopener">http://kenwublog.com/java-asynchronous-notify-based-on-signal</a></li><li><code>-XX:-DisableExplicitGC</code><br><br>  默认不启用禁止在运行期显式地调用 System.gc().开启该选项后,GC的触发时机将由Garbage Collector全权掌控</li><li><code>-XX:-RelaxAccessControlCheck</code><br><br>  默认不启用在Class校验器中,放松对访问控制的检查.作用与reflection里的setAccessible类似.</li><li><code>-XX:+DisableAttachMechanism</code><br><br>  是否可以使用jcmd、jstack、jmap等工具，默认是false，则可以使用</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
