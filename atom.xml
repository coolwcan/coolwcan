<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coolwcan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coolwcan.cn/"/>
  <updated>2019-03-15T07:11:40.642Z</updated>
  <id>https://coolwcan.cn/</id>
  
  <author>
    <name>coolwcan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java应用高并发优化漫谈</title>
    <link href="https://coolwcan.cn/J2ee/J2ee/Java%E5%BA%94%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/"/>
    <id>https://coolwcan.cn/J2ee/J2ee/Java应用高并发优化漫谈/</id>
    <published>2019-03-15T07:09:28.545Z</published>
    <updated>2019-03-15T07:11:40.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景">一、背景</h3><p>现在<code>QBus</code>每天有<strong>1.1～1.2</strong>亿次访问量，其中消息发送和删除的请求有<strong>9~10</strong>千万次，由两台4核8G的机器提供服务，消息拉取接口有<strong>1～2千万</strong>左右的访问量，同样也是由两台4核8G的机器提供服务。以下就是我们在提高服务整体性能上所做出的优化。</p><h3 id="二、优化思路">二、优化思路</h3><p>在谈优化思路前，首先需要搞清楚一个<code>QBus</code>请求是如何从各个服务器走到<code>qbus-server</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk ==&gt; 域名解析 ==&gt; http协议 ==&gt; kong(nginx) ==&gt; qbus-server</span><br></pre></td></tr></table></figure><p>以下是针对每个环节提供的一些优化点，大家可以深入了解一下:</p><ul><li><p>SDK<br><br>TCP的keepalive，复用连接，使用连接池</p></li><li><p>域名解析如何优化呢？<br><br>CDN，选择就近资源</p></li><li><p>HTTP协议优化如何优化呢？<br><br>现在比较流行的是<code>HTTP/1.1</code>，但是可以的话，用<code>HTTP/2</code>，性能将提高很多</p></li><li><p>kong优化？<br><br>操作系统优化和nginx的优化</p></li><li><p><code>qbus-server</code>如何优化？<br><br>操作系统优化、jvm优化、tomcat优化、代码优化</p></li></ul><p>主要叙述的是<code>qbus-server</code>的优化，以下将会从这几个方面讲解一下<code>qbus-server</code>中的优化:</p><ul><li>操作系统优化</li><li>JVM优化</li><li>Tomcat优化</li><li>代码优化</li></ul><h3 id="三、内核及网络优化">三、内核及网络优化</h3><p>以下主要基于腾讯云上的Centos7的内核、网络优化。大家可以根据各自的情况进行相应的调整。</p><p>调整步骤:</p><ul><li>用<code>root</code>权限编辑<code>/etc/sysctl.conf</code>文件</li><li>执行<code>sysctl -p</code>使配置生效</li></ul><p>特别注意在修改线上文件前，请先备份。注释的为默认值配置</p><h4 id="3-1_关闭无用的资源">3.1 关闭无用的资源</h4><ul><li><p>关闭<code>ipv6</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br></pre></td></tr></table></figure></li><li><p>数据转发<br><br>可以实现数据转发，通常用于将一张网卡的数据转发到另一张网发上</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.ip_forward = 0</span><br></pre></td></tr></table></figure></li><li><p>不处理无源地址的网络包</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"></span><br><span class="line"># net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2_安全方面优化">3.2 安全方面优化</h4><ul><li><p><code>开启防欺骗攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure></li><li><p><code>避免ping flood攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br></pre></td></tr></table></figure></li><li><p>开启防SYN洪水攻击，当出现SYN等待队列溢出时，启用cookies来处理</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3_TCP优化">3.3 TCP优化</h4><ul><li><p><code>keepalive</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效，默认是7200s</span><br><span class="line"># net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line"></span><br><span class="line"># keepalive探针，当对方不给予回应时，发送的探针的次数</span><br><span class="line"># net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"></span><br><span class="line"># keepalive探针的间隔，单位秒</span><br><span class="line"># net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`H</span>TTP<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`分</span>别有什么作用？<span class="escape">`H</span>TTP/<span class="number">1.0</span><span class="escape">`协</span>议，每一个HTTP请求开始，都将打开一个TCP连接，请求结束，都将会关闭TCP连接。从<span class="escape">`H</span>TTP/<span class="number">1.1</span><span class="escape">`开</span>始，提供了<span class="escape">`k</span>eepalive<span class="escape">`功</span>能，指的是同时请求同一个服务的同一台机器时，请求结束后，并不会立即关闭TCP连接，而是保留一段时间，在保留时间段内的请求，会复用TCP连接，过期后，才会真正结束TCP连接。TCP的<span class="escape">`k</span>eepalive<span class="escape">`指</span>的是<span class="escape">`T</span>CP<span class="escape">`协</span>议层面上的一个检测机制，当某一个TCP连接没有数据传输后，会存在着一个定时器用于确定一个<span class="escape">`T</span>CP<span class="escape">`连</span>接是否依然存活，以决定是否关闭当前连接。<span class="label">从上面的解释大家也能看出他们的区别，它们是两个不同层面上的协议，但是它们会共同影响`TCP`连接的生命周期。从时间上，`TCP`的`keepalive`和`HTTP`的`keepalive`会了出现如下几种情况:</span><span class="number">1</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间一样<span class="number">2</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间大<span class="number">3</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间小因为<span class="escape">`H</span>TTP<span class="escape">`是</span>比<span class="escape">`T</span>CP<span class="escape">`更</span>高层的协议，当<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`的</span>时间一样，或者比<span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`小</span>，其逻辑会是正常的，因为HTTP先关，再关TCP嘛。但是如果<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`大</span>，则有可能会出现，<span class="escape">`H</span>TTP<span class="escape">`的</span>连接依然在复用，但是<span class="escape">`T</span>CP<span class="escape">`已</span>经关闭。</code></pre><ul><li><p><code>TIME_WAIT</code>状态的重用及回收</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 启TCP时间戳，用来计算往返时间RTT（Round-Trip Time）和防止序列号回绕，用于支持tcp_tw_reuse和tcp_tw_recycle</span><br><span class="line"># net.ipv4.tcp_timestamps = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的状态的重用</span><br><span class="line"># net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的快速回收，在对外网提供服务时，需要关闭</span><br><span class="line"># net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`T</span>IME-WAIT<span class="escape">`会</span>保持两个周期(<span class="escape">`M</span>S<span class="escape">`)</span>，而一个<span class="escape">`M</span>S<span class="escape">`是</span>一个IP报文最大的存活时间，而两个周期在于客户端发出<span class="escape">`A</span>CK<span class="escape">`到</span>达服务器的过程和数据报来到客户端的过程。只有在两个<span class="escape">`M</span>S<span class="escape">`内</span>没有任何数据，才能让客户端确定再没有任何的数据来自服务器，才能关闭<span class="escape">`S</span>ocket<span class="escape">`。</span><span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>快速回收，是一种基于时间序列的快速回收机制，并不会让<span class="escape">`T</span>IME_WAIT<span class="escape">`状</span>态持续两个周期，而是保持一个重传时间，能够快速释放资源。<span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>重用，当满足特定条件的<span class="escape">`S</span>ocket<span class="escape">`，</span>可以用于接受新的连接，而不用先关闭再连接。</code></pre><ul><li><p><code>TCP</code>内存</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 内核分配给TCP连接的内存，单位是page：</span><br><span class="line">#  第一个数字表示TCP使用的page少于此值时，内核不进行任何处理（干预），</span><br><span class="line">#  第二个数字表示TCP使用的page超过此值时，内核进入“memory pressure”压力模式，</span><br><span class="line">#  第三个数字表示TCP使用的page超过些值时，报“Out of socket memory”错误，TCP 连接将被拒绝</span><br><span class="line"># net.ipv4.tcp_mem = 7658911021191 1531782</span><br><span class="line">net.ipv4.tcp_mem = 88557 118079 177114</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的读缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_rmem = 4096873806291456</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 6291456</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的写缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_wmem = 4096163844194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重试次数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP连接时，SYN 重发的最大次数</span><br><span class="line"># net.ipv4.tcp_syn_retries = 6</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line"># TCP连接时重发ACK的最大次数</span><br><span class="line"># net.ipv4.tcp_synack_retries = 5</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line"># 孤儿sockets废弃前重试的次数</span><br><span class="line"># net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`孤</span>儿sockets<span class="escape">`指</span>的是已经从进程上下文中删除了，可是还有一些清理工作没有完成的<span class="escape">`s</span>ocket<span class="escape">`。</span></code></pre><ul><li><p>端口范围</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口范围，提高服务能力</span><br><span class="line"># net.ipv4.ip_local_port_range = 32768 60999</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure></li><li><p>Other</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 设置FIN_WAIT2的等待时间，单位秒，默认为60</span><br><span class="line"># net.ipv4.tcp_fin_timeout = 60</span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br><span class="line"></span><br><span class="line"># 设置TIME_WAIT的最大个数，大于这个阀值后会被删除</span><br><span class="line"># net.ipv4.tcp_max_tw_buckets = 131072</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line"># 表示SYN队列的长度，默认为1024，可以容纳更多等待连接</span><br><span class="line"># net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 100000</span><br><span class="line"></span><br><span class="line"># 用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制</span><br><span class="line"># net.core.somaxconn = 128</span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line"></span><br><span class="line"># 即不属于任何进程的tcp socket最大数量. 超过这个数量的socket会被reset, 并同时告警</span><br><span class="line"># net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">net.ipv4.tcp_max_orphans = 100000</span><br><span class="line"></span><br><span class="line"># 当网卡接受数据包的速率, 比kernel处理来的快时, cache这些数据包的队列长度，默认是1000</span><br><span class="line"># net.core.netdev_max_backlog = 1000</span><br><span class="line">net.core.netdev_max_backlog = 32768</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4_其它">3.4 其它</h4><ul><li><p>日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 用于调试内核</span><br><span class="line"># kernel.sysrq = 1</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line"></span><br><span class="line"># 用于在core dump文件中，增加进程ID</span><br><span class="line"># kernel.core_uses_pid = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br></pre></td></tr></table></figure></li><li><p>内核队列</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 控制一个消息的大小，bytes</span><br><span class="line"># kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"></span><br><span class="line"># 限制一个队列的最大消息个数</span><br><span class="line"># kernel.msgmax = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、JVM优化">四、JVM优化</h3><p>JVM优化主要针对两个方面，<strong>内存</strong>和<strong>GC</strong>，以确保服务的质量和服务所占内存处于一个稳定状态。首先先介绍一下JVM的内存分布和现有<code>GC</code>算法</p><h4 id="4-1_JVM内存">4.1 JVM内存</h4><p>JVM中的内存主要有如下几个部分组成:</p><ul><li><p>程序计数器<br><br>用于指明当前线程需要执行的字节码行；<strong>线程私有</strong>；如果是Java方法，则记录虚拟机字节码指令地址，如果为<code>native</code>方法，则为<code>Undefined</code></p></li><li><p>虚拟机栈<br><br>每一个方法执行时，都将创建一个栈帧，用于记录局部变量、操作栈、动态链接、方法出口等，当方法被调用时，栈帧入栈，执行完成后，出栈。<strong>线程私有</strong>。</p></li><li><p>本地方法栈<br><br>与虚拟机栈类似，唯一的区别就是：虚拟机栈保存Java方法栈帧，而本地方法栈保存native方法栈帧。<strong>线程私有</strong>。</p></li><li><p>堆区<br><br>GC的主要区域，由<strong>所有线程共享</strong>，在虚拟机启动时创建，用于存储对象实例。</p></li><li><p>方法区<br><br>各个线程共享的区域，用于存储已经被虚拟机加载的类信息、final常量、静态变量、编译器即时编译的代码等。</p></li><li><p>直接内存<br><br>不受JVM管理的内存。</p></li></ul><p>而我们所做的优化主要针对堆区，而堆又分成：<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>、<code>Old</code>，其中<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>被统称为年轻代，<code>Old</code>是老年代。</p><h4 id="4-2_GC算法">4.2 <code>GC</code>算法</h4><p><code>GC</code>主要用于回收堆内存，而堆主要包含两个部分:</p><ul><li>年轻代</li><li>老年代</li></ul><p>针对年轻代的<code>GC</code>称为<code>Minor GC</code>，针对老年代的<code>GC</code>称为<code>Full GC</code>。</p><p>由于年轻代具有生命周期短的特点，通常采用 <strong>停止-复制</strong>的算法，其主要的算法有:</p><ul><li><p>Serial<br><br>新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。</p></li><li><p>ParNew<br><br>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。</p></li><li><p>Parallel Scavenge<br><br>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</p></li></ul><p>针对老年代对象具有数量多，对象大的特点，通常采用 <strong>标记-整理</strong>的算法，其算法有:</p><ul><li><p>Serial Old<br><br>老年代收集器，单线程收集器，使用标记整理的策略，单线程GC，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>Parallel Old<br><br>老年代，多线程收集器，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>CMS<br><br>Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</p><ol><li>初始标记， 仅仅标记一下GC Roots能直接关联到的对象</li><li>并发标记， 进行GC Roots Tracing的过程</li><li>重新标记， 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li><p>并发清除， 标记某一个对象不可用</p><p>初始标记与重新标记仍然需要停止其它工作线程。其主要的2个过程，都采用并发的操作，能够保证与工作线程一起运行。但是该算法对CPU资源很敏感，CPU越多，越快；无法处理浮动垃圾，即在一次GC过程中，可能又会出现一些垃圾，需要下次GC去处理，因为它没有停止工作线程；会产生大量内存碎片，没有整理。</p></li></ol></li><li><p>G1<br><br>基于“标记-整理”算法实现的收集器，不会产生空间碎片。G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ul><h4 id="4-3_JVM优化">4.3 JVM优化</h4><p>为了避免<code>GC</code>带来的停顿影响服务质量，在内存和GC优化过程中会有如下经验:</p><ul><li>年轻代使用<code>ParNew</code>算法，老年代使用<code>CMS</code>算法，能够减少系统由于GC带来的停顿，当然也可以直接用<code>G1</code>算法，<code>QBus</code>线上使用的就是<code>ParNew</code>和<code>CMS</code>的组合</li><li>最大堆和最小堆设置成一样，能够避免扩容引起的<code>Full GC</code></li><li>最大堆的大小，不能超过整个物理机内存的50%</li><li>年轻代的大小，最好占整个堆的 <code>3/8</code></li><li><code>Eden</code>和<code>Survivor</code>的比例是<code>8</code></li><li><code>-XX:+DisableExplicitGC</code>，这个参数慎用，<code>DirectBuffer</code>的内存释放依赖<code>System.gc()</code>，会导致内存泄露。</li></ul><p>除了内存与<code>GC</code>优化外，以下几个方面也是需要优化的:</p><ul><li>打印<code>GC</code>日志</li><li>出现内存问题时，导出内存到文件</li></ul><p>如下是线上的一台<code>QBus</code>机器的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-server </span><br><span class="line">                  -XX:+PrintGCDetails </span><br><span class="line">                  -XX:+PrintGCDateStamps </span><br><span class="line">                  -Xloggc:/data/logs/qbus-server/jvm-gc/gc.log </span><br><span class="line">                  -XX:ErrorFile=/data/logs/qbus-server/jvm-error/error.log </span><br><span class="line">                  -Xms4096M </span><br><span class="line">                  -Xmx4096M </span><br><span class="line">                  -Xss228k </span><br><span class="line">                  -Xmn1536M </span><br><span class="line">                  -XX:SurvivorRatio=8 </span><br><span class="line">                  -XX:+UseParNewGC </span><br><span class="line">                  -XX:+UseConcMarkSweepGC </span><br><span class="line">                  -XX:+AggressiveOpts </span><br><span class="line">                  -XX:MaxTenuringThreshold=15 </span><br><span class="line">                  -XX:+CMSParallelRemarkEnabled  </span><br><span class="line">                  -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure><h3 id="五、Tomcat优化">五、Tomcat优化</h3><p>Tomcat的优化主要从如下几个方面进行优化:</p><ul><li>网络模型</li><li>连接池</li><li>线程池</li><li>超时时间</li><li>TCP参数</li></ul><p>下面将从这几个方面谈优化。</p><h4 id="5-1_网络模型">5.1 网络模型</h4><p>Tomcat8.5版本中，<code>Connector</code>的<code>protocol</code>支持三个模式:</p><ul><li><p><code>org.apache.coyote.http11.Http11NioProtocol</code><br><br>同步非阻塞，用Java的NIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11Nio2Protocol</code><br><br>异步非阻塞，用Java的AIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11AprProtocol</code><br><br>异步非阻塞，通过<code>JNI</code>的方式调用核心链接库来处理文档读取和网络传输。该协议会用到如下几个库:</p><ol><li>Apache Portable Run-time libraries(Apache可移植运行库，APR)</li><li>JNI wrappers for APR used by Tomcat (libtcnative)</li><li><p>OpenSSL</p><p><code>APR</code>库，是一个跨平台库，提供与平台无关的API，能够保证同一个API，在不同平台下运行，其结果总是一致的。而<code>libtcnative</code>则会调用<code>APR</code>库进行文档和网络传输的处理。而<code>Tomcat</code>则会通过<code>JNI</code>调用<code>libtcnative</code>库。</p></li></ol></li></ul><p><code>org.apache.coyote.http11.Http11AprProtocol</code>是<code>Tomcat</code>上运行高并发的首选，接下来将介绍如何安装APR库。</p><hr><p>首先创建<code>tomcat-native-install.sh</code>脚本，并添加执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">base=`pwd`</span><br><span class="line">#tomcat的安装目录</span><br><span class="line">tomcat_base=$1</span><br><span class="line">#希望编译好的lib放到什么地方</span><br><span class="line">lib_base=$2</span><br><span class="line">    </span><br><span class="line">function install_openssl() &#123;</span><br><span class="line">    openssl=openssl-1.1.0f</span><br><span class="line">    wget https://www.openssl.org/source/$&#123;openssl&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;openssl&#125;.tar.gz</span><br><span class="line">    cd $&#123;openssl&#125; </span><br><span class="line">    ./config --prefix=$&#123;base&#125;/ssl no-shared -fPIC</span><br><span class="line">    make &amp;&amp; make install_sw</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;openssl&#125; $&#123;openssl&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_apr() &#123;</span><br><span class="line">    apr=apr-1.6.3</span><br><span class="line">    wget http://archive.apache.org/dist/apr/$&#123;apr&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;apr&#125;.tar.gz</span><br><span class="line">    cd $&#123;apr&#125;</span><br><span class="line">    ./configure --prefix=$&#123;base&#125;/apr</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;apr&#125; $&#123;apr&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_tomcat_native() &#123;</span><br><span class="line">    base_dir=`pwd`</span><br><span class="line">    cd $&#123;tomcat_base&#125;/bin</span><br><span class="line">    pwd</span><br><span class="line">    tar -xf tomcat-native.tar.gz</span><br><span class="line">    cd `ls $&#123;tomcat_base&#125;/bin | grep src`/native</span><br><span class="line">    ./configure --with-apr=$&#123;base&#125;/apr --with-ssl=$&#123;base&#125;/ssl --with-java-home=$JAVA_HOME --prefix=$lib_base</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd $base_dir</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">install_openssl</span><br><span class="line">install_apr</span><br><span class="line">install_tomcat_native</span><br><span class="line">    </span><br><span class="line">rm -rf $&#123;base&#125;/apr</span><br><span class="line">rm -rf $&#123;base&#125;/ssl</span><br><span class="line">    </span><br><span class="line">lib=$&#123;lib_base&#125;/lib</span><br><span class="line">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&apos;$&#123;lib&#125; &gt;&gt; ~/.profile</span><br><span class="line">source ~/.profile</span><br><span class="line">    </span><br><span class="line">echo 编译 Tomcat目录/conf/server.xml，将其中的 Connector 的 protocol 改成 org.apache.coyote.http11.Http11AprProtocol 和</span><br><span class="line">echo org.apache.coyote.ajp.AjpAprProtocol</span><br></pre></td></tr></table></figure><p>然后再用<code>root</code>执行<code>./tomcat-native-install.sh Tomcat的安装目录 APR库的安装位置</code>进行安装，在传参时，需要注意如下两点:</p><ol><li>传入给shell的参数需要全路径</li><li>传给shell的路径参数，最后不需要加上<code>/</code></li></ol><p>例如： <code>./tomcat-native-install.sh /usr/local/services/tomcat /usr/local/services/tomcat-apr/tomcat-native</code></p><p>安装完成后，还需要修改如下配置：</p><ol><li>修改<code>Tomcat目录/conf/server.xml</code>将其中的<code>Connector</code>的<code>protocol</code>改成<code>org.apache.coyote.http11.Http11AprProtocol</code> 和<code>org.apache.coyote.ajp.AjpAprProtocol</code></li><li>修改<code>Tomcat目录/bin/catalina.sh</code>中添加<code>JAVA_OPTS=&quot;$JAVA_OPTS -Djava.library.path=上面APR的安装目录/lib&quot;</code></li></ol><p>重启服务，即可生效。在<code>logs/catalina.out</code>，能看到如下输出，则能确定<code>APR</code>库生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">07-Mar-2019 11:46:15.871 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8080&quot;]</span><br><span class="line">07-Mar-2019 11:46:15.875 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]</span><br></pre></td></tr></table></figure><h4 id="5-2_连接池优化">5.2 连接池优化</h4><ul><li><p><code>acceptorThreadCount</code><br><br>在<code>Tomcat</code>中会由专门的<code>accept</code>线程用于接收请求，并将请求转交给工作线程。通常<code>accept</code>线程个数与CPU核数一致，默认值为1</p></li><li><p><code>acceptCount</code><br><br>当已经没有任何可用的工作线程为新的请求提供服务时，会将请求进行缓存。<code>acceptCount</code>则用于指定缓存队列的大小。当请求无法再放入缓存队列后，请求将会被拒绝。通常用户可能会在nginx层面上看到如下的异常:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure></li><li><p><code>maxConnections</code><br><br>用于设置<code>Tomcat</code>的最大连接数，这仅仅是Tomcat层面上的限制，超过最大连接数后，操作系统层面，仍然会接收请求，只是请求请求将会进入到缓存队列，当缓存队列满后，请求会被阻塞。可以设置为-1，关闭此限制。</p></li></ul><h4 id="5-3_线程池优化">5.3 线程池优化</h4><p>线程池的优化主要有两个方面:</p><ul><li>线程命名</li><li>线程个数</li></ul><p>线程命名是为在排查问题时，通过<code>jstack</code>命令查询，能够区分出哪些是<code>Tomcat</code>线程。而线程个数能够保证服务的稳定运行。<code>QBus</code>服务线上的配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Executor name=&quot;tomcatThreadPool&quot;</span><br><span class="line">              namePrefix=&quot;tomcatThreadPool-&quot;</span><br><span class="line">              maxThreads=&quot;500&quot;</span><br><span class="line">              maxIdleTime=&quot;10000&quot;</span><br><span class="line">              minSpareThreads=&quot;300&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 用于指明线程名字前缀</li><li><code>minSpareThreads</code> 初始化线程个数</li><li><code>maxThreads</code> 线程池的最大线程个数</li><li><code>maxIdleTime</code> 当某一个线程多久未使用，将会被回收，单位毫秒</li></ul><p>通常可以将线程个数的最大个数设置为500，或者更多，然后上线后，通过<code>jstack tomcat线程ID | grep Tomcat线程前缀名 | grep run | wc -l</code>查看线上稳定运行的线程个数，然后再去调整<code>minSpareThreads</code>。</p><p>请注意在Tomcat中的<code>TPS</code>是由<code>maxConnections</code>、<code>acceptCount</code>与<code>maxThreads</code>共同决定的。</p><h4 id="5-4_超时优化">5.4 超时优化</h4><p>Tomcat总体上有如下几个超时设置:</p><ul><li><p><code>connectionTimeout</code><br><br>当客户端与服务器已经建立连接后，等待客户端传输请求头时，最多等待<code>connectionTimeout</code>毫秒</p></li><li><p><code>keepAliveTimeout</code><br><br>针对<code>HTTP/1.1</code>协议，用于设置服务器最大保持连接的时间</p></li><li><p><code>disableUploadTimeout</code>和<code>connectionUploadTimeout</code><br><br>  当<code>disableUploadTimeout</code>为<code>false</code>时，<code>connectionUploadTimeout</code>才会生效。<code>connectionUploadTimeout</code>用于设置服务器等待客户传输请求体的最大等待时间。</p></li></ul><p>注意<code>connectionTimeout</code>和<code>connectionUploadTimeout</code>，这两个参数分别设置了传输请求头与请求体的最大等待时间。<code>QBus</code>的线上配置是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot;</span><br><span class="line">                executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">                protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">                URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">                enableLookups=&quot;false&quot;</span><br><span class="line">                connectionTimeout=&quot;30000&quot;</span><br><span class="line">                keepAliveTimeout=&quot;30000&quot;</span><br><span class="line">                disableUploadTimeout=&quot;false&quot;</span><br><span class="line">                connectionUploadTimeout=&quot;600000&quot;</span><br><span class="line">                acceptCount=&quot;500&quot;</span><br><span class="line">                useSendfile=&quot;false&quot;</span><br><span class="line">                compression=&quot;off&quot;</span><br><span class="line">                redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="5-5_TCP参数">5.5 TCP参数</h4><ul><li><p><code>tcpNoDelay</code><br><br>用于开启或者关闭<code>Nagle</code>算法。<code>Nagle</code>算法，会将小的<code>TCP</code>包合并成一个大的包再进行发送，避免过多的小报文的TCP头的资源消耗。通常在交互性比较强的应用中会关闭<code>Nagle</code>算法，默认是开启的。</p></li><li><p><code>connectionLinger</code><br><br>与<code>TCP</code>的<code>SO_LINGER</code>的选项一致，用于控制<code>TCP</code>的<code>close</code>行为。<code>SO_LINGER</code>通常有三个取值：</p><ol><li>-1，会将<code>socket</code>发送缓存区中的数据发送完成后，才关闭<code>socket</code></li><li>0，通过发送RST分组(而不是用正常的FIN|ACK|FIN|ACK四个分组)来关闭该连接，并放弃发送缓存区中的数据。</li><li>大于0，关闭时，进程将进入睡眠状态，内核通过定时器在超时前尽量发送数据，如果发送完成，则正常关闭，否则超时后，直接通过<code>RST</code>进行关闭，丢弃发送缓存区中的数据。</li></ol></li><li><p><code>deferAccept</code><br><br>与<code>TCP</code>中的<code>TCP_DEFER_ACCEPT</code>选项一致。在解释<code>TCP_DEFER_ACCEPT</code>参数前，先解释一下<code>TCP</code>的三次握手:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Client -&gt; Server：客户端给服务器发送SYN包</span><br><span class="line">2. Client &lt;- Server: 服务器在收到SYN包后，将返给客户SYN + ACK，Server端的连接为SYN_RECV状态</span><br><span class="line">3. Client -&gt; Server: 客户端收到SYN+ACK包后，向服务器发送ACK包，Client和Server端的连接均为ESTABLISHED</span><br></pre></td></tr></table></figure><p>  通常服务器在接受到最后的一个<code>ACK</code>包后，将进入<code>ESTABLISH</code>状态。此过程会出现一个问题，当服务器已经打开了连接，但是如果客户端一直不发数据的话，会占用服务器的资源。而<code>TCP_DEFER_ACCEPT</code>选项开启后，在接受到最后一个<code>ACK</code>后，并不会进入<code>ESTABLISH</code>状态，也并不会真正建立连接，而是保持在<code>SYN_RECV</code>状态，只是标记当前<code>socket</code>，当客户端的数据真正到来时，才建立连接。通常是需要开启<code>延迟ACK</code>，将<code>ACK</code>与数据一起发送，才能建立连接。</p></li><li><p><code>useSendfile</code><br><br>用于开启或者关闭<strong>零拷贝机制</strong>，该机制，通过减少数据在用户态和内核态的拷贝，从而提高性能。</p></li></ul><h4 id="5-6_Tomcat的注意点">5.6 Tomcat的注意点</h4><ul><li><code>Spring</code>项目，尽量不要将项目调整成<code>root</code>目录，否则有可能你会遇到某一个<code>bean</code>会被初始化两次的问题</li><li>一个<code>Tomcat</code>尽量只有一个项目</li></ul><h3 id="六、代码层面上的优化">六、代码层面上的优化</h3><p>代码方面，主要引入了内存级别的缓存层，将配置信息放入缓存，避免对数据库的读操作。多个进程间的缓存同步有两个机制进行保证:</p><ul><li>同步通过<code>QBus</code>本身进行同步</li><li>当从缓存中读取不到数据时，再读数据库，此时一定需要注意，避免出现<code>Dog Pipe Effect</code>现象</li></ul><p>加入缓存后，整个消息的发送时延多<code>40ms</code>降低到<code>10～15ms</code>之间。</p><h3 id="七、总结">七、总结</h3><p>以上就是<code>QBus</code>已经做过的优化，在孙哥(孙国峻)和我们沟通后，新版本的<code>QBus</code>中，我们将做如下的优化:</p><ol><li>减少对数据库的依赖，引入redis</li><li>模块分离，将<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>与页面逻辑进行模块分离</li><li>针对<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>接口，通过<code>netty</code>进行网络接连，这样可以自定义其<code>TCP</code>参数、连接池、线程池、网络模型等，而且除了能提高性能，同样也能给出详细的日志，比如metric信息、异常信息等，能更好地把控服务</li><li>优化日志，不直接写kafka，写文件，再同步到kafka，以便快速解决问题</li></ol><p>优化是一个长期过程，而要反复迭代，并且会很受到业务功能的影响，比如<code>QBus</code>的拉消息接口，其功能决定了这是一个慢操作，而发送消息、删除消息，就必须要保证尽可能快，所以相对而言，拉消息更消耗内存，而发送消息、删除消息接口更消耗CPU，所以优化时，也需要分开处理。欢迎大家补充指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、背景&quot;&gt;一、背景&lt;/h3&gt;&lt;p&gt;现在&lt;code&gt;QBus&lt;/code&gt;每天有&lt;strong&gt;1.1～1.2&lt;/strong&gt;亿次访问量，其中消息发送和删除的请求有&lt;strong&gt;9~10&lt;/strong&gt;千万次，由两台4核8G的机器提供服务，消息拉取接口有&lt;s
      
    
    </summary>
    
      <category term="J2ee" scheme="https://coolwcan.cn/categories/J2ee/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="高并发" scheme="https://coolwcan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper-02-Session</title>
    <link href="https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper-02-Session/"/>
    <id>https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper-02-Session/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>在对 <code>Zookeeper</code> 的使用过程中，经常会用到临时节点，而临时节点与 <code>Session</code> 相关，那么 <code>Session</code> 在 <code>Zookeeper</code> 中到底是怎样的一个概念呢？会从如下几个角度去看:</p><ol><li>Session 的创建</li><li>Session 的关闭</li><li>Session 的过期</li></ol><p>在 <code>Zookeeper</code> 找到了一个与 <code>Session</code> 相关的接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface SessionTracker &#123;</span><br><span class="line">    public static interface Session &#123;</span><br><span class="line">        long getSessionId();</span><br><span class="line">        int getTimeout();</span><br><span class="line">        boolean isClosing();</span><br><span class="line">    &#125;</span><br><span class="line">    public static interface SessionExpirer &#123;</span><br><span class="line">        void expire(Session session);</span><br><span class="line">        long getServerId();</span><br><span class="line">    &#125;</span><br><span class="line">    long createSession(int sessionTimeout);</span><br><span class="line">    boolean addGlobalSession(long id, int to);</span><br><span class="line">    boolean addSession(long id, int to);</span><br><span class="line">    boolean touchSession(long sessionId, int sessionTimeout);</span><br><span class="line">    void setSessionClosing(long sessionId);</span><br><span class="line">    void shutdown();</span><br><span class="line">    void removeSession(long sessionId);</span><br><span class="line">    boolean isTrackingSession(long sessionId);</span><br><span class="line">    public void checkSession(long sessionId, Object owner)</span><br><span class="line">            throws KeeperException.SessionExpiredException,</span><br><span class="line">            KeeperException.SessionMovedException,</span><br><span class="line">            KeeperException.UnknownSessionException;</span><br><span class="line">    public void checkGlobalSession(long sessionId, Object owner)</span><br><span class="line">            throws KeeperException.SessionExpiredException,</span><br><span class="line">            KeeperException.SessionMovedException;</span><br><span class="line">    void setOwner(long id, Object owner) throws SessionExpiredException;</span><br><span class="line">    void dumpSessions(PrintWriter pwriter);</span><br><span class="line">    Map&lt;Long, Set&lt;Long&gt;&gt; getSessionExpiryMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionTracker</code> 中的<code>Session</code> 这个接口，相对于 <code>Web</code> 中的 <code>Session</code>, 其功能是很弱的，感觉仅仅标记了一个 <code>Session</code> 而已。在查看资料时，发现如下的一个状态图:</p><center><img src="/pics/Zookeeper-Session-Status.jpg" alt=""></center><p>其它的状态没什么可以说的，但是需要注意 <code>CONNECTING</code> 与 <code>CONNECTED</code> 之间存在相互转换的过程，在如下的情况下 <code>Session</code> 将被关闭:</p><ol><li>登录的认证失败</li><li>客户端手动关闭</li><li>连接成功后，由于客户端的操作，导致 <code>Session</code> 过期，此时将重新进入 <code>CONNECTING</code>，在重新连接服务的过程中，连接失败，或者连接成功后，收到了 <code>Session</code> 过期的消息</li></ol><p>在<code>Zookeeper</code> 中的 <code>ClientCnxn</code> 用于负责客户端与服务器的连接、数据传输的相关操作，<code>Session</code> 的创建与关闭都将从该接口相关。</p><h3 id="1-_Session_的创建">1. <code>Session</code> 的创建</h3><p><code>ClientCnxn</code>的构建函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ClientCnxn(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper,</span><br><span class="line">        ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span><br><span class="line">        long sessionId, byte[] sessionPasswd, boolean canBeReadOnly) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    sendThread = new SendThread(clientCnxnSocket);</span><br><span class="line">    eventThread = new EventThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到会创建两个线程: <code>SendThread</code> 、<code>EventThread</code>，<code>SendThread</code> 用于负责与服务器的连接操作、心跳、数据传输，而 <code>EventThread</code> 负责处理事件。其<code>SendThread</code> 的 <code>run</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">clientCnxnSocket.introduce(this, sessionId, outgoingQueue);</span><br><span class="line">clientCnxnSocket.updateNow();</span><br><span class="line">clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">int to;</span><br><span class="line">long lastPingRwServer = Time.currentElapsedTime();</span><br><span class="line">final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds</span><br><span class="line">while (state.isAlive()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">// don&apos;t re-establish connection if we are closing</span><br><span class="line">if (closing) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">startConnect();</span><br><span class="line">clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        // ...</span><br><span class="line">&#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>startConnect</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void startConnect() throws IOException &#123;</span><br><span class="line">    // ... 获取地址等信息</span><br><span class="line">    clientCnxnSocket.connect(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只看 <code>ClientCnxnSocketNIO</code> 的实现，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void connect(InetSocketAddress addr) throws IOException &#123;</span><br><span class="line">    SocketChannel sock = createSock();</span><br><span class="line">    try &#123;</span><br><span class="line">       registerAndConnect(sock, addr);</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">        LOG.error(&quot;Unable to open socket to &quot; + addr);</span><br><span class="line">        sock.close();</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>registerAndConnect</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void registerAndConnect(SocketChannel sock, InetSocketAddress addr)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    boolean immediateConnect = sock.connect(addr);</span><br><span class="line">    if (immediateConnect) &#123;</span><br><span class="line">        sendThread.primeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>register</code> 是 <code>Java NIO</code> 中的 <code>Selector</code> 的相关操作；其 <code>primeConnection</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * Setup session, previous watches, authentication.</span><br><span class="line"> */</span><br><span class="line">void primeConnection() throws IOException &#123;</span><br><span class="line">long sessId = (seenRwServerBefore) ? sessionId : 0;</span><br><span class="line">    ConnectRequest conReq = new ConnectRequest(0, lastZxid,</span><br><span class="line">            sessionTimeout, sessId, sessionPasswd);</span><br><span class="line">// …… 针对 watch 和 auth 相关的处理</span><br><span class="line">    outgoingQueue.addFirst(new Packet(null, null, conReq,</span><br><span class="line">                    null, null, readOnly));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起了一个连接请求。接下来，我们来看看服务器收到请求后，是如何处理的。在 <code>Zookeeper</code> 中 <code>ZookeeperServer</code> 代表着服务器，在其中有这样一个函数: <code>processConnectRequest</code> ，通过其名字，能够发现，是用于处理客户端的连接的，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;</span><br><span class="line">    // ... 做校验</span><br><span class="line">    int sessionTimeout = connReq.getTimeOut();</span><br><span class="line">    byte passwd[] = connReq.getPasswd();</span><br><span class="line">    int minSessionTimeout = getMinSessionTimeout();</span><br><span class="line">    if (sessionTimeout &lt; minSessionTimeout) &#123;</span><br><span class="line">        sessionTimeout = minSessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSessionTimeout = getMaxSessionTimeout();</span><br><span class="line">    if (sessionTimeout &gt; maxSessionTimeout) &#123;</span><br><span class="line">        sessionTimeout = maxSessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">    cnxn.setSessionTimeout(sessionTimeout);</span><br><span class="line">    // We don&apos;t want to receive any packets until we are sure that the session is setup</span><br><span class="line">    cnxn.disableRecv();</span><br><span class="line">    long sessionId = connReq.getSessionId();</span><br><span class="line">    if (sessionId == 0) &#123;</span><br><span class="line">        LOG.info(&quot;Client attempting to establish new session at &quot;</span><br><span class="line">                + cnxn.getRemoteSocketAddress());</span><br><span class="line">        createSession(cnxn, passwd, sessionTimeout);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        long clientSessionId = connReq.getSessionId();</span><br><span class="line">        LOG.info(&quot;Client attempting to renew session 0x&quot;</span><br><span class="line">                + Long.toHexString(clientSessionId)</span><br><span class="line">                + &quot; at &quot; + cnxn.getRemoteSocketAddress());</span><br><span class="line">        if (serverCnxnFactory != null) &#123;</span><br><span class="line">            serverCnxnFactory.closeSession(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        if (secureServerCnxnFactory != null) &#123;</span><br><span class="line">            secureServerCnxnFactory.closeSession(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        cnxn.setSessionId(sessionId);</span><br><span class="line">        reopenSession(cnxn, sessionId, passwd, sessionTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>reopenSession</code> 与 <code>Session</code> 重连相关，在这里，我们只看 <code>createSession</code> 函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">long createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;</span><br><span class="line">    if (passwd == null) &#123;</span><br><span class="line">        // Possible since it&apos;s just deserialized from a packet on the wire.</span><br><span class="line">        passwd = new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">    long sessionId = sessionTracker.createSession(timeout);</span><br><span class="line">    Random r = new Random(sessionId ^ superSecret);</span><br><span class="line">    r.nextBytes(passwd);</span><br><span class="line">    ByteBuffer to = ByteBuffer.allocate(4);</span><br><span class="line">    to.putInt(timeout);</span><br><span class="line">    cnxn.setSessionId(sessionId);</span><br><span class="line">    Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);</span><br><span class="line">    setLocalSessionFlag(si);</span><br><span class="line">    submitRequest(si);</span><br><span class="line">    return sessionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>SessionTrackerImpl</code> 的 <code>createSession</code> 就创建了 <code>Session</code> ，而 <code>submitRequest</code> 则是将请求，提交到队列中，通过 <code>RequestProcessor</code> 去处理。在 <code>PrepRequestProcessor</code> 是该处理链的第一个，它是这样处理的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest(Request request) throws RequestProcessorException &#123;</span><br><span class="line">request.setHdr(null);</span><br><span class="line">request.setTxn(null);</span><br><span class="line">try &#123;</span><br><span class="line">switch (request.type) &#123;</span><br><span class="line">//create/close session don&apos;t require request record</span><br><span class="line">case OpCode.createSession:</span><br><span class="line">case OpCode.closeSession:</span><br><span class="line">if (!request.isLocalSession()) &#123;</span><br><span class="line">pRequest2Txn(request.type, zks.getNextZxid(), request,</span><br><span class="line"> null, true);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">request.zxid = zks.getZxid();</span><br><span class="line">nextProcessor.processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>pRequest2Txn</code> 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void pRequest2Txn(int type, long zxid, Request request,</span><br><span class="line">                                Record record, boolean deserialize)</span><br><span class="line">        throws KeeperException, IOException, RequestProcessorException</span><br><span class="line">&#123;</span><br><span class="line">request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid,</span><br><span class="line">Time.currentWallTime(), type));</span><br><span class="line"></span><br><span class="line">switch (type) &#123;</span><br><span class="line">case OpCode.createSession:</span><br><span class="line">request.request.rewind();</span><br><span class="line">int to = request.request.getInt();</span><br><span class="line">request.setTxn(new CreateSessionTxn(to));</span><br><span class="line">request.request.rewind();</span><br><span class="line">if (request.isLocalSession()) &#123;</span><br><span class="line">zks.sessionTracker.addSession(request.sessionId, to);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">zks.sessionTracker.addGlobalSession(request.sessionId, to);</span><br><span class="line">&#125;</span><br><span class="line">zks.setOwner(request.sessionId, request.getOwner());</span><br><span class="line">break;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个 创建<code>Session</code> 的请求，然后让 <code>nextProcessor</code> 去处理，而 <code>nextProcessor</code> 指的是 <code>SyncRequestProcessor</code>，其代码主要的逻辑是负责 <code>Request</code> 的序列化，或者做整个的 <code>DataTree</code> 与 <code>Session</code> 的快照。当 <code>SyncRequestProcessor</code> 处理完后，会由 <code>FinalRequestProcessor</code> 接着处理,其处理 <code>Session</code> 的主要的逻辑代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case OpCode.createSession: &#123;</span><br><span class="line">    zks.serverStats().updateLatency(request.createTime);</span><br><span class="line"></span><br><span class="line">    lastOp = &quot;SESS&quot;;</span><br><span class="line">    cnxn.updateStatsForResponse(request.cxid, request.zxid, lastOp,</span><br><span class="line">            request.createTime, Time.currentElapsedTime());</span><br><span class="line"></span><br><span class="line">    zks.finishSessionInit(request.cnxn, true);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>finishSessionInit</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void finishSessionInit(ServerCnxn cnxn, boolean valid) &#123;</span><br><span class="line">// cnxn 的 JMX 注册</span><br><span class="line">try &#123;</span><br><span class="line">ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout()</span><br><span class="line">: 0, valid ? cnxn.getSessionId() : 0, // send 0 if session is no</span><br><span class="line">// longer valid</span><br><span class="line">valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);</span><br><span class="line">// ... 创建 NIO buf</span><br><span class="line">cnxn.sendBuffer(bb);</span><br><span class="line">if (valid) &#123;</span><br><span class="line">LOG.info(&quot;Established session 0x&quot;</span><br><span class="line">+ Long.toHexString(cnxn.getSessionId())</span><br><span class="line">+ &quot; with negotiated timeout &quot; + cnxn.getSessionTimeout()</span><br><span class="line">+ &quot; for client &quot;</span><br><span class="line">+ cnxn.getRemoteSocketAddress());</span><br><span class="line">cnxn.enableRecv();</span><br><span class="line">&#125;</span><br><span class="line">        // ... else</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">LOG.warn(&quot;Exception while establishing session, closing&quot;, e);</span><br><span class="line">cnxn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码注意一下 <code>generatePasswd</code> 这个方法，这个是重连的关键。至此，服务器完成了对 <code>Session</code> 的创建。再看看，客户端当接受到 <code>ConnectResponse</code> 消息后，是如何处理的，具体逻辑在 <code>ClientCnxnSocketNIO</code> 中的<code>doIO</code> 逻辑中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void doIO(List&lt;Packet&gt; pendingQueue, ClientCnxn cnxn)</span><br><span class="line">      throws InterruptedException, IOException &#123;</span><br><span class="line">SocketChannel sock = (SocketChannel) sockKey.channel();</span><br><span class="line">if (sock == null) &#123;</span><br><span class="line">throw new IOException(&quot;Socket is null!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (sockKey.isReadable()) &#123;</span><br><span class="line">    // ...</span><br><span class="line">if (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">incomingBuffer.flip();</span><br><span class="line">if (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">recvCount++;</span><br><span class="line">readLength();</span><br><span class="line">&#125; else if (!initialized) &#123;</span><br><span class="line">readConnectResult();</span><br><span class="line">enableRead();</span><br><span class="line">// ...</span><br><span class="line">initialized = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键是 <code>readConnectResult</code> 的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void readConnectResult() throws IOException &#123;</span><br><span class="line">ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);</span><br><span class="line">BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);</span><br><span class="line">ConnectResponse conRsp = new ConnectResponse();</span><br><span class="line">conRsp.deserialize(bbia, &quot;connect&quot;);</span><br><span class="line">boolean isRO = false;</span><br><span class="line">try &#123;</span><br><span class="line">isRO = bbia.readBool(&quot;readOnly&quot;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">LOG.warn(&quot;Connected to an old server; r-o mode will be unavailable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">this.sessionId = conRsp.getSessionId();</span><br><span class="line">sendThread.onConnected(conRsp.getTimeOut(), this.sessionId,</span><br><span class="line">conRsp.getPasswd(), isRO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化连接的请求，并记录 <code>SessionId</code>，并调用 <code>onConnected</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void onConnected(int _negotiatedSessionTimeout, long _sessionId,</span><br><span class="line">byte[] _sessionPasswd, boolean isRO) throws IOException &#123;</span><br><span class="line">negotiatedSessionTimeout = _negotiatedSessionTimeout;</span><br><span class="line">// .. 协商 Session 超时时间</span><br><span class="line">readTimeout = negotiatedSessionTimeout * 2 / 3;</span><br><span class="line">connectTimeout = negotiatedSessionTimeout / hostProvider.size();</span><br><span class="line">hostProvider.onConnected();</span><br><span class="line">sessionId = _sessionId;</span><br><span class="line">sessionPasswd = _sessionPasswd;</span><br><span class="line">state = (isRO) ? States.CONNECTEDREADONLY : States.CONNECTED;</span><br><span class="line">seenRwServerBefore |= !isRO;</span><br><span class="line">KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;</span><br><span class="line">eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据得到的 <code>Session</code> 超时时间，初始化客户端的一些参数，并发起一个 <code>Watcher.Event.EventType.None</code> 的事件通知，表明连接成功。至此连接建立完成。同时在服务器创建了 <code>Session</code>。</p><h3 id="2-_Session_的关闭">2. Session 的关闭</h3><p>在 <code>zookeeper</code> 的 <code>close</code> 方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        RequestHeader h = new RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.closeSession);</span><br><span class="line">        submitRequest(h, null, null, null);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // ignore, close the send/event threads</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起了一个关闭的请求，我们在 <code>PrepRequestProcessor</code> 的 <code>pRequest2Txn</code> 方法中能看到相应的处理操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">case OpCode.closeSession:</span><br><span class="line">    Set&lt;String&gt; es = zks.getZKDatabase().getEphemerals(request.sessionId);</span><br><span class="line">    synchronized (zks.outstandingChanges) &#123;</span><br><span class="line">        for (ChangeRecord c : zks.outstandingChanges) &#123;</span><br><span class="line">            if (c.stat == null) &#123;</span><br><span class="line">                // Doing a delete</span><br><span class="line">                es.remove(c.path);</span><br><span class="line">            &#125; else if (c.stat.getEphemeralOwner() == request.sessionId) &#123;</span><br><span class="line">                es.add(c.path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String path2Delete : es) &#123;</span><br><span class="line">            addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));</span><br><span class="line">        &#125;</span><br><span class="line">        zks.sessionTracker.setSessionClosing(request.sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG.info(&quot;Processed session termination for sessionid: 0x&quot;</span><br><span class="line">            + Long.toHexString(request.sessionId));</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>会将相应的 <code>Session</code> 的 <code>isClosing</code> 属性设置为 <code>true</code>。接下来将由 <code>SessionExpire</code> 去处理，我们只需要去看 <code>ZookeeperServer</code> 中的处理即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void expire(Session session) &#123;</span><br><span class="line">    long sessionId = session.getSessionId();</span><br><span class="line">    LOG.info(&quot;Expiring session 0x&quot; + Long.toHexString(sessionId)</span><br><span class="line">            + &quot;, timeout of &quot; + session.getTimeout() + &quot;ms exceeded&quot;);</span><br><span class="line">    close(sessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>close</code> 函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void close(long sessionId) &#123;</span><br><span class="line">    Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);</span><br><span class="line">    setLocalSessionFlag(si);</span><br><span class="line">    submitRequest(si);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又会重新走一次上面的流程，但是不一样的在 <code>SyncRequestProcessor</code> 的 <code>queuedRequests</code> 将又会多一条的数据，因为 <code>SyncRequestProcessor</code> 其本身也是 <code>Thread</code> ，在其 <code>run</code> 有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Request si = null;</span><br><span class="line">if (toFlush.isEmpty()) &#123;</span><br><span class="line">    si = queuedRequests.take();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    si = queuedRequests.poll();</span><br><span class="line">    if (si == null) &#123;</span><br><span class="line">        flush(toFlush);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会调用其 <code>fluash</code> 方法，其代码中有如下的代码段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request i = toFlush.remove();</span><br><span class="line">if (nextProcessor != null) &#123;</span><br><span class="line">    nextProcessor.processRequest(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会调用 <code>FinalRequestProcessor</code> 的 <code>processRequest</code> 方法，最终会调用到 <code>ZookeeperServer</code> 中的 <code>processTxn</code> 函数，其关键代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionTracker.removeSession(sessionId);</span><br></pre></td></tr></table></figure><p>会调用 <code>SessionTrackerImpl</code> 中的 <code>removeSession</code>，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized public void removeSession(long sessionId) &#123;</span><br><span class="line">    SessionImpl s = sessionsById.remove(sessionId);</span><br><span class="line">    sessionsWithTimeout.remove(sessionId);</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        sessionExpiryQueue.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从内存中移除对应的 <code>Session</code> ，并调用 <code>ExpiryQueue</code> 中的 <code>remove</code> 方法，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Long remove(E elem) &#123;</span><br><span class="line">    Long expiryTime = elemMap.remove(elem);</span><br><span class="line">    if (expiryTime != null) &#123;</span><br><span class="line">        Set&lt;E&gt; set = expiryMap.get(expiryTime);</span><br><span class="line">        if (set != null) &#123;</span><br><span class="line">            set.remove(elem);</span><br><span class="line">            // We don&apos;t need to worry about removing empty sets,</span><br><span class="line">            // they&apos;ll eventually be removed when they expire.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return expiryTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;在对 &lt;code&gt;Zookeeper&lt;/code&gt; 的使用过程中，经常会用到临时节点，而临时节点与 &lt;code&gt;Session&lt;/code&gt; 相关，那么 &lt;code&gt;Session&lt;/code&gt; 在 &lt;code&gt;Zookee
      
    
    </summary>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/categories/Zookeeper/"/>
    
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper/"/>
    <id>https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_Zookeeper介绍">0. Zookeeper介绍</h3><p>Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务。其维护了一个类似Linux文件系统，但比它更简单，支持分布式的文件系统，能够保证对于节点的操作具有原子性，并且能够保证集群中所有服务器都具有相同的数据。有如下优点:</p><ol><li>原子性<br>更新只能成功或者失败，没有中间状态</li><li>顺序性<br>包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面</li><li>最终一致性(单系统镜像)<br>Client不论连接到哪个Server，都能看到完全一致的数据</li><li>等待无关<br>慢的或者失效的Client不得干预快速的Client的请求，使得每个Client都能有效的等待</li><li>可靠性<br>具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受</li><li>实时性<br>Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</li></ol><p>主要使用Zookeeper完成命名服务、配置管理、同步、组服务。使用的 <strong>ZAB(ZooKeeper Atomic Broadcast)协议</strong> 作为其数据一致性的算法。其最大的特性就是数据复制，具有如下的优势:</p><ol><li>容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作</li><li>提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力</li><li>提高性能<br>让客户端本地访问就近的节点，提高用户访问速度</li></ol><h3 id="1-_基本概念">1. 基本概念</h3><ul><li>事务<br>Client发出的每一个操作数据的请求，都会包装成一个事务，用 ZXID 唯一标识事务。</li><li>ZXID<br>是64位的数字，高32位代表Leader周期的 epoch 编号，而低32位是一个简单递增的计数器。ZAB 使用 epoch 来区分不同的 Leader 周期</li><li><p>Znode<br>对于文件系统中的每一个层次，称为一个节点。节点能够存储数据，和一些额外的数据:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid: 创建时的事务</span><br><span class="line">   ctime: 创建时间</span><br><span class="line">   mZxid: 修改时的事务</span><br><span class="line">   mtime: 修改时间</span><br><span class="line">   pZxid: 子节点最后一次修改的事务</span><br><span class="line">   cversion: 子节点的修改版本号记录，子节点每修改一次，增加1</span><br><span class="line">   dataVersion： 当前节点的数据的修改记录，每修改一次，增加1</span><br><span class="line">   aclVersion: 用于控制节点的权限</span><br><span class="line">   ephemeralOwner: 如果是临时节点，则记录session id，否则为0</span><br><span class="line">   dataLength: 数据长度</span><br><span class="line">   numChildren: 子节点的个数</span><br></pre></td></tr></table></figure><p>  节点分为四类：<code>PERSISTENT</code>， <code>PERSISTENT_SEQUENTIAL</code>， <code>EPHEMERAL</code>， <code>EPHEMERAL_SEQUENTIAL</code>， 临时指的是Session关闭时，节点将会删除，持久是指是否可以持久化，顺序指的是创建的节点会根据创建时间进行编号，后创建的编号越大，编号一般都跟在名字后面。</p></li><li>Watch<br>客户端能够针对节点添加监听器，当节点改变后，会触发watch，然后会清除watch，即watch是一次性的，而且watch能够保证事件的顺序性。watch分为两类，数据监听器和子节点监听器。</li><li>Session<br>客户端和服务端建立连接后，会话随之建立，生成一个全局唯一的会话ID(Session ID)，服务器与客户端建立TCP长连接。</li><li>ACL<br>Access Controller List，用于控制对于节点的访问，类似于unix中的<code>allow/disallow</code></li></ul><h3 id="2-_常量">2. 常量</h3><ol><li>当节点的类型为<code>PERSISTENT_SEQUENTIAL</code>, <code>EPHEMERAL_SEQUENTIAL</code>，序号从<strong>0000000001 ~ 2147483647</strong>，格式为<code>%10d</code></li><li>节点数据不能超过 1M</li><li>最多接受来自服务器的数据大小为 4M</li><li>默认的session的过期时间，2 ~ 20 个 tickTime</li></ol><h3 id="3-_常见的使用场景">3. 常见的使用场景</h3><ol><li>命名服务<br>Zookeeper 提供了一套简单的文件系统，当在同一个路径下再次创建节点时，会出错，就能保证每一个路径的唯一性。而命名服务，需要保证每一个名字的唯一性，可以通过文件系统路径的唯一性去保证。</li><li>配置管理<br>将一些小的配置放到 Zookeeper 上，因为每个 Zookeeper 服务器所看到的数据都是一致的，并且能够一致更新，从而达到动态配置的目的。</li><li><p>同步<br>利用 Zookeeper 实现分布式锁。其实现锁有以下几种方式:</p><ol><li>利用节点名称的唯一性来实现共享锁<br>在同一个路径下去同时去创建节点，谁创建成功，则获得锁，使用完后，再删除节点；否则就监听该节点，当删除时，再次去尝试创建。利用 Zookeeper 操作的原子性。如果该节点下的 watcher 很多的话，当释放锁时，会有很多线程同时去创建锁，效率不高。</li><li>利用临时顺序节点实现共享锁的一般做法<br>首先创建一个节点(例如 /distribute_lock)，所有客户端在它下面创建临时顺序 (EPHEMERAL_SEQUENTIAL) 节点，例如(/distribute_lock/guid-lock-)，同时在这个节点上注册上子节点变更通知的 Watcher，客户端调用 getChildren(“/distribute_lock”)，如果发现自己创建的节点的序号最小，则获得锁，否则就等待锁被释放，然后每一次变更都比较一下，自己的序号是否为最小。如果子节点很多的话，会有很多无用的 watch 事件。</li><li>利用临时顺序节点实现共享锁的改进实现<br>与方法二类似，只是在 watch 时，只关注节点顺序比自己小 1 的节点的事件。</li></ol></li><li>组服务<br>主要体现在于 Zookeeper 对集群的管理，而对集群的管理，主要需要解决如下两个问题:<ol><li>动态观察是否有服务器退出和加入集群<br>在一个约定目录下，创建临时节点，并且监听该目录的变化，如果掉线，则节点会被删除，那么同时，其它服务器会收到其宕机的消息。</li><li>选举master<br>同样在一个约定目录下，创建临时有序节点，每次选取编号最小的机器作为master就好。</li></ol></li><li>队列管理<ol><li>Barrier: 当一个队列的成员都聚齐时，这个队列才可用，否则一直等待<br>在约定目录下创建临时目录节点，监听目录节点数是否和我们要求的数目一致</li><li>队列按照 FIFO 方式进行入队和出队的操作<br>在约定上当下创建临时顺序目录节点，出队按编号最小的原则出队</li></ol></li></ol><h3 id="4-_ZAB协议">4. ZAB协议</h3><p>ZAB协议是作为Zookeeper一致性复制的核心。除了保证数据一致性之外，还需要满足以下的两个安全属性:</p><ol><li>全序<br>Total Order, 如果消息a 在消息b 之前发送，则所有 Server 应该看到相同的结果</li><li>因果顺序<br>Causal Order, 如果消息a 在消息b 之前发生，并被一起发送，则a始终在b之前被执行</li></ol><p>在ZAB协议中使用了TCP协议和Leader机制。通过TCP协议保证了消息的全序特性，利用Leader机制保证了因果顺序。因为所有的操作数据的操作都将通过TCP协议发给Leader，而Leader只有一个。整个ZAB协议分成四个阶段: 选举(election)、发现(discovery)、同步(sync)、广播(Broadcast)。通常根据状态分为崩溃恢复模式和消息广播模式。ZAB协议中存在三种状态: Looking(处于选举状态)、Following(当前节点是跟随者)、Leading(当前节点是 Leader， 负责协调事务)。</p><h4 id="4-1_崩溃恢复模式">4.1 崩溃恢复模式</h4><ol><li><p>选举<br>必须确保选出的 Leader 具有最高的 ZXID 。选举流程如下:</p><ol><li>每个 Follower 都向其他节点发送选自身成为 Leader 的投票请求，并带上自己最新的 ZXID；</li><li>Follower 接受到的 ZXID 如果比自身的大时则投票，并记录，否则拒绝投票；</li><li>每个 Follower 中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该 Follower 选为 Leader；</li></ol></li><li><p>发现<br>当选出最新的 Leader 后，Leader 将生成新的 epoch，让 Follower 接受最新的 acceptedEpoch。并且接收 Follower 发过来的 FOLLOWERINFO (含有当前节点的最新的 ZXID)，发现大多数节点接收的最新提议。</p></li><li><p>同步<br>Leader 利用前一阶段获得的最新提交记录，与 Follower 同步数据。同步策略如下:</p><ol><li>SNAP<br>如果 Follower 数据太老， Leader 将发送快照 SNAP 指令给 Follower 同步数据</li><li>DIFF<br>Leader 发送从 Follower 的 LastZXID 到 Leader 的 LastZXID 的 DIFF 指令给 Follower，以同步数据。</li><li>TRUNC<br>当 Follower 的 LastZXID 比 Leader 的 LastZXID 大时，Leader 发送从 Leader 的 LastZXID 到 Follower 的 LastZXID 的 Trunc 指令，让 Follower 丢弃该段数据</li></ol><p>SNAP 与 DIFF 指令用于保证集群中的 Follower 节点与已经 Committed 数据一致， TRUNC 用于抛弃已经被处理但是没有 Committed 的数据。当集群中大多数 Follower 同步成功后，再会真正成为 Leader。</p></li><li><p>ZAB崩溃恢复的策略:</p><ol><li>ZAB协议需要确保那些已经在 Leader 服务器上提交的事务最终被所有服务器都提交<br>假设一个事务在 Leader 服务器上被提交了，并且已经得到了过半 Follower 服务器的 Ack 反馈，此时 Leader 已经提交，但是在它将 Commit 消息发送给所有 Follower 机器之前，Leader 服务器挂了，恢复过程中则需要恢复该操作日志</li><li>ZAB 协议将丢弃那些只在 Leader 服务器上被提出的事务。<br>假设初始的 Leader 服务器 Server 在提出一个事务之后，还没有给 Follower 发送请求，希望得到 Ack 之前，挂了,则要丢弃该事务</li></ol></li></ol><h4 id="4-2_消息广播模式">4.2 消息广播模式</h4><ol><li>Leader 服务器会为事务请求生成一个全局唯一递增的事务ID（即ZXID），保证每个消息的因果关系的顺序。</li><li>Leader 服务器会为该事务生成对应的 Proposal，进行广播。</li><li>Leader 服务器会为每一个 Follower 服务器都各自分配一个单独的队列，将需要广播的事务 Proposal 依次放入这些队列中去，并根据 FIFO 策略进行消息发送。</li><li>每一个 Follower 服务器在接收到这个事务 Proposal 之后，首先以日志形式写入本地磁盘，并且成功写入后反馈给 Leader 服务器一个 Ack 响应</li><li>当 Leader 服务器接收超过半数的 Follower 的 Ack 响应，Leader 自身也会完成对事务的提交。同时就会广播一个 Commit 消息给所有的Follower 服务器以通知进行事务提交。每一个 Follower 服务器在接收到 Commit 消息后，也会完成对事务的提交。</li></ol><p>消息广播过程中使用了 TCP 协议进行通讯所有保证了接受和发送事务的顺序性。</p><h3 id="5-_常见问题">5. 常见问题</h3><ul><li><p>为什么要限制ZooKeeper中ZNode的大小？<br>ZooKeeper 是一套高吞吐量的系统，为了提高系统的读取速度，ZooKeeper 不允许从文件中读取需要的数据，而是直接从内存中查找。换句话说，ZooKeeper 集群中每一台服务器都包含全量的数据，并且这些数据都会加载到内存中。同时 ZNode 的数据不支持 Append 操作，全部都是Replace。所以从上面分析可以看出，如果 ZNode 过大，那么读写某一个 ZNode 将造成不确定的延时; 同时 ZNode 过大，将过快地耗尽ZooKeeper 服务器的内存。</p></li><li><p>ZAB 与 Paxos 的关系与区别<br>ZAB 与 Paxos 算法一样都是一致性算法，而 ZAB 同时解决了全序与因果顺序的问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_Zookeeper介绍&quot;&gt;0. Zookeeper介绍&lt;/h3&gt;&lt;p&gt;Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务。其维护了一个类似Linux文件系统，但比它更简单，支持分布式的文件系统，能够保证对于节点的操作具有原子性，并且能够保证集
      
    
    </summary>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper-01-简介</title>
    <link href="https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper-01-%E7%AE%80%E4%BB%8B/"/>
    <id>https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper-01-简介/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。其通过一个类似于文件目录的树形文件系统，可以对外提供配置维护、分布式同步、组服务、域名服务。Zookeeper具有如下特点:</p><ol><li>简单<br>只需要类似于文件系统的操作，就可以完成分布式环境下程序的协调，不能不说，其操作是简单的</li><li>镜像服务<br><code>Zookeeper</code> 会保证在所有的服务器所存储的数据都是一样的</li><li>有序的<br><code>Zookeeper</code> 会通过事务ID去标记每一次的更新操作</li><li>快速的<br>在读多写少的情况下，效率最高，读写效率为 <code>10 : 1</code></li></ol><p>主要涉及如下的概念:</p><ol><li><p>节点<br><code>Zookeeper</code> 提供一种类似于文件系统的树形结构，该树形结构上每一个点，被称为节点。节点有如下几类:</p><ol><li><code>PERSISTENT</code><br>持久化非顺序的节点</li><li><code>PERSISTENT_SEQUENTIAL</code><br>持久化并且顺序的节点</li><li><code>EPHEMERAL</code><br>临时非顺序节点</li><li><code>EPHEMERAL_SEQUENTIAL</code><br>临时并且顺序的节点</li></ol><p>在上面提出两个概念 <strong>持久化</strong> 和 <strong>顺序</strong>，<strong>持久化</strong> 是指当创建操作成功后，无论服务器是否重启，该结点都将存在。<strong>临时</strong> 是相对 <strong>持久</strong> 而言的，是指创建的结点的生命周期与 <code>Session</code> 的生命周期一致，即当关闭 <code>Session</code> 后，该节点也将被删除；<strong>顺序</strong> 是指在创建该结点时，是否会在节点后面添加一个最大值为 <code>2147483647</code> 并且固定为 <code>10</code> 位的顺序号，顺序号的大小，表明了该节点的创建时间与其它节点的创建时间上的先后。即如果顺序号小，但是表明是先被创建的。</p></li><li><code>Watch</code><br>用于监听节点的变化</li><li><code>ACL</code><br>权限控制</li><li><code>Session</code><br>每一个连接到 <code>Zookeeper</code> 服务的客户端，系统都将为其创建一个 <code>Session</code>。</li></ol><h3 id="1-_源码的目录结构">1. 源码的目录结构</h3><p>先大概的说一下源码的编译方式吧:</p><ol><li>下载 <code>apache ant</code>，并将它添加进环境变量里</li><li>下载源码，在源码所在目录下运行 <code>ant eclipse</code></li><li><code>intellij idea -&gt; New -&gt; Project from Existing Sources -&gt; eclipse</code>，然后一直下一步</li><li>在 <code>ZooKeeperServerMain</code> 这个类，<code>Ctrl + Shift + F10</code>，然后关闭</li><li>编辑 <code>Run/Debug Configurations</code>， 在 <code>Program arguments</code> 中填入 <code>2180 ~/workstation/temp/zk-data</code> （路径自己定义）</li><li>然后，你再去一个编译好了的 <code>Zookeeper</code> ，然后在其的 <code>bin</code> 目录下，运行 <code>zkCli.sh -server 127.0.0.1:2180</code>，如果能正常显示，说明编译成功</li></ol><p>目录结构如下:</p><center><img src="/pics/Zookeeper-Sources.png" alt=""></center><ul><li>bin<br>一些脚本</li><li>conf<br>配置文件</li><li>docs<br>文档说明</li><li>src<br>在该目录下，只关注 <code>java</code> 与 <code>recipes</code> 目录，<code>java</code> 目录并没有什么好解释的，只需要关注 <code>generated</code> 是通过代码生成的 <code>java</code> 代码；<code>recipes</code> 是 <code>Zookeeper</code> 提供的一些高级功能，例如： 利用 <code>Zookeeper</code> 实现锁、<code>Queue</code>、<code>Election</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。其通过一个类似于文件目录的树形文件系统，可以对外提供配置维护、分布式同步、组服务、域名服务。Zookeeper具有如下特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单
      
    
    </summary>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/categories/Zookeeper/"/>
    
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://coolwcan.cn/Tools/Tools/Vim/"/>
    <id>https://coolwcan.cn/Tools/Tools/Vim/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_Vim复制数据到剪切板">1. Vim复制数据到剪切板</h3><ol><li>安装vim-gui-commom<br><code>sudo apt-get install vim-gui-common</code></li><li><p>使用命令<br>在普通模式下，输入三个字符 <code>&quot;+y</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;，表示使用的是寄存器</span><br><span class="line">2. +，表示系统的剪切板</span><br><span class="line">3. y，复制</span><br></pre></td></tr></table></figure><p>可以通过 <code>:reg</code> 命令，查看所有的寄存器数据</p></li></ol><h3 id="2-_Vim的插件管理工具—-Bundle">2. Vim的插件管理工具—-Bundle</h3><p>安装过程如下:</p><ol><li>从github上down下Vundle，地址：<a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="noopener">https://github.com/gmarik/Vundle.vim</a></li><li>放在vimfiles文件的bundle目录下</li><li><p>在_vimrc文件中，加入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">filetype off</span><br><span class="line"> </span><br><span class="line">set rtp+=D:\Tools\Vim\vimfiles\bundle\Vundle.vim  #你下载的vundle的位置，目录名为Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line"> </span><br><span class="line">Plugin &apos;gmarik/Vundle.vim&apos;  &quot;Vundle插件</span><br><span class="line">...其它插件</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure></li></ol><p>安装插件时，在vundle中的格式如下:</p><ol><li>代码在github上,使用github帐号/项目名，例如: <code>Bundle &#39;tpope/vim-fugitive&#39;</code> 可以直接通过加上<code>https://github.com/tpope/vim-fugitive</code>进行访问</li><li>“代码在vimscript上，使用插件名称，插件名字可以在<code>http://vim-scripts.org/vim/scripts.html</code>页面中查找，例如: <code>Bundle &#39;vimwiki&#39;</code></li></ol><p>常用的命令如下:</p><ol><li>BundleInstall， 安装所有的在文件中配置了的插件</li><li>BundleSearch，搜索某个插件</li><li>BundleClean, 删除之前下载过，但是现在不使用的插件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_Vim复制数据到剪切板&quot;&gt;1. Vim复制数据到剪切板&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装vim-gui-commom&lt;br&gt;&lt;code&gt;sudo apt-get install vim-gui-common&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用命令&lt;br
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Vim" scheme="https://coolwcan.cn/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Chrome</title>
    <link href="https://coolwcan.cn/Tools/Tools/Chrome/"/>
    <id>https://coolwcan.cn/Tools/Tools/Chrome/</id>
    <published>2019-03-12T05:48:38.588Z</published>
    <updated>2019-03-12T05:48:38.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_无法安装插件">1. 无法安装插件</h3><ul><li>问题<br>给Chrome安装插件时，提示“只能通过Chrome网上应用店添加该程序。”</li><li>解决方案<ul><li>把下载后的.crx扩展名的离线Chrome插件的文件扩展名改成为.zip或者.rar，然后解压</li><li>将文件夹下的”_metadata”文件夹签名为“metadata”</li><li>然后在Chrome的扩展程序下，开启“开发者模式”</li><li>选择“加载正在开发的扩展程序”</li></ul></li></ul><p>不能删除解压后的目录，否则，下次启动Chrome时，插件就消失了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_无法安装插件&quot;&gt;1. 无法安装插件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;问题&lt;br&gt;给Chrome安装插件时，提示“只能通过Chrome网上应用店添加该程序。”&lt;/li&gt;
&lt;li&gt;解决方案&lt;ul&gt;
&lt;li&gt;把下载后的.crx扩展名的离线Chrome插件的文件扩展名改成
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Chrome" scheme="https://coolwcan.cn/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://coolwcan.cn/Tools/Tools/Git/"/>
    <id>https://coolwcan.cn/Tools/Tools/Git/</id>
    <published>2019-03-12T05:48:38.588Z</published>
    <updated>2019-03-12T05:48:38.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_Git术语">0. Git术语</h3><ul><li>Head<br>指向当前活跃分支</li><li>origin<br>是默的远程版本库的代称</li><li>工作区<br>指在某目录下的所有操作，都将被记录或者感知</li><li>暂存区<br>stage或者index，用于记录此时的工作目录与上次的提交之间的更改</li></ul><h3 id="1-_Git中文乱码">1. Git中文乱码</h3><p><code>git config --global core.quotepath false</code></p><h3 id="2-_配置快捷方式">2. 配置快捷方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status   // st 就代表 status</span><br><span class="line">git config --global alias.ci commit   // st 就代表 commit</span><br></pre></td></tr></table></figure><h3 id="3-_git_revert_与_git_reset_区别">3. git revert 与 git reset 区别</h3><ul><li><p>git revert</p><p>通过生成一个新的提交来撤销之前的提交，但是之前的commit会被保留</p></li><li><p>git reset</p><p>回到某一次commit，该commit之后的commit会被放到暂存区或者直接删除，取决于模式，有如下模式:</p><ul><li><code>hard</code>: 强行把当前的head指针指向某一次的commit，并且之后的commit会清空（仅在本地）</li><li><code>soft</code>: 把当前的head指针指向某一次的commit，并把之后的commit放入到暂存区</li></ul></li></ul><h3 id="4-_fast_foward_VS_no_fast_foward">4. fast foward VS no fast foward</h3><p>通常合并会产生一个 <code>merge commit</code>，但是决不绝对的，取决于不同的merge模式，有如下两种模式:</p><ul><li><code>fast foward</code>: 在没有任何的冲突时， 将不会产生 <code>merge commit</code></li><li><code>no fast foward</code>: 无论什么情况都会生成 <code>merge commit</code></li></ul><p><code>git merge</code> 默认是 <code>fast foward</code>，如果需要<code>no fast foward</code>的话，则需要加上 <code>--no-ff</code></p><h3 id="5-_git_merge_与_git_rebase的区别及其使用场景">5. git merge 与 git rebase的区别及其使用场景</h3><p>区别:</p><ol><li><code>git merge</code> 会创建一个<code>merge commit</code>，并且分别指向合并前的两个分支</li><li><code>git rebase</code> 不会创建一个 <code>merge commit</code>, 而是将两个分支的提交合并成一个线性的提交；其原理是先将一个分支相对于另一个分支所有提交缓存，然后将其更新到最新，然后再应用这缓存中的提交</li></ol><p><code>git rebase</code> 有一个黄金规则，即不能 <code>rebase</code> 一个公共的分支，会导致分支混乱，所以 <code>git rebase</code> 通常用在仅仅由某一个人开发的分支上，<code>git merge</code>用在共享分支上。</p><p><a href="https://segmentfault.com/a/1190000005937408" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005937408</a> 对此有详细的解释</p><h3 id="6-_git生成密钥">6. git生成密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@xx.com&quot;</span><br></pre></td></tr></table></figure><p>然后连续输入三个空格就好</p><h3 id="7-_-ignore文件的语法规则">7. <code>.ignore</code>文件的语法规则</h3><ul><li>空行和以 <code>＃</code> 开始行会被忽略</li><li>可使用通配符<ul><li><code>*</code>，代表任意多个字符</li><li><code>?</code>，代表一个字符</li><li>方括号 ([abc])，代表可选字符范围</li><li>大括号（{string1,string2,…}）代表可选的字符串</li></ul></li><li>名称前有一个感叹号(!)，表示例外规则，将不被忽略</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ul><p>常用的例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释行，将被忽略</span><br><span class="line">*.a       # 忽略所有以.a为扩展名的文件    </span><br><span class="line">!lib.a    # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略</span><br><span class="line">/TODO     # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略</span><br><span class="line">build/    # 忽略所有build目录下的目录，但如果是名为build的文件则不忽略</span><br><span class="line">doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略</span><br></pre></td></tr></table></figure><h3 id="8-_Git多帐户ssh登陆">8. Git多帐户ssh登陆</h3><p>问题:</p><p>在实际情况，会遇到这样的问题，假如我有两个帐号，分别是 github， coding的帐号，而且这两个帐号都有自己的公钥和私钥，而默认情况下 <code>ssh</code> 命令只会去读 <code>.ssh</code> 目录下的 <code>id_rsa</code> 这个私钥，但是我们现在有两个私钥。所以我们期望能够自动识别服务器地址，然后选择相应的私钥文件。</p><p>方案:</p><p>在 <code>~/.ssh/config</code>进行配置，没有的话新建一个格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host 名称</span><br><span class="line">HostName 主机名</span><br><span class="line">User 登录的用户名</span><br><span class="line">IdentityFile 证书文件路径</span><br></pre></td></tr></table></figure><p>其它字段，可以通过<code>man ssh_config</code>来查看</p><h3 id="9-_Git的cherry-pick">9. Git的<code>cherry-pick</code></h3><p>用于将另一个分支的部分<code>commit</code>合并到当前分支。命令如下:</p><p><code>git cherry-pick hash</code>，此处的<code>hash</code>为另一个分支的<code>commit</code>的<code>hash</code>值。</p><h3 id="10-_Git的bisect">10. Git的<code>bisect</code></h3><p>用于快速定位异常的<code>commit</code>。</p><p>场景:</p><p>假如有1，2，3，4这4个提交，此时你发现项目运行不起来，但是需要定位是哪一个commit导致的系统异常，此时可以用<code>bisect</code>，它采用一种二分搜索的方式去搜索。例如commit4不能运行，那就将commit4设置为<code>bad</code>，假设我回滚到commit1后，项目可以运行，那么就将commit1设置为<code>good</code>，针对1～4之间的提交，采用二分搜索的方式，能够准确定位。</p><p>其命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开始</span><br><span class="line">git bisect start</span><br><span class="line"></span><br><span class="line"># 标记当前Head所指向的提交，是错误的</span><br><span class="line">git bisect bad</span><br><span class="line"></span><br><span class="line"># 将某一个提交设置成good，一般在初始化时，需要设置</span><br><span class="line">git bisect good your_commit_hash</span><br><span class="line"></span><br><span class="line"># 标记当前Head所指向的提交，是正常的</span><br><span class="line">git bisect good</span><br><span class="line"></span><br><span class="line"># 结束，并且将Head指向最新提交</span><br><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>首先须要执行<code>start</code>命令，再执行<code>bad</code>和<code>good</code>命令，最后如果找出异常的commit，则<code>reset</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_Git术语&quot;&gt;0. Git术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Head&lt;br&gt;指向当前活跃分支&lt;/li&gt;
&lt;li&gt;origin&lt;br&gt;是默的远程版本库的代称&lt;/li&gt;
&lt;li&gt;工作区&lt;br&gt;指在某目录下的所有操作，都将被记录或者感知&lt;/li&gt;
&lt;li&gt;暂存区&lt;b
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Git" scheme="https://coolwcan.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Idea</title>
    <link href="https://coolwcan.cn/Tools/Tools/Intellij-Idea/"/>
    <id>https://coolwcan.cn/Tools/Tools/Intellij-Idea/</id>
    <published>2019-03-12T05:48:38.588Z</published>
    <updated>2019-03-12T05:48:38.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_设置编码格式">1. 设置编码格式</h3><ul><li>设置IDE编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; IDE Encoding， 设置成UTF-8</li><li>设置Project编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; Project Encoding， 设置成UTF-8</li><li>设置properties编码格式<br>Intellij Idea –&gt; Settings –&gt; Editor –&gt; File Encodings –&gt; <code>Default encoding for properties files</code>， 设置成GB2312</li><li>安装中文字体<ul><li><code>下载SimSun字体</code></li><li><code>sudo mv simsun.ttc simsun.ttf /usr/share/fonts/zh_CN/TrueType/simsun</code></li><li><code>sudo fc-cache -fv</code></li></ul></li></ul><h3 id="2-_取消单行的fold">2. 取消单行的fold</h3><ul><li>Settings –&gt; Editor –&gt; Code Folding –&gt; One-Line methods</li><li>取消选择</li></ul><h3 id="3-_给Intellij_IDE_添加_serialVersionUID">3. 给Intellij IDE 添加 serialVersionUID</h3><ol><li><code>Setting -&gt; Inspections -&gt; Serialization issues -&gt; 勾上 Serializable class without ’serialVersionUID’</code></li><li>将光标定位到类名上，按 <code>Alt + Enter</code> 就会提示自动创建 serialVersionUID</li></ol><h3 id="4-_让Intellij_idea_支持_lua">4. 让Intellij idea 支持 lua</h3><p>下载 <code>https://plugins.jetbrains.com/plugin/5055-lua</code> ，然后从磁盘安装插件</p><h3 id="5-_Linux_下_Intellij_idea_提示_Unable_to_open_debugger_port">5. Linux 下 Intellij idea 提示 <code>Unable to open debugger port</code></h3><p>提示: <code>Unable to open debugger port : java.net.SocketException “Socket closed”</code><br>方案: 将 <code>TOMCAT</code> 的 <code>Bin</code> 目录里面的所有的 <code>.sh</code> 添加执行权限，<code>sudo chmod +x *.sh</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_设置编码格式&quot;&gt;1. 设置编码格式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;设置IDE编码格式&lt;br&gt;Intellij Idea –&amp;gt; Settings –&amp;gt; Editor –&amp;gt; File Encodings –&amp;gt; IDE Encoding， 设置
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Intellij Idea" scheme="https://coolwcan.cn/tags/Intellij-Idea/"/>
    
  </entry>
  
  <entry>
    <title>MAC配置及问题修复</title>
    <link href="https://coolwcan.cn/Tools/Tools/MAC%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
    <id>https://coolwcan.cn/Tools/Tools/MAC配置及问题修复/</id>
    <published>2019-03-12T05:48:38.588Z</published>
    <updated>2019-03-18T02:42:55.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_mac安装brew">1. mac安装brew</h3><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p><h3 id="2-_mac安装lrzsz">2. mac安装lrzsz</h3><ol><li><code>brew install lrzsz</code></li><li><code>git clone https://github.com/mmastrac/iterm2-zmodem</code></li><li>将 <code>iterm2-zmodem</code> 中的 <code>iterm2-send-zmodem.sh</code> 和 <code>iterm2-recv-zmodem.sh</code> 放到 <code>/usr/local/bin</code> 路径下，并为其添加执行权限 <code>sudo chmod +x iterm2*.sh</code></li><li><p>打开item2的 <code>Preferences</code> -&gt; <code>Profiles</code> 选项卡 -&gt; <code>Advanced</code> -&gt; <code>Triggers</code> ，点击 <code>Edit</code><br>添加两个选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t1:</span><br><span class="line">Regular expression: \*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">t2:</span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">arameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><p><code>Regular expression</code> 、 <code>Action</code> 、 <code>Parameters</code> 为列名，注意与页面对应</p></li></ol><h3 id="3-_Mac_安装软件时，提示已损坏解决">3. Mac 安装软件时，提示已损坏解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><h3 id="4-_iTerm2的常用配置">4. iTerm2的常用配置</h3><ol><li><p>安装Oh my zsh<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装<code>PowerLine</code><br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">pip install powerline-status --user</span><br></pre></td></tr></table></figure></li><li><p>安装PowerFonts<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/powerline/fonts.git --depth=1</span><br><span class="line">cd fonts</span><br><span class="line"></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure><p> 然后选择<code>Meslo LG S for Powerline</code>字体</p></li><li><p>切换到主题<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译~/.zshrc，ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装高亮插件<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><pre><code>将<span class="escape">`z</span>sh-syntax-highlighting<span class="escape">`，</span>放在<span class="escape">`p</span>lugins<span class="escape">`的</span>最后</code></pre><ol start="6"><li><p>安装命令补全<br></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions</span><br><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p> 将<code>zsh-autosuggestions</code>放在<code>zshrc</code>的<code>plugins</code>选项的倒数第二个</p></li></ol><h3 id="5-_Alfred的自定义命令端">5. Alfred的自定义命令端</h3><p><code>alfred</code>打开<code>iTerm</code>，并执行命令，通过设置<code>custom</code>，然后复制以下的脚本就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">    tell application &quot;iTerm&quot;</span><br><span class="line">        set _length to count window</span><br><span class="line">    if _length = 0 then</span><br><span class="line">        create window with default profile</span><br><span class="line">    end if</span><br><span class="line">    set aa to (get miniaturized of current window)</span><br><span class="line">    if aa then</span><br><span class="line">        set miniaturized of current window to false</span><br><span class="line">    end if</span><br><span class="line">    set bb to (get visible of current window)</span><br><span class="line">    if bb is false then</span><br><span class="line">        set visible of current window to true</span><br><span class="line">    end if</span><br><span class="line">    set cc to frontmost</span><br><span class="line">    if cc is false then</span><br><span class="line">        activate</span><br><span class="line">    end if</span><br><span class="line">        (*if _length = 0 then*)</span><br><span class="line">            set theResult to current tab of current window</span><br><span class="line">        (*else</span><br><span class="line">            set theResult to (create tab with default profile) of current window</span><br><span class="line">        end if*)</span><br><span class="line">        write session of theResult text q</span><br><span class="line">end tell</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_mac安装brew&quot;&gt;1. mac安装brew&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="MAC" scheme="https://coolwcan.cn/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置及问题修复</title>
    <link href="https://coolwcan.cn/Tools/Tools/Ubuntu%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
    <id>https://coolwcan.cn/Tools/Tools/Ubuntu配置及问题修复/</id>
    <published>2019-03-12T05:48:38.588Z</published>
    <updated>2019-03-12T05:48:38.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_系统设置中_language_support_消失">1. 系统设置中 <code>language support</code> 消失</h3><p>在 <code>synaptick</code> 中安装 <code>language-selector-gnome</code>，这个软件与 <code>im-switch</code> 这个是冲突的，所以在安装 <code>im-switch</code> 后，它会将这一个软件删除，所以在系统的选项中将不会显示，只要再安装一次就可，但是这个软件也会删除 <code>im-switch</code></p><h3 id="2-_系统选项中很多图标消失">2. 系统选项中很多图标消失</h3><p>安装 <code>unity-control-center</code> 就可以恢复了</p><h3 id="3-_在VirtualBox中安装Xp系统时的问题：">3. 在VirtualBox中安装Xp系统时的问题：</h3><ol><li>安装Xp系统后提示”init 8, init failure”<br>表示你的系统中没有一个磁盘，是设置为主作为区，在PQ中，在转换中，可以将一个硬盘转换成“主作为区”</li><li>安装Xp，启动时，出现蓝屏，一直不能进入，并且提示”prossor.sys错误”<br>在PE中安装完Xp后不要马上启动系统，进入到C:\WINDOWS\system32\drivers下，并找到processr.sys这个文件，将这个文件更名processr.sys.old</li><li>安装完Xp，不能使用笔记本集成的摄像头<br>在VirtualBox的官网上下载对应你的型号的扩展包，然后打开VirtualBox，在 “管理” –&gt; “全局选项” –&gt; “扩展” –&gt; 选择你的扩展包就可以安装了，重新启动就可以</li><li>出现Wine System Tray, 在切换到gnome classic，通知区域不见了，WineQQ，会显示一个 <code>Wine System Tray</code>，这表明通知区域没有被显示出来。解决步骤如下：<ol><li>在顶部的信息栏中上的空白处 Win+Alt+鼠标右键,选择“添加到面板“</li><li>在其中找到 “通知区域”</li><li>点击下面的“添加”即可</li></ol></li></ol><h3 id="4-_“Virtual_machine_‘Centos’_has_terminated_unexpectedly_during_startup”">4. “Virtual machine ‘Centos’ has terminated unexpectedly during startup”</h3><p>是因为 <code>vboxdrv</code> 没有加载， 执行 <code>sudo /etc/init.d/vboxdrv setup</code></p><h3 id="5-_用户不在sudoers文件中的解决方法">5. 用户不在sudoers文件中的解决方法</h3><ol><li>切换到root用户权限<br><code>su root</code></li><li>查看/etc/sudoers文件权限，如果只读权限，修改为可写权限<br><code>chmod 777 /etc/sudoers</code></li><li>编辑 <code>/etc/sudoers</code> 文件，添加要提升权限的用户<br>找到 <code>root ALL=(ALL) ALL</code> 这一行，并在其下面加上一行:<br>  <code>user ALL=(ALL) ALL</code><br>说明：格式为（用户名 网络中的主机=(执行命令的目标用户) 执行的命令范围）</li><li>并恢复 <code>/etc/sudoers</code> 的访问权限为 <code>440</code><br><code>chmod 440 /etc/sudoers</code></li><li>切换到普通用户，测试用户权限提升功能</li></ol><h3 id="6-_Ubuntu_连接局域网共享">6. Ubuntu 连接局域网共享</h3><ol><li><p>安装samba</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br><span class="line">sudo apt-get install cifs-utils</span><br></pre></td></tr></table></figure></li><li><p>挂载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs -o username=anonymous,password=&apos;&apos; //192.168.2.253/xxxx/ ~/public-files</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-_双系统Ubuntu无法进入Windows磁盘的解决方法">7. 双系统Ubuntu无法进入Windows磁盘的解决方法</h3><ol><li>输入命令检测 ntfs-3g 是否已经安装： <code>locate ntfs-3g</code>, 否则就执行 <code>sudo apt-get install ntfs-3g</code></li><li>sudo ntfsfix /dev/sda6  # /dev/sda6 为需要修复的盘符</li></ol><h3 id="8-_win10和Ubuntu16-04双系统下时间不对的问题">8. win10和Ubuntu16.04双系统下时间不对的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br></pre></td></tr></table></figure><h3 id="9-_运行openProj时，提示_Your_Java_vendor_is_“Oracle_Corporation”-_To_run_OpenProj,_you_need_the_Sun_Java_implementation-The_auto-detected_Java_Runtime_used_is-">9. 运行openProj时，提示 Your Java vendor is “Oracle Corporation”. To run OpenProj, you need the Sun Java implementation.The auto-detected Java Runtime used is..</h3><p>将 <code>$HOME/.openproj/run.conf and</code> 从 <code>JAVA_OPTS=&quot;-Xms128m -Xmx768m&quot;</code> 改成 <code>JAVA_OPTS=&quot;-Djava.vendor=Sun -Xms128m -Xmx768m&quot;</code></p><h3 id="10-_安装爱壁纸时，提示_python-support找不到">10. 安装爱壁纸时，提示 python-support找不到</h3><ul><li><code>wget http://launchpadlibrarian.net/109052632/python-support_1.0.15_all.deb</code></li><li><code>sudo dpkg -i python-support_1.0.15_all.deb</code></li><li><code>sudo apt-get install -f</code></li></ul><p>然后再执行 <code>sudo dpkg -i xxx.deb</code></p><h3 id="11-_Ubuntu设置静态地址">11. Ubuntu设置静态地址</h3><ol><li><p>找到文件并作如下修改：</p><p><code>sudo vim /etc/network/interfaces</code></p><p> 修改如下部分：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto eth0                # 注意eth0，是你对应的网卡</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.0.117    # 地址</span><br><span class="line">gateway 192.168.0.1      # 网关</span><br><span class="line">netmask 255.255.255.0    # 掩码</span><br><span class="line">network 192.168.0.0      # 网络号</span><br><span class="line">broadcast 192.168.0.255  # 广播地址</span><br></pre></td></tr></table></figure></li><li><p>修改dns解析，因为之前是<code>dhcp</code>，会自动分配dns，现在需要手动配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. sudo vim /etc/resolv.conf</span><br><span class="line">2. 百度的dns</span><br><span class="line">   nameserver 180.76.76.76</span><br></pre></td></tr></table></figure></li><li><p>重启网卡<br><code>sudo /etc/init.d/networking restart</code></p></li></ol><h3 id="12-_Win8使用XShell连接Ubuntu">12. Win8使用XShell连接Ubuntu</h3><p>需要在 <code>VirtualBox</code> 设置两个网卡，分别是 <code>NAT</code> 和 <code>桥接</code>, <code>NAT</code>是为了能够让虚拟机上网，而 <code>桥接</code> 是为了让主机能够连接上虚拟机</p><h3 id="13-_配置字体">13. 配置字体</h3><p>将 windows 下的字体拷贝出来，放到Ubuntu的 <code>/usr/share/fonts/windows-fonts</code>，然后运行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache -fv</span><br></pre></td></tr></table></figure><ul><li>命令成功后会提示 <code>fc-cache: succeeded</code></li><li><code>windows-fonts</code> 这是自己建的目录，命令会自己去扫描</li></ul><h3 id="14-_设置快捷方式">14. 设置快捷方式</h3><p>在 Ubuntu 中所有的快捷方式都在 <code>/usr/share/applications</code> 目录下，会存在很多 <code>.desktop</code>文件，如果需要自己建立一个通过双击就能运行的程序，就必须创建一个快捷方式，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=DrClient</span><br><span class="line">Comment=DrClient</span><br><span class="line">Exec=/home/haiyang/DrClient/DrClientLinux</span><br><span class="line">Icon=/home/haiyang/DrClient/icon.xpm</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=true</span><br><span class="line">Categories=Accessibility;Utility;</span><br><span class="line">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure><p>其它的用法，可以参考其它的快捷方式去创建</p><h3 id="15-_便笺工具">15. 便笺工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:umang/indicator-stickynotes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-stickynotes</span><br></pre></td></tr></table></figure><h3 id="16-_Ubuntu_16-04_阿里云源">16. Ubuntu 16.04 阿里云源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">##测试版源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"># 源码</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">##测试版源</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="17-_系统错误报告屏蔽">17. 系统错误报告屏蔽</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/crash/*</span><br><span class="line">sudo vim /etc/default/apport</span><br></pre></td></tr></table></figure><p>将 <code>enabled</code> 设置为 <code>0</code></p><h3 id="18-_无法显示桌面">18. 无法显示桌面</h3><p>重装桌面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall ubuntu-desktop</span><br></pre></td></tr></table></figure><p>特别强调一下，尽量不要去删 Ubuntu 自带的软件，不要使用 <strong>Ubuntu商店</strong></p><h3 id="19-_zsh_提示_no_match_found_XX">19. zsh 提示 <code>no match found XX</code></h3><p>在 <code>~/.zshrc</code> 中加入 <code>setopt no_nomatch</code> 再 <code>source</code> 一下就好</p><h3 id="20-_Ubuntu_16-04_提示_the_system_is_running_in_low-graphics_mode">20. Ubuntu 16.04 提示 <code>the system is running in low-graphics mode</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Alt + F1</span><br><span class="line">sudo add-apt-repository ppa:ubuntu-x-swat/updates</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="21-_修改_grub_的字体大小">21. 修改 grub 的字体大小</h3><p><code>http://forum.ubuntu.com.cn/viewtopic.php?f=139&amp;t=348988</code></p><h3 id="22-_Ubuntu_16-04出现：Problem_executing_scripts_APT::Update::Post-Invoke-Success_‘if_/usr/bin/test_-w_/var/cache/app-info_-a_-e_/usr/bin/appstreamcli;_then_appstreamcli_refresh_&gt;_/dev/null;_fi’">22. Ubuntu 16.04出现：Problem executing scripts APT::Update::Post-Invoke-Success ‘if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi’</h3><p>执行如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -KILL appstreamcli</span><br><span class="line">wget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.deb</span><br><span class="line">sudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure></p><p>再次执行 <code>sudo apt-get update</code> 就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_系统设置中_language_support_消失&quot;&gt;1. 系统设置中 &lt;code&gt;language support&lt;/code&gt; 消失&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;synaptick&lt;/code&gt; 中安装 &lt;code&gt;language-selector-
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Ubuntu" scheme="https://coolwcan.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Centos配置及问题修复</title>
    <link href="https://coolwcan.cn/Tools/Tools/Centos%E9%85%8D%E7%BD%AE/"/>
    <id>https://coolwcan.cn/Tools/Tools/Centos配置/</id>
    <published>2019-03-12T05:48:38.587Z</published>
    <updated>2019-03-12T05:48:38.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_更新源">1. 更新源</h3><ol><li>首先备份<br><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li><li>进入yum源配置文件所在文件夹<br><code>cd /etc/yum.repos.d/</code></li><li>下载163的yum源配置文件，放入 <code>/etc/yum.repos.d/</code><br><code>wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</code></li><li>生成缓存<br><code>yum makecache</code></li><li>更新系统<br><code>yum -y update</code></li></ol><h3 id="2-_多网卡配置静态IP">2. 多网卡配置静态IP</h3><ul><li>在<code>/etc/sysconfig/network-scripts/</code>目录下</li><li>在当前目录，根据你的网卡数，创建n个<code>ifcfg-ethX</code>个文件</li><li><p>配置每一个<code>ifcfg-ethX</code>文件，主要内容如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0                 //指出设备名称</span><br><span class="line">BOOTPROT=static             //启动类型 dhcp|static</span><br><span class="line">BROADCAST=192.168.1.203     //广播地址</span><br><span class="line">HWADDR=00:06:5B:FE:DF:7C    //硬件Mac地址</span><br><span class="line">IPADDR=192.168.0.2          //IP地址</span><br><span class="line">NETMASK=255.255.255.0       //子网掩码</span><br><span class="line">NETWORK=192.168.0.0         //网络地址</span><br><span class="line">GATEWAY=192.168.0.1         //网关地址</span><br><span class="line">ONBOOT=yes                  //是否启动应用</span><br></pre></td></tr></table></figure></li><li><p>重启网络服务<br><code>service network restart</code></p></li></ul><h3 id="3-_Centos最小化安装后，无法连网？">3. Centos最小化安装后，无法连网？</h3><ul><li>执行<code>dhclient eth0</code></li><li>修改<code>etc/sysconfig/network-scripts/ifcfg-eth0</code>文件，将<code>ONBOOT=no改为ONBOOT=yes</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_更新源&quot;&gt;1. 更新源&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先备份&lt;br&gt;&lt;code&gt;mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup&lt;/code&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Linux" scheme="https://coolwcan.cn/tags/Linux/"/>
    
      <category term="Centos" scheme="https://coolwcan.cn/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Shiro 与 Spring集成</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro%E4%B8%8ESpring%E9%9B%86%E6%88%90/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro与Spring集成/</id>
    <published>2019-03-12T05:48:38.587Z</published>
    <updated>2019-03-12T05:48:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_基础概念">0. 基础概念</h3><p>在整个Shiro框架中， <code>SecurityManager</code> 是整个框架的核心，它会去协调内部的调用关系，<code>Subject</code> 代表所有的请求发起者，通常只需要通过 <code>Subject</code> 进行登录与登出操作，然后实现自己的 <code>Realm</code> 去实现认证与授权就可以了</p><h3 id="1-_与Spring的集成">1. 与Spring的集成</h3><ol><li><p>引入 maven 的依赖</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> 此处省略了版本号，当然是引入最新的版本就好</p></li><li><p>配置 Shiro 的过滤器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p> <code>DelegatingFilterProxy</code> 就不用多解释了，会在Spring容器中去找到一个名为 <code>shiroFilter</code> 的过滤器，并且用该<code>Filter</code>过滤所有的访问请求。</p></li><li><p>配置Spring容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;realm&quot; ref=&quot;shiroDbRealm&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--自定的Realm--&gt;</span><br><span class="line">   &lt;bean id=&quot;shiroDbRealm&quot; class=&quot;xx.xxx.ShiroDbRealm&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;successUrl&quot; value=&quot;/home&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">           &lt;value&gt;</span><br><span class="line">               /static/** = anon</span><br><span class="line">               /** = user</span><br><span class="line">           &lt;/value&gt;</span><br><span class="line">       &lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;shiroEhcacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache-shiro.xml&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">       &lt;constructor-arg value=&quot;rememberMe&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;rememberMeManager&quot;</span><br><span class="line">         class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class="line">       &lt;property name=&quot;cipherKey&quot; value=&quot;#&#123;T(org.apache.shiro.codec.Base64).decode(&apos;4AvVhmFLUs0KTA3Kprsdag==&apos;)&#125;&quot;/&gt;</span><br><span class="line">       &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><code>shiroFilter</code> 就是 <code>Web.xml</code> 中配置所需要的Bean，因为 Shiro 的核心是 <code>securityManager</code>，其它的几个Bean，大多数都是为了SecurityManager 所准备的，而 <code>lifecycleBeanPostProcessor</code> 会自动去调 Shiro 特定 Bean 的初始化与destroy方法。</p></li><li><p>登录与登出操作</p><ol><li><p>登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username</span><br><span class="line">                , password, isRememberMe;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">try &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; catch (AuthenticationException e) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>登出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">if (currentUser.isAuthenticated() || currentUser.isRemembered())&#123;</span><br><span class="line">    currentUser.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_基础概念&quot;&gt;0. 基础概念&lt;/h3&gt;&lt;p&gt;在整个Shiro框架中， &lt;code&gt;SecurityManager&lt;/code&gt; 是整个框架的核心，它会去协调内部的调用关系，&lt;code&gt;Subject&lt;/code&gt; 代表所有的请求发起者，通常只需要通过 &lt;cod
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Spring MVC" scheme="https://coolwcan.cn/tags/Spring-MVC/"/>
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-05-在Shiro中是如何实现独立的Session</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro-05-%E5%9C%A8Shiro%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8B%AC%E7%AB%8B%E7%9A%84Session/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro-05-在Shiro中是如何实现独立的Session/</id>
    <published>2019-03-12T05:48:38.587Z</published>
    <updated>2019-03-12T05:48:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_引入">0. 引入</h3><p><code>Shiro</code> 对其 <code>Session</code> 管理是这样描述的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use a Session API in any environment, even without web or EJB containers.</span><br></pre></td></tr></table></figure></p><p>能够将 <code>Session</code> 应用到任意一个环境上，而不仅仅在 <code>Web</code> 和 <code>EJB containers</code>，这就引起我的一个好奇，那么它是如何做的呢？在之前，我们也曾分析过 <code>Shiro</code> 的登录、登出及创建，接下来我们将再次从这个角度去分析 <code>Shiro</code> 中的 <code>Session</code>，及其整个生命周期。在分析之前，我很好奇 <code>HttpSession</code> 与 <code>Shiro</code> 内部的 <code>Session</code> 会有什么区别呢，下面只展示其接口:</p><ol><li><p><code>HttpSession</code>:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  public interface HttpSession &#123;</span><br><span class="line">public long getCreationTime();</span><br><span class="line">      public String getId();</span><br><span class="line">      public long getLastAccessedTime();</span><br><span class="line">      public ServletContext getServletContext();</span><br><span class="line">      public void setMaxInactiveInterval(int interval);</span><br><span class="line">      public int getMaxInactiveInterval();</span><br><span class="line">      public HttpSessionContext getSessionContext();</span><br><span class="line">      public Object getAttribute(String name);</span><br><span class="line">      public Object getValue(String name);</span><br><span class="line">      public Enumeration&lt;String&gt; getAttributeNames();</span><br><span class="line">      public String[] getValueNames();</span><br><span class="line">      public void setAttribute(String name, Object value);</span><br><span class="line">      public void putValue(String name, Object value);</span><br><span class="line">      public void removeAttribute(String name);</span><br><span class="line">      public void removeValue(String name);</span><br><span class="line">      public void invalidate();</span><br><span class="line">      public boolean isNew();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Shiro</code> 的 <code>Session</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Session &#123;</span><br><span class="line">Serializable getId();</span><br><span class="line">    Date getStartTimestamp();</span><br><span class="line">    Date getLastAccessTime();</span><br><span class="line">    long getTimeout() throws InvalidSessionException;</span><br><span class="line">    void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException;</span><br><span class="line">    String getHost();</span><br><span class="line">    void touch() throws InvalidSessionException;</span><br><span class="line">    void stop() throws InvalidSessionException;</span><br><span class="line">    Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException;</span><br><span class="line">    Object getAttribute(Object key) throws InvalidSessionException;</span><br><span class="line">    void setAttribute(Object key, Object value) throws InvalidSessionException;</span><br><span class="line">    Object removeAttribute(Object key) throws InvalidSessionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>粗略一看还是有一定的区别。</p><h3 id="1-_在_Web_环境下登录与非_Web_环境下登录其_Session_有什么区别呢？">1. 在 <code>Web</code> 环境下登录与非 <code>Web</code> 环境下登录其 <code>Session</code> 有什么区别呢？</h3><h4 id="1-1_在非Web_环境下登录，此时_Session_的创建过程？">1.1 在非<code>Web</code> 环境下登录，此时 <code>Session</code> 的创建过程？</h4><p>直接看 <code>DefaultSecurityManager</code> 的 <code>getSession()</code> 方法，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SessionContext sessionContext = createSessionContext();</span><br><span class="line">Session session = this.securityManager.start(sessionContext);</span><br><span class="line">this.session = decorate(session);</span><br></pre></td></tr></table></figure><p>省略了很多代码，比较关键的是这三行代码。</p><ul><li>第一行代码，创建了 <code>SessionContext</code> ，其本质是一个 <code>Map</code>，其中针对需要存储的对象，设置了一个固定的 <code>Key</code>;</li><li>第三行代码，仅仅包装了一下创建出来的 <code>Session</code></li><li>第二行代码，真正创建 <code>Session</code></li></ul><p>在创建过程中，会经过 <code>DefaultSecurityManager</code> 转到 <code>DefaultSessionManager</code>，然后再转到 <code>AbstractNativeSessionManager</code> 的 <code>start</code> 方法，其方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Session start(SessionContext context) &#123;</span><br><span class="line">    Session session = createSession(context);</span><br><span class="line">    applyGlobalSessionTimeout(session);</span><br><span class="line">    onStart(session, context);</span><br><span class="line">    notifyStart(session);</span><br><span class="line">    //Don&apos;t expose the EIS-tier Session object to the client-tier:</span><br><span class="line">    return createExposedSession(session, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要分析 <code>createSession</code> 这个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext context) throws AuthorizationException &#123;</span><br><span class="line">    enableSessionValidationIfNecessary();</span><br><span class="line">    return doCreateSession(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>enableSessionValidationIfNecessary</code> 配置一个线程池去定期清理过期的 <code>Session</code>, <code>doCreateSession</code> 对应到 <code>DefaultSessionManager</code> ，方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected Session doCreateSession(SessionContext context) &#123;</span><br><span class="line">    Session s = newSessionInstance(context);</span><br><span class="line">    if (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(&quot;Creating session for host &#123;&#125;&quot;, s.getHost());</span><br><span class="line">    &#125;</span><br><span class="line">    create(s);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>create(s)</code> 仅仅是缓存创建的 <code>Session</code>，其默认实现为 <code>MemorySessionDAO</code> 的 <code>doCreate</code> 方法，其通过 <code>UUID</code> 生成 <code>SessionId</code>  然后，将 <code>SessionId</code> 为 <code>key</code>, <code>Session</code> 为值，放到一个 <code>ConcurrentMap</code> 中；而 <code>newSessionInstance</code> 具体是由 <code>SimpleSessionFactory</code> 的 <code>createSession</code> 去执行，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Session createSession(SessionContext initData) &#123;</span><br><span class="line">    if (initData != null) &#123;</span><br><span class="line">        String host = initData.getHost();</span><br><span class="line">        if (host != null) &#123;</span><br><span class="line">            return new SimpleSession(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅就是简单地 <code>new</code> 了一个 <code>SimpleSession</code> 对象而已。那么如何判断一个非认证的用户在同一个 <code>Session</code> 呢，因为在 <code>Web</code> 环境中，就算一个用户没有通过认证，但是我们能够通过其 <code>Cookie</code> 判断其在同一个 <code>Session</code> 中。</p><h4 id="1-2_在_Web_环境下登录，此时_Session_的创建过程？">1.2 在 <code>Web</code> 环境下登录，此时 <code>Session</code> 的创建过程？</h4><p>此时创建 <code>Session</code> 的过程与非 <code>Web</code> 环境的创建 <code>Session</code> 的过程比较一致，大的区别在于 <code>WebDelegatingSubject</code> 和 <code>ServletContainerSessionManager</code>， 在 <code>WebDelegatingSubject</code> 可以看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected SessionContext createSessionContext() &#123;</span><br><span class="line">    WebSessionContext wsc = new DefaultWebSessionContext();</span><br><span class="line">    String host = getHost();</span><br><span class="line">    if (StringUtils.hasText(host)) &#123;</span><br><span class="line">        wsc.setHost(host);</span><br><span class="line">    &#125;</span><br><span class="line">    wsc.setServletRequest(this.servletRequest);</span><br><span class="line">    wsc.setServletResponse(this.servletResponse);</span><br><span class="line">    return wsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法中，会将 <code>ServletRequest</code> 与 <code>ServletResponse</code> 放入到 <code>WebSessionContext</code> 中； 在 <code>ServletContainerSessionManager</code> 中看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext sessionContext) throws AuthorizationException &#123;</span><br><span class="line">    if (!WebUtils.isHttp(sessionContext)) &#123;</span><br><span class="line">        String msg = &quot;SessionContext must be an HTTP compatible implementation.&quot;;</span><br><span class="line">        throw new IllegalArgumentException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    HttpServletRequest request = WebUtils.getHttpRequest(sessionContext);</span><br><span class="line">    HttpSession httpSession = request.getSession();</span><br><span class="line">    String host = getHost(sessionContext);</span><br><span class="line">    return createSession(httpSession, host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，可以看到在先从 <code>ServletRequest</code> 中获取 <code>HttpSession</code>，然后通过 <code>createSession</code> 包装原始的 <code>HttpSession</code>。其 <code>createSession</code> 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(HttpSession httpSession, String host) &#123;</span><br><span class="line">    return new HttpServletSession(httpSession, host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装成了一个 <code>HttpServletSession</code> (<code>Shiro</code> 的内部对象)。在此过程无缓存。</p><h4 id="1-3_在登录过程中_Web_环境与_非_Web_环境的_Session_创建的比较">1.3 在登录过程中 <code>Web</code> 环境与 非 <code>Web</code> 环境的 <code>Session</code> 创建的比较</h4><ol><li>在 <code>Web</code> 环境下，包装 <code>HttpSession</code> 成 <code>Shiro</code> 的内部对象 <code>HttpServletSession</code>，无缓存，也无须去管理定时去清理 <code>Session</code> 的问题，这些问题，会由容器去处理</li><li>在 非<code>Web</code> 环境下，创建 <code>SimpleSession</code> 对象，能够为每一个访问者提供一个类似于 <code>Web</code> 容器的 <code>Session</code> 的功能，并且通过 <code>SessionDao</code> 缓存对象，并且创建线程池定期清理过期的 <code>Session</code> 对象</li></ol><p>通过对上面的分析，大家可能对 <code>Session</code> 有一个粗略的理解，但是我认为想要完全地达到 <code>Web</code> 容器的 <code>Session</code> 的功能，必须要解决掉，如何唯一标识一个用户(可能已经认证，可以非认证)</p><h3 id="2-_登出的过程_Web_环境与非_Web_环境的_Session_销毁有什么区别？">2. 登出的过程 <code>Web</code> 环境与非 <code>Web</code> 环境的 <code>Session</code> 销毁有什么区别？</h3><p>因为 <code>DelegatingSubject</code>、<code>DefaultSecurityManager</code> 与 <code>WebDelegatingSubject</code>、<code>DefaultWebSecurityManager</code> 这四个类，分别代表非 <code>Web</code> 及 <code>Web</code> 环境。在通过比较两个 <code>logout</code> 方法时，能够发现，有区别的仅仅是在 <code>DefaultSecurityManager</code> 与 <code>DefaultWebSecurityManager</code> 的 <code>beforeLogout</code> 方法，而 <code>DefaultWebSecurityManager</code> 又继承自 <code>DefaultSecurityManager</code>，在<code>DefaultWebSecurityManager</code> 可以看到如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void beforeLogout(Subject subject) &#123;</span><br><span class="line">    super.beforeLogout(subject);</span><br><span class="line">    removeRequestIdentity(subject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void removeRequestIdentity(Subject subject) &#123;</span><br><span class="line">    if (subject instanceof WebSubject) &#123;</span><br><span class="line">        WebSubject webSubject = (WebSubject) subject;</span><br><span class="line">        ServletRequest request = webSubject.getServletRequest();</span><br><span class="line">        if (request != null) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会调用父类的 <code>beforeLogout</code> 方法，而它的父类则为 <code>DefaultSecurityManager</code>，所以区别在于 <code>removeRequestIdentity</code> 方法，在该方法中，仅仅看到的是在 <code>ServletRequest</code> 添加了一个 <code>ShiroHttpServletRequest.IDENTITY_REMOVED_KEY</code>。</p><h3 id="3-_该如何做_Session_的同步呢？">3. 该如何做 <code>Session</code> 的同步呢？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_引入&quot;&gt;0. 引入&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Shiro&lt;/code&gt; 对其 &lt;code&gt;Session&lt;/code&gt; 管理是这样描述的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux配置及问题修复</title>
    <link href="https://coolwcan.cn/Tools/Tools/Archlinux%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
    <id>https://coolwcan.cn/Tools/Tools/Archlinux配置及问题修复/</id>
    <published>2019-03-12T05:48:38.587Z</published>
    <updated>2019-03-12T05:48:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_安装yaourt">1. 安装yaourt</h3><ol><li>概念：<ol><li>Yaourt, <code>Yet AnOther User Repository Tool</code>，是社区贡献的一个pacman的一个外壳。</li><li>yaourt的安装方式是编译安装</li><li>AUR, <code>Arch Linux User-Community Repository</code>, 社区用户软件仓库</li></ol></li><li><p>安装</p><ol><li>安装依赖包<br>pacman -S base-devel</li><li><p>安装package-query</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://aur.archlinux.org/packages/pa/package-query/package-query.tar.gz</span><br><span class="line">tar zxvf package-query.tar.gz</span><br><span class="line">cd package-query</span><br><span class="line">makepkg -si</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>安装yaourt</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://aur.archlinux.org/packages/ya/yaourt/yaourt.tar.gz</span><br><span class="line">tar zxvf yaourt.tar.gz</span><br><span class="line">cd yaourt</span><br><span class="line">makepkg -si</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2-_安装ibus五笔输入法">2. 安装ibus五笔输入法</h3><ol><li>安装ibus框架<br><code>pacman -S ibus ibus-table ibus-table-chinese</code></li><li><p>在bash中配置ibus的启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. vim .bashrc</span><br><span class="line">2.</span><br><span class="line">   export GTK_IM_MODULE=ibus</span><br><span class="line">   export XMODIFIERS=@im=ibus</span><br><span class="line">   export QT_IM_MODULE=ibus</span><br></pre></td></tr></table></figure></li><li><p>后台启动ibus的守护进程<br><code>ibus-daemon -drx</code></p></li><li>添加五笔<br><code>ibus-setup --&gt; 汉语 --&gt; 极点五笔</code></li><li>重启ibus<br><code>ibus restart</code></li></ol><h3 id="3-_Xfce4中文设置">3. Xfce4中文设置</h3><ol><li><p>加载中文设置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. vim /etc/locale.gen</span><br><span class="line">2. 将zh_CN.UTF-8 UTF-8的注释去掉</span><br><span class="line">3. locale-gen</span><br></pre></td></tr></table></figure></li><li><p>修改语言</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. cd</span><br><span class="line">2. vim .bash_profile</span><br><span class="line">3. 在末尾加上：</span><br><span class="line">  export LANG=zh_CN.UTF-8</span><br><span class="line">  export LANGUAGE=zh_CN.UTF-8</span><br><span class="line">  export LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-_安装字体">4. 安装字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S wqy-microhei tf-arphic-ukai、ttf-arphic-uming</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_安装yaourt&quot;&gt;1. 安装yaourt&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;概念：&lt;ol&gt;
&lt;li&gt;Yaourt, &lt;code&gt;Yet AnOther User Repository Tool&lt;/code&gt;，是社区贡献的一个pacman的一个外壳。&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Archlinux" scheme="https://coolwcan.cn/tags/Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-03-Shiro的框架结构</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro-03-Shiro%E7%9A%84%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro-03-Shiro的框架结构/</id>
    <published>2019-03-12T05:48:38.586Z</published>
    <updated>2019-03-12T05:48:38.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_Authenticator">1. Authenticator</h3><p>负责用户身份的认证，其接口如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Authenticator &#123;</span><br><span class="line">    public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)</span><br><span class="line">            throws AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>验证 <code>AuthenticationToken</code> 对象，如果成功则返回 <code>AuthenticationInfo</code> 对象。<code>AuthenticationToken</code> 接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationToken extends Serializable &#123;</span><br><span class="line">    Object getPrincipal();</span><br><span class="line">    Object getCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要理清两个概念： <code>Principal</code>和<code>Credentials</code>。 <code>Principal</code> 用于唯一标识用户, <code>Credentials</code> 凭证，用于表明该用户的确拥有该用户。通俗的理解就是，<code>Principal</code> 就是用户名, <code>Credentials</code> 是密码，不过在 Shiro 框架中，对用户名与密码做了抽象，它可能有多种表现形式。例如可能用户名会存在多个，密码也有可能是一个文件等等。在理解了这两个概念后，我想对于 <code>AuthenticationToken</code> 也有一定的认识了吧，它是用户输入的载体。 <code>AuthenticationInfo</code> 接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationInfo extends Serializable &#123;</span><br><span class="line">    PrincipalCollection getPrincipals();</span><br><span class="line">    Object getCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口承载的是用户登录后的，保存的认证信息，以便在应用上下文中，使用其用户名或者密码。<code>PrincipalCollection</code> 代表 <code>Principal</code> 的集合。为什么会用户名会是多个呢？在实际的情况下，可能会存在这样的情况，当一个用户用ID登录后，但是其用户名、邮箱、手机号也可以唯一标识该用户的，则可以放到该集合里。<code>Authenticator</code> 其继承关系如下:</p><center><img src="/pics/Shiro-Authenticator.png" alt=""></center><p>首先 <code>SecurityManager</code> 下面再谈; <code>AbstractAuthenticator</code> 提供了对 <code>AuthenticationListener</code> 的支持，并且实现了 <code>LogoutAware</code> 接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LogoutAware &#123;</span><br><span class="line">    public void onLogout(PrincipalCollection principals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>一旦看到 <code>Aware</code>，我们就能很自然地想到 Spring，<code>LogoutAware</code> 表明在 <code>Subject</code> 调用 <code>logout</code> 时，所有实现了 <code>LogoutAware</code> 的类，都将被调用其 <code>void onLogout(PrincipalCollection principals)</code> 方法；</li><li>通过阅读 <code>AuthenticationListener</code> 的源码，可以发现，它对 <code>Authenticator</code> 的 <code>AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException</code> 方法进行了包装，其继承类，只需要实现 <code>AuthenticationInfo doAuthenticate(AuthenticationToken token) throws AuthenticationException;</code> 即可，在包装的过程，主要做了两件事，一件事，当出现异常时，通知在 <code>AbstractAuthenticator</code> 中记录的所有 <code>AuthenticationListener</code>，当成功后，通知所有 <code>AuthenticationListener</code>, 当登出，通知所有的 <code>AuthenticationListener</code>。</li></ol><p>接下来，我们再来看看 <code>ModularRealmAuthenticator</code>，在此模块中，引入了一个概念，<code>PAM</code>, <code>Pluggable Authentication Module</code>，可插拔式认证模块，这是一个Linux下的概念，即多模块认证的方式。现实情况下，也的确有这样的需求，例如，我即可以通过ID登录，也可以通过手机登录，邮箱登录都是可以的。但是这同时又会引入一个新的策略类 <code>AuthenticationStrategy</code>，它提供了一个策略，在多个 <code>Realm</code> 同时认证时，什么情况下，才认为用户是认证成功的，是必须所有的 <code>Realm</code> 都认证成功，还是仅仅只有一个 <code>Realm</code> 认证成功就可以，等等。</p><h3 id="2-_Authorizer">2. Authorizer</h3><p>负责对已经登录的用户进行授权，其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Authorizer &#123;</span><br><span class="line">    boolean isPermitted(PrincipalCollection principals, String permission);</span><br><span class="line">    boolean isPermitted(PrincipalCollection subjectPrincipal, Permission permission);</span><br><span class="line">    boolean[] isPermitted(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line">    boolean[] isPermitted(PrincipalCollection subjectPrincipal, List&lt;Permission&gt; permissions);</span><br><span class="line">    boolean isPermittedAll(PrincipalCollection subjectPrincipal, String... permissions);</span><br><span class="line">    boolean isPermittedAll(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions);</span><br><span class="line">    void checkPermission(PrincipalCollection subjectPrincipal, String permission) throws AuthorizationException;</span><br><span class="line">    void checkPermission(PrincipalCollection subjectPrincipal, Permission permission) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(PrincipalCollection subjectPrincipal, String... permissions) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(PrincipalCollection subjectPrincipal, Collection&lt;Permission&gt; permissions) throws AuthorizationException;</span><br><span class="line"></span><br><span class="line">    boolean hasRole(PrincipalCollection subjectPrincipal, String roleIdentifier);</span><br><span class="line">    boolean[] hasRoles(PrincipalCollection subjectPrincipal, List&lt;String&gt; roleIdentifiers);</span><br><span class="line">    boolean hasAllRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers);</span><br><span class="line">    void checkRole(PrincipalCollection subjectPrincipal, String roleIdentifier) throws AuthorizationException;</span><br><span class="line">    void checkRoles(PrincipalCollection subjectPrincipal, Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;</span><br><span class="line">    void checkRoles(PrincipalCollection subjectPrincipal, String... roleIdentifiers) throws AuthorizationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过其接口，我们也能看出来，主要提供对权限和角色的验证，这觉得这一块的东西，是没必要多做解释的，在Shiro框架中，角色与权限都需要用户自己去定义。其继承关系如下:</p><center><img src="/pics/Shiro-Authorizer.png" alt=""></center><p>虽然其实现类，很多，但是这些不过是针对具体的协议下的不同做法而已。</p><h3 id="3-_Realm">3. Realm</h3><p>其英文名字是 <code>范围、领域</code> 的意思，其主要的功能是获取用户认证信息与授权数据，与数据源是一对一的关系。其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Realm &#123;</span><br><span class="line">    String getName();</span><br><span class="line">    boolean supports(AuthenticationToken token);</span><br><span class="line">    AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>String getName();</code> 为该 <code>Realm</code> 取一个唯一的名字</li><li><code>boolean supports(AuthenticationToken token);</code> 判断当前 <code>Realm</code> 是否支持当前用户的输入</li><li><code>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code> 用户的认证信息</li></ol><p>其继承关系如下:</p><center><img src="/pics/Shiro-Realm.png" alt=""></center><ol><li><code>CachingRealm</code><br>提供对缓存的支持, 在其中注入了 <code>CacheManager</code>，添加了一些常用的方法</li><li><code>AuthenticatingRealm</code><br>对 <code>Authenticator</code> 的支持， 将 <code>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code> 包装成了 <code>AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;</code>，并将缓存的操作，集成到了 <code>getAuthenticationInfo</code> 这个方法里。缓存的key为 <code>AuthenticationToken.getPrincipal</code> 其值为 <code>AuthenticationInfo</code></li><li><code>AuthorizingRealm</code> 对 <code>Authorizer</code> 的支持<br>除了实现 <code>Authorizer</code> 的方法外，还对外抛出了 <code>AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals)</code> 这个待实现的接口，该是被 <code>AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals)</code> 这个方法包装的，在包装的过程，将顶层的 <code>CachingRealm</code> 集成了进来。通过其命名就能看到 <code>getAuthorizationInfo</code> 是与 <code>AuthenticatingRealm</code> 的 <code>getAuthenticationInfo</code> 同一级的函数。缓存的key为 <code>PrincipalCollection</code>， 而值为 <code>AuthorizationInfo</code></li></ol><p>剩下的类，都是针对具体的协议，没必要去分析。通过其继承关系，我们可以明白 <code>Realm</code>，其实代表了认证与授权的数据，理所当然也就应该实现 <code>Authenticator</code> 和 <code>Authorizer</code>，为了提高性能，都采取了缓存的方式。</p><h3 id="4-_SecurityManager">4. SecurityManager</h3><p>在之前也曾提及到，<code>SecurityManger</code> 代表着整个框架，它会自动去协议内部对象。其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface SecurityManager extends Authenticator, Authorizer, SessionManager &#123;</span><br><span class="line">    Subject login(Subject subject, AuthenticationToken authenticationToken) throws AuthenticationException;</span><br><span class="line">    void logout(Subject subject);</span><br><span class="line">    Subject createSubject(SubjectContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个最顶层的类，代表着一个 <code>SecurityManager</code> 所应具体的功能，可以看到主要涉及到三个方面: 认证、授权、Session管理，而这三个方面，不正是 Shiro 所在做的事吗。其 <code>login</code> 、<code>logout</code>、<code>createSubject</code> 则是外界的行为，如果通读源码的话，会发现，Subject的行为，会被委托给 <code>SecurityManager</code>，而且必须委托给 <code>SecurityManager</code>。我认为可以从 <code>Shiro</code> 框架对 <code>SecurityManager</code> 以及对 <code>Subject</code> 的定位进行分析，<code>SecurityManager</code> 代表着 <code>Shiro</code>，而 <code>Subject</code> 代表所有的访问者，不可能把所有的内部对象都放到 <code>Subject</code> 中去吧，而且 <code>Shiro</code> 肯定得对外提供 <code>login</code> 和 <code>logout</code> 接口。</p><center><img src="/pics/Shiro-SecurityManager.png" alt=""></center><p>通过其继承关系，可以明了，<code>SecurityManager</code> 走了两条线，一条是普通的 <code>SecurityManager</code> 而另一条线则是提供了对 Web 的支持。对 Web 的支持暂时不分析。</p><ol><li>CachingSecurityManager<br>提供了对 <code>EventBus</code> 与 <code>CacheManager</code> 的注入方法</li><li>RealmSecurityManager<br>提供了对 <code>Collection&lt;Realm&gt;</code> 的注入</li><li>AuthenticatingSecurityManager<br>提供了对 <code>Authenticator</code> 的注入，默认为 <code>ModularRealmAuthenticator</code></li><li>AuthorizingSecurityManager<br>提供了对 <code>authorizer</code> 的注入，默认为 <code>ModularRealmAuthorizer</code></li><li>SessionSecurityManager<br>提供了对 <code>SessionManager</code> 的注入，默认为 <code>DefaultSessionManager</code></li><li>DefaultSecurityManager<br>提供了对 <code>RememberMeManager</code>、 <code>SubjectDAO</code>、<code>SubjectFactory</code> 的注入，<code>RememberMeManager</code> 需要外界注入，而 <code>SubjectDAO</code>、<code>SubjectFactory</code> 如果外界没有设置的话，默认为 <code>DefaultSubjectDAO</code> 和 <code>DefaultSubjectFactory</code>。很多逻辑都在该类里面。</li></ol><h3 id="5-_Subject">5. Subject</h3><p><code>Subject</code> 代表着所有的外部访问者，其接口如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">// 用户常见的调用</span><br><span class="line">    Object getPrincipal();</span><br><span class="line">    PrincipalCollection getPrincipals();</span><br><span class="line">    void login(AuthenticationToken token) throws AuthenticationException;</span><br><span class="line">    void logout();</span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line">    boolean isRemembered();</span><br><span class="line"></span><br><span class="line">    // Session的创建</span><br><span class="line">    Session getSession();</span><br><span class="line">    Session getSession(boolean create);</span><br><span class="line"></span><br><span class="line">    // 权限与角色的判断</span><br><span class="line">    boolean isPermitted(String permission);</span><br><span class="line">    boolean isPermitted(Permission permission);</span><br><span class="line">    boolean[] isPermitted(String... permissions);</span><br><span class="line">    boolean[] isPermitted(List&lt;Permission&gt; permissions);</span><br><span class="line">    boolean isPermittedAll(String... permissions);</span><br><span class="line">    boolean isPermittedAll(Collection&lt;Permission&gt; permissions);</span><br><span class="line">    void checkPermission(String permission) throws AuthorizationException;</span><br><span class="line">    void checkPermission(Permission permission) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(String... permissions) throws AuthorizationException;</span><br><span class="line">    void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;</span><br><span class="line">    boolean hasRole(String roleIdentifier);</span><br><span class="line">    boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);</span><br><span class="line">    boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);</span><br><span class="line">    void checkRole(String roleIdentifier) throws AuthorizationException;</span><br><span class="line">    void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;</span><br><span class="line">    void checkRoles(String... roleIdentifiers) throws AuthorizationException;</span><br><span class="line"></span><br><span class="line">// 异步执行</span><br><span class="line">    &lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;</span><br><span class="line">    void execute(Runnable runnable);</span><br><span class="line">    &lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);</span><br><span class="line">    Runnable associateWith(Runnable runnable);</span><br><span class="line"></span><br><span class="line">// runAs</span><br><span class="line">    void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;</span><br><span class="line">    boolean isRunAs();</span><br><span class="line">    PrincipalCollection getPreviousPrincipals();</span><br><span class="line">    PrincipalCollection releaseRunAs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Subject</code> 中还有一个 <code>Builder</code>，与分析 <code>Subject</code> 无关，所以省略。<code>Subject</code> 代表着访问者，即其中的方法，则为访问者的行为，初步一看，其实和 <code>SecurityManager</code> 碾平后的代码相似度比较高。其行为主要分为如下几类:</p><ol><li>登录、登出、判断是否登录，是否记住，获取用户名</li><li>Session的获取与创建</li><li>权限与角色的判断</li><li>异步执行</li><li>runAs</li></ol><p>前三个主要是委托给 <code>SecurityManager</code> 去做，异步执行与runAs，则是 <code>Subject</code> 去实现，默认实现在 <code>DelegatingSubject</code> 中。</p><h3 id="5-_总结">5. 总结</h3><p>零零碎碎地讲了很多，主要是明确主要的几个组件之间的相互关系，及其职责，其中还有很多可以去分析，比如其对缓存的封装，事件的分析，对加密算法的封装，AOP，接下来会从它是如何去Spring去集成和其独立的Session到底是怎么一回事的角度去分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_Authenticator&quot;&gt;1. Authenticator&lt;/h3&gt;&lt;p&gt;负责用户身份的认证，其接口如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-04-如何是与Spring集成的</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro-04-%E5%A6%82%E4%BD%95%E6%98%AF%E4%B8%8ESpring%E9%9B%86%E6%88%90%E7%9A%84/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro-04-如何是与Spring集成的/</id>
    <published>2019-03-12T05:48:38.586Z</published>
    <updated>2019-03-12T05:48:38.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_引入">0. 引入</h3><p>在对 <code>Shiro</code> 的使用中，更多的是用在 <code>Spring MVC</code> 中，那么 <code>Shiro</code> 是如何集成到 <code>Spring MVC</code> 中的呢？我只是先大概说明一下步骤:</p><ol><li>引用 <code>shiro-spring</code> 的maven依赖</li><li>在 <code>web.xml</code> 配置一个名为 <code>shiroFilter</code>，类为 <code>org.springframework.web.filter.DelegatingFilterProxy</code>的 Filter，拦截所有请求</li><li>在 <code>Spring</code> 容器中配置一个名为 <code>shiroFilter</code>，类为 <code>org.apache.shiro.spring.web.ShiroFilterFactoryBean</code> 的 <code>Bean</code></li><li>实现自定义的 <code>Realm</code></li><li>使用过程，使用 <code>@RequiresPermissions</code> 等注解</li></ol><p>根据以上的步骤，可以将该问题，拆分成两个小的问题:</p><ol><li>ShiroFilterFactoryBean 到底做了些什么</li><li><code>@RequiresPermissions</code> 这些注解是如何生效的</li></ol><h3 id="1-_ShiroFilterFactoryBean">1. ShiroFilterFactoryBean</h3><p>该类的属性如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private SecurityManager securityManager;</span><br><span class="line">private Map&lt;String, Filter&gt; filters;</span><br><span class="line">private Map&lt;String, String&gt; filterChainDefinitionMap;</span><br><span class="line">private String loginUrl;</span><br><span class="line">private String successUrl;</span><br><span class="line">private String unauthorizedUrl;</span><br><span class="line">private AbstractShiroFilter instance;</span><br></pre></td></tr></table></figure><p>需要解释的字段:</p><ol><li><p><code>Map&lt;String, Filter&gt; filters</code><br>在 <code>org.apache.shiro.web.filter.mgt.DefaultFilter</code> 定义了一个enum，该枚举的作用，是通过枚举的名字建立与对应的Filter的关系，此处是一个扩展点，用于建立用户自定义的名字与一个特定的Filter的关系。eg:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;filters&quot;&gt;</span><br><span class="line"> &lt;map&gt;</span><br><span class="line">  &lt;entry key=&quot;cas&quot; value-ref=&quot;casFilter&quot;/&gt;</span><br><span class="line"> &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 其默认的枚举如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">anon(AnonymousFilter.class),</span><br><span class="line">authc(FormAuthenticationFilter.class),</span><br><span class="line">authcBasic(BasicHttpAuthenticationFilter.class),</span><br><span class="line">logout(LogoutFilter.class),</span><br><span class="line">noSessionCreation(NoSessionCreationFilter.class),</span><br><span class="line">perms(PermissionsAuthorizationFilter.class),</span><br><span class="line">port(PortFilter.class),</span><br><span class="line">rest(HttpMethodPermissionFilter.class),</span><br><span class="line">roles(RolesAuthorizationFilter.class),</span><br><span class="line">ssl(SslFilter.class),</span><br><span class="line">user(UserFilter.class);</span><br></pre></td></tr></table></figure></li><li><p><code>Map&lt;String, String&gt; filterChainDefinitionMap</code><br>设置不同的请求，所对应的Filter，路径是通过 <code>Ant</code> 匹配规则进行匹配的。eg:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">&lt;value&gt;</span><br><span class="line">/config_* = anon</span><br><span class="line">/logout = logout</span><br><span class="line">/cas/* = cas</span><br><span class="line">/** = stUser</span><br><span class="line">&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p> 可以使用默认定义的，也可以使用自定义的</p></li><li><code>AbstractShiroFilter instance</code><br>该 <code>FactoryBean</code> 创建的对象，是单例，所以记录创建的对象</li></ol><p>因为该类为 <code>FactoryBean</code> ，可以发现，在其 <code>getObject</code> 中会创建一个单例的 <code>SpringShiroFilter</code>, 这是一个内部类，在整个类中最核心的函数是 <code>AbstractShiroFilter createInstance() throws Exception</code>。其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractShiroFilter createInstance() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    SecurityManager securityManager = getSecurityManager();</span><br><span class="line">    if (securityManager == null) &#123;</span><br><span class="line">        String msg = &quot;SecurityManager property must be set.&quot;;</span><br><span class="line">        throw new BeanInitializationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!(securityManager instanceof WebSecurityManager)) &#123;</span><br><span class="line">        String msg = &quot;The security manager does not implement the WebSecurityManager interface.&quot;;</span><br><span class="line">        throw new BeanInitializationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FilterChainManager manager = createFilterChainManager();</span><br><span class="line">    PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();</span><br><span class="line">    chainResolver.setFilterChainManager(manager);</span><br><span class="line"></span><br><span class="line">    return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码做了三件事:</p><ol><li>检查 <code>SecurityManager</code></li><li>创建 <code>FilterChainManager</code>，<code>PathMatchingFilterChainResolver</code></li><li>生成 <code>SpringShiroFilter</code> 对象</li></ol><p><code>FilterChainManager</code> 其主要的是维护一个路径与Filter的关系， <code>PathMatchingFilterChainResolver</code> 会利用 <code>AntPathMatcher</code> 去匹配请求的路径，然后调用 <code>FilterChainManager</code> 获取一个对应的Filter去拦截请求。而 <code>SpringShiroFilter</code> 是对 <code>AbstractShiroFilter</code> 的一个包装，而且该Filter拦截所有的请求，然后选择相应的Filter进行处理。（<code>ShiroFilterFactoryBean</code> 为一个 <code>FactoryBean</code>， 在反射过程中，会直接调用其 <code>getObject</code> 方法，生成 <code>SpringShiroFilter</code>）</p><h3 id="2-_如何在每一个请求中，注入_Subject_对象？">2. 如何在每一个请求中，注入 Subject 对象？</h3><p>在分析 <code>ShiroFilterFactoryBean</code> 可以发现，其最终会生成 <code>SpringShiroFilter</code>，然后根据不同的请求路径，让相应的Filter去拦截处理。但是有一个问题，不一定是每一个请求都是进入同一个线程中，那它是在什么时候，将已经认证过的 <code>Subject</code> 注入到 <code>ThreadContext</code> 对象中去的呢？查看 <code>SpringShiroFilter</code>，顺序着 <code>doFilter</code> (Filter的过滤函数)去找，发现在 <code>SpringShiroFilter</code> 的父类 <code>AbstractShiroFilter</code> 的 <code>doFilterInternal</code> 方法有如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain)</span><br><span class="line">        throws ServletException, IOException &#123;</span><br><span class="line">    Throwable t = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">        final ServletResponse response = prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">        final Subject subject = createSubject(request, response);</span><br><span class="line"></span><br><span class="line">        //noinspection unchecked</span><br><span class="line">        subject.execute(new Callable() &#123;</span><br><span class="line">            public Object call() throws Exception &#123;</span><br><span class="line">                updateSessionLastAccessTime(request, response);</span><br><span class="line">                executeChain(request, response, chain);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略了一些代码，发现 <code>final Subject subject = createSubject(request, response);</code> 每次都会创建一个新的 <code>WebSubject</code> ，那么它是如何取得之前的登录信息呢，不能做一个全局的缓存，因为不能与某一个未认证的用户建立关系，所以有一个感觉，应该是存在于 <code>Session</code> 中,事实上也是如此。看一下 <code>DefaultSecurityManager</code> 中的 <code>Subject createSubject(SubjectContext subjectContext)</code> 方法，该方法会在 <code>login</code> 时，创建 <code>Subject</code> 时，被调用，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext subjectContext) &#123;</span><br><span class="line">    SubjectContext context = copy(subjectContext);</span><br><span class="line">    context = ensureSecurityManager(context);</span><br><span class="line">    context = resolveSession(context);</span><br><span class="line">    context = resolvePrincipals(context);</span><br><span class="line">    Subject subject = doCreateSubject(context);</span><br><span class="line">    save(subject);</span><br><span class="line">    return subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>save</code> 方法 会将认证信息放到 <code>Session</code> 中。在创建 <code>WebSubject</code> 时，会调用 <code>DefaultWebSubjectFactory</code> 去创建 <code>WebSubject</code> ，代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext context) &#123;</span><br><span class="line">    if (!(context instanceof WebSubjectContext)) &#123;</span><br><span class="line">        return super.createSubject(context);</span><br><span class="line">    &#125;</span><br><span class="line">    WebSubjectContext wsc = (WebSubjectContext) context;</span><br><span class="line">    SecurityManager securityManager = wsc.resolveSecurityManager();</span><br><span class="line">    Session session = wsc.resolveSession();</span><br><span class="line">    boolean sessionEnabled = wsc.isSessionCreationEnabled();</span><br><span class="line">    PrincipalCollection principals = wsc.resolvePrincipals();</span><br><span class="line">    boolean authenticated = wsc.resolveAuthenticated();</span><br><span class="line">    String host = wsc.resolveHost();</span><br><span class="line">    ServletRequest request = wsc.resolveServletRequest();</span><br><span class="line">    ServletResponse response = wsc.resolveServletResponse();</span><br><span class="line"></span><br><span class="line">    return new WebDelegatingSubject(principals, authenticated, host, session, sessionEnabled,</span><br><span class="line">            request, response, securityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有很多的 <code>wsc.resolveXXXX</code> 这类的代码，就可以看到其在执行过程，最终会落实到从 <code>Session</code> 中取数据。最后附上所有的Filter的类关系图:</p><center><img src="/pics/Shiro-Filter.png" alt=""></center><h3 id="3-_@RequiresPermissions_这些注解是如何生效的？">3. <code>@RequiresPermissions</code> 这些注解是如何生效的？</h3><p>在 <code>Shiro</code> 对AOP提供了两种支持，一种支持 <code>AOP Alliance</code>，另一种是 <code>Shiro</code> 自己定义的AOP接口。因为在 <code>Spring</code> 中是用的 <code>AOP Alliance</code> 所定义的接口。粗略地看一下其接口，有如下几个类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Advice</span><br><span class="line">AspectException</span><br><span class="line">ConstructorInterceptor</span><br><span class="line">ConstructorInvocation</span><br><span class="line">Interceptor</span><br><span class="line">Invocation</span><br><span class="line">Joinpoint</span><br><span class="line">MethodInterceptor</span><br><span class="line">MethodInvocation</span><br></pre></td></tr></table></figure><p>针对 AOP ，此处提出了两个概念 <code>Advice</code> 和 <code>Joinpoint</code>， <code>Joinpoint</code> 代表切面的对象，<code>Advice</code> 代表对该切面点的处理。而所有的 <code>Interceptor</code> 是 <code>Advice</code>，而所有的 <code>Invocation</code> 代表 <code>Joinpoint</code>。在 <code>Shiro</code> 项目中的 <code>aspectj</code> 的模块中，有一个 <code>ShiroAnnotationAuthorizingAspect</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Aspect()</span><br><span class="line">public class ShiroAnnotationAuthorizingAspect &#123;</span><br><span class="line"></span><br><span class="line">    private static final String pointCupExpression =</span><br><span class="line">            &quot;execution(@org.apache.shiro.authz.annotation.RequiresAuthentication * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresGuest * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresPermissions * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresRoles * *(..)) || &quot; +</span><br><span class="line">                    &quot;execution(@org.apache.shiro.authz.annotation.RequiresUser * *(..))&quot;;</span><br><span class="line"></span><br><span class="line">    @Pointcut(pointCupExpression)</span><br><span class="line">    public void anyShiroAnnotatedMethod()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(pointCupExpression)</span><br><span class="line">    void anyShiroAnnotatedMethodCall(JoinPoint thisJoinPoint) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private AspectjAnnotationsAuthorizingMethodInterceptor interceptor =</span><br><span class="line">            new AspectjAnnotationsAuthorizingMethodInterceptor();</span><br><span class="line"></span><br><span class="line">    @Before(&quot;anyShiroAnnotatedMethodCall(thisJoinPoint)&quot;)</span><br><span class="line">    public void executeAnnotatedMethod(JoinPoint thisJoinPoint) throws Throwable &#123;</span><br><span class="line">        interceptor.performBeforeInterception(thisJoinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我想大概应该很熟悉了，其关键点在于 <code>interceptor.performBeforeInterception(thisJoinPoint)</code> 这行代码，顺着这条线看下去，会在 <code>AnnotationsAuthorizingMethodInterceptor</code> 类里看到这样一个方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void assertAuthorized(MethodInvocation methodInvocation) throws AuthorizationException &#123;</span><br><span class="line">    //default implementation just ensures no deny votes are cast:</span><br><span class="line">    Collection&lt;AuthorizingAnnotationMethodInterceptor&gt; aamis = getMethodInterceptors();</span><br><span class="line">    if (aamis != null &amp;&amp; !aamis.isEmpty()) &#123;</span><br><span class="line">        for (AuthorizingAnnotationMethodInterceptor aami : aamis) &#123;</span><br><span class="line">            if (aami.supports(methodInvocation)) &#123;</span><br><span class="line">                aami.assertAuthorized(methodInvocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>getMethodInterceptors()</code> 返回的是在构造函数初始化的几个 <code>Interceptor</code>，其代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methodInterceptors = new ArrayList&lt;AuthorizingAnnotationMethodInterceptor&gt;(5);</span><br><span class="line">methodInterceptors.add(new RoleAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new PermissionAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new AuthenticatedAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new UserAnnotationMethodInterceptor());</span><br><span class="line">methodInterceptors.add(new GuestAnnotationMethodInterceptor());</span><br></pre></td></tr></table></figure><p>结合上面的两段代码，再看一下这几个 <code>Interceptor</code> 我想你就能够明白了，根据其注解的类型，选择相应的 <code>Interceptor</code> 去进行处理，其处理的过程，最终会在相应的 <code>AnnotationHandler</code> 中进行处理。</p><h3 id="4-_总结">4. 总结</h3><p>以上就是通过带着问题的方式，去看 <code>Shiro</code> 如何去 <code>Spring</code> 的集成，其中省略了很多的代码，上面展示的只是看代码的一个过程，及其最终的结果，中间的步骤，需要大家根据其中的思路继续深入，才能理解在这个框架中，给我们带来的思想与灵感。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_引入&quot;&gt;0. 引入&lt;/h3&gt;&lt;p&gt;在对 &lt;code&gt;Shiro&lt;/code&gt; 的使用中，更多的是用在 &lt;code&gt;Spring MVC&lt;/code&gt; 中，那么 &lt;code&gt;Shiro&lt;/code&gt; 是如何集成到 &lt;code&gt;Spring MVC&lt;/code&gt;
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-01-简介</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro-01-%E7%AE%80%E4%BB%8B/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro-01-简介/</id>
    <published>2019-03-12T05:48:38.586Z</published>
    <updated>2019-03-12T05:48:38.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>Apache Shiro 是一个强大、灵活的安全框架，提供认证、授权、Session管理和加密服务。其构架如下:</p><center><img src="/pics/ShiroArchitecture.png" alt=""></center><p>涉及到如下的几个核心概念:</p><ol><li>Subject<br>代表任意的请求发起方，可以是浏览器、爬</li><li>SecurityManager<br>是Shiro框架的核心，负责Shiro内部组件的协调，以保证整个功能的正确性</li><li>Authenticator<br>认证器，负责校验访问者的身份</li><li>Authorizer<br>授权器，用于确认访问者的权限，每一个访问，都需要得到Authorizer的认可后，才可以访问</li><li>Session Manager<br>负责 Session 的管理</li><li>Cache Manager<br>缓存管理，对Shiro框架中所有需要使用到的缓存的地方提供支持</li><li>Session Dao<br>对 Session 进行存储</li><li>Realm<br>通常根据用户的需求去定制，负责用户身份的认证与权限鉴别</li><li>Cryptography<br>加密服务</li><li>principals<br>即主体的标识属性，通常是用户名，需要保持其唯一性，可以存在多个principals，但是只有一个Primary principals</li><li>credentials<br>即只有Subject才知道的安全值，如密码/数字证书</li></ol><h3 id="1-_源码包的目录简介">1. 源码包的目录简介</h3><center><img src="/pics/Shiro源码目录.png" alt=""></center><ol><li>all<br>打包</li><li>cache<br>Shiro 对于缓存的封装</li><li>config<br>用于解析配置文件， 支持 Ini 和 OGDL 方式</li><li>core<br>Shiro 的核心逻辑</li><li>crypto<br>加密模板，提供了对 JCA 的支持</li><li>event<br>事件机制的封装</li><li>integration-tests、test-coverage<br>测试</li><li>lang<br>各个模板都会用到的类</li><li>samples<br>例子</li><li>support<br>提供了一些常用的支持</li><li>tools</li><li>web<br>提供对 Web 的支持</li></ol><h3 id="2-_会通过如下的角度去分析Shiro框架">2. 会通过如下的角度去分析Shiro框架</h3><ol><li>通过Ini文件的方式，分析登录、登出的过程</li><li>Shiro的框架结构</li><li>如何与Spring集成</li><li>在Shiro中是如何实现独立的Session</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;Apache Shiro 是一个强大、灵活的安全框架，提供认证、授权、Session管理和加密服务。其构架如下:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/pics/ShiroArchitecture.png&quot; alt=
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-02-Ini配置下的登录、登出</title>
    <link href="https://coolwcan.cn/Shiro/Shiro/Shiro-02-Ini%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA/"/>
    <id>https://coolwcan.cn/Shiro/Shiro/Shiro-02-Ini配置下的登录、登出/</id>
    <published>2019-03-12T05:48:38.586Z</published>
    <updated>2019-03-12T05:48:38.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_例子入口">0. 例子入口</h3><p>配置文件shiro.ini如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">root = secret, admin</span><br><span class="line">guest = guest, guest</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin = *</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure></p><p>源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">SecurityManager securityManager = factory.getInstance();</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line"></span><br><span class="line">if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    // 3</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    try &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (currentUser.isAuthenticated()) &#123;</span><br><span class="line">    // 表明用户已经登录</span><br><span class="line">&#125;</span><br><span class="line">// 4</span><br><span class="line">if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;</span><br><span class="line">    log.info(&quot;May the Schwartz be with you!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 5</span><br><span class="line">if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;</span><br><span class="line">    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;</span><br><span class="line">    log.info(&quot;You are permitted to &apos;drive&apos; the winnebago with license plate (id) &apos;eagle5&apos;.  &quot; +</span><br><span class="line">            &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 6</span><br><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure></p><h3 id="1-_分析">1. 分析</h3><h4 id="1-1-_步骤1，创建_SecurityManager，_并读取_shiro-ini">1.1. 步骤1，创建 SecurityManager， 并读取 <code>shiro.ini</code></h4><p>其初始化函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public IniSecurityManagerFactory() &#123;</span><br><span class="line">    this.builder = new ReflectionBuilder();</span><br><span class="line">&#125;</span><br><span class="line">public IniSecurityManagerFactory(Ini config) &#123;</span><br><span class="line">    this();</span><br><span class="line">    setIni(config);</span><br><span class="line">&#125;</span><br><span class="line">public IniSecurityManagerFactory(String iniResourcePath) &#123;</span><br><span class="line">    this(Ini.fromResourcePath(iniResourcePath));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>根据传过来的路径，生成了 Ini 对象，Ini 对象保存着 <code>shiro.ini</code> 中记录的数据，并自动在 FactoryBean 中生成了 <code>ReflectionBuilder</code>。</li><li>在 <code>getInstance</code> 这个方法中，会去调用 <code>IniSecurityManagerFactory</code> 中的 <code>createInstance</code> 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected SecurityManager createInstance(Ini ini) &#123;</span><br><span class="line">    if (CollectionUtils.isEmpty(ini)) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;Ini argument cannot be null or empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager securityManager = createSecurityManager(ini);</span><br><span class="line">    if (securityManager == null) &#123;</span><br><span class="line">        String msg = SecurityManager.class + &quot; instance cannot be null.&quot;;</span><br><span class="line">        throw new ConfigurationException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    return securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在<code>createSecurityManager</code> 方法中，创建了 <code>SecurityManager</code> 和 <code>IniRealm</code></li><li>而在 <code>ReflectionBuilder</code> 中创建了默认的 <code>DefaultEventBus</code></li><li>通过<code>ReflectionBuilder</code> 的 <code>buildObjects</code> 方法的 <code>LifecycleUtils.init(objects.values());</code> 去初始化这三个创建的类</li><li>在 <code>IniRealm</code> 的初始化 (onInit方法)过程中，会将 <code>shiro.ini</code> 中配置的user和role创建对应的 <code>SimpleAccount</code> 和 <code>SimpleRole</code>。</li><li><code>Subject currentUser = SecurityUtils.getSubject();</code> 这一行代码，会创建 Subject, SubjectContext，创建好的 Subject 将会存储在 ThreadContext 中，而 SubjectContext 用于记录在创建 Subject 中会用到的数据，如 SecurityManager、Session、Host等</li><li><p>创建 Subject 是由 <code>DefaultSubjectFactory</code> 的 <code>createSubject</code> 方法:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Subject createSubject(SubjectContext context) &#123;</span><br><span class="line">    SecurityManager securityManager = context.resolveSecurityManager();</span><br><span class="line">    Session session = context.resolveSession();</span><br><span class="line">    boolean sessionCreationEnabled = context.isSessionCreationEnabled();</span><br><span class="line">    PrincipalCollection principals = context.resolvePrincipals();</span><br><span class="line">    boolean authenticated = context.resolveAuthenticated();</span><br><span class="line">    String host = context.resolveHost();</span><br><span class="line"></span><br><span class="line">    return new DelegatingSubject(principals, authenticated, host, session, sessionCreationEnabled, securityManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码会创建一个 <code>DelegatingSubject</code>，在后续的过程中，会通过SubjectDAO缓存创建的 <code>DelegatingSubject</code></p></li></ol><h4 id="1-2_步骤2,_Session">1.2 步骤2, Session</h4><p>在创建的 Session 的过程中，会调用 <code>AbstractValidatingSessionManager</code> 的 <code>createSession</code> 方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Session createSession(SessionContext context) throws AuthorizationException &#123;</span><br><span class="line">    enableSessionValidationIfNecessary();</span><br><span class="line">    return doCreateSession(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>会先创建 <code>SessionValidationScheduler</code>，用于定期清除过期的 Session</li><li><p>会由  <code>SimpleSessionFactory</code> 的 <code>createSession</code>方法创建 Session, 如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Session createSession(SessionContext initData) &#123;</span><br><span class="line">    if (initData != null) &#123;</span><br><span class="line">        String host = initData.getHost();</span><br><span class="line">        if (host != null) &#123;</span><br><span class="line">            return new SimpleSession(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建完成后，会通过 SessionDAO，存储到一个Map中，以作缓存</p></li><li>为了便于用户使用，而又不影响Map缓存的Session，会创建了一个 <code>DelegatingSession</code> 去包裹真实的Session</li><li>在 Subject 的层面，创建了一个 <code>StoppingAwareProxiedSession</code> ，重写了 <code>stop</code> 方法，当调用 <code>stop()</code> 方法时，会将Subject中的session置空</li></ol><h4 id="1-3_步骤3,_登录过程">1.3 步骤3, 登录过程</h4><p>会调用 <code>DelegatingSubject</code> 的 <code>login</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void login(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    Subject subject = securityManager.login(this, token);</span><br><span class="line">    // 将创建的新的 subject 的属性值放到当前 DelegatingSubject 中，因为针对外界而言，引用的是之前的那一个Subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>登录过程是委托给 <code>securityManager</code> 的 <code>login</code> 方法，</li><li>在该过程中，会调用 <code>ModularRealmAuthenticator</code> 的 <code>doAuthenticate</code> 方法，最终转到 <code>IniRealm</code> 的 <code>getAuthenticationInfo</code>，最后转到 <code>SimpleAccountRealm</code> 的 <code>doGetAuthenticationInfo</code> 方法，从而得到 <code>SimpleAccount</code> 对象，即 IniRealm 根据 <code>shiro.ini</code> 创建的对象。</li></ol><h4 id="1-4_步骤4，角色检查">1.4 步骤4，角色检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasRole(String roleIdentifier) &#123;</span><br><span class="line">    return hasPrincipals() &amp;&amp; securityManager.hasRole(getPrincipals(), roleIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是委托给 <code>securityManager</code> ，中间经过 ModularRealmAuthenticator、IniReaml，最终转到 <code>SimpleAccountRealm</code> 中进行权限的检查</p><h4 id="1-5_步骤5,_权限检查">1.5 步骤5, 权限检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPermitted(String permission) &#123;</span><br><span class="line">    return hasPrincipals() &amp;&amp; securityManager.isPermitted(getPrincipals(), permission);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与角色检查的过程类似，委托给 <code>securityManager</code> ，中间经过 ModularRealmAuthenticator、IniReaml，最终转到 <code>SimpleAccountRealm</code>，获取所有的权限对象，让权限对象自己去校验是否拥有权限</p><h4 id="1-6_步骤6,_登出">1.6 步骤6, 登出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void logout() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        clearRunAsIdentitiesInternal();</span><br><span class="line">        this.securityManager.logout(this);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        this.session = null;</span><br><span class="line">        this.principals = null;</span><br><span class="line">        this.authenticated = false;</span><br><span class="line">        //Don&apos;t set securityManager to null here - the Subject can still be</span><br><span class="line">        //used, it is just considered anonymous at this point.  The SecurityManager instance is</span><br><span class="line">        //necessary if the subject would log in again or acquire a new session.  This is in response to</span><br><span class="line">        //https://issues.apache.org/jira/browse/JSEC-22</span><br><span class="line">        //this.securityManager = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>登出的过程，同样的是委托给 <code>securityManager</code>，如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void logout(Subject subject) &#123;</span><br><span class="line"></span><br><span class="line">    if (subject == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Subject method argument cannot be null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beforeLogout(subject);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals = subject.getPrincipals();</span><br><span class="line">    if (principals != null &amp;&amp; !principals.isEmpty()) &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(&quot;Logging out subject with primary principal &#123;&#125;&quot;, principals.getPrimaryPrincipal());</span><br><span class="line">        &#125;</span><br><span class="line">        Authenticator authc = getAuthenticator();</span><br><span class="line">        if (authc instanceof LogoutAware) &#123;</span><br><span class="line">            ((LogoutAware) authc).onLogout(principals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        delete(subject);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (log.isDebugEnabled()) &#123;</span><br><span class="line">            String msg = &quot;Unable to cleanly unbind Subject.  Ignoring (logging out).&quot;;</span><br><span class="line">            log.debug(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            stopSession(subject);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (log.isDebugEnabled()) &#123;</span><br><span class="line">                String msg = &quot;Unable to cleanly stop Session for Subject [&quot; + subject.getPrincipal() + &quot;] &quot; +</span><br><span class="line">                        &quot;Ignoring (logging out).&quot;;</span><br><span class="line">                log.debug(msg, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>登出的过程会经过如下几个步骤:</p><ol><li>如果存在 <code>RememberMeManager</code>，则清除Cookie</li><li>通知实现了 <code>LogoutAware</code> 接口的 <code>Authenticator</code></li><li>删除缓存的 <code>Subject</code></li><li>修改 Session 的 <code>stopTimestamp</code> 字段</li></ol></li></ol><h3 id="2-_总结">2. 总结</h3><p>以下，便是以代码的角度粗略地看了一下 Shiro 框架给我们带来的些</p><ol><li>SecurityManager 代表了整个框架，而 Subject 代表了所有的访问者</li><li>只有显示调用 <code>getSession</code> 才会创建 Session</li><li>所有的认证与授权都是通过 <code>Realm</code> 实现的</li><li>在整个过程中，都会使用缓存, <code>SubjectDAO</code> 和 <code>SessionDAO</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_例子入口&quot;&gt;0. 例子入口&lt;/h3&gt;&lt;p&gt;配置文件shiro.ini如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="Shiro" scheme="https://coolwcan.cn/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="https://coolwcan.cn/tags/Shiro/"/>
    
      <category term="Source codes analysis" scheme="https://coolwcan.cn/tags/Source-codes-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Xss攻击</title>
    <link href="https://coolwcan.cn/Security/Security/Xss%E6%94%BB%E5%87%BB/"/>
    <id>https://coolwcan.cn/Security/Security/Xss攻击/</id>
    <published>2019-03-12T05:48:38.585Z</published>
    <updated>2019-03-12T05:48:38.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-_概念">0. 概念</h2><ol><li>XSS<br>Cross Site Scripting, 跨站脚本攻击</li><li>常用手段<br>攻击者通常会在有漏洞的程序中插入javascript, VBScript, ActiveX或Flash以欺骗用户，盗取用户账户，修改用户设置，盗取/污染cookie，做虚假广告。</li></ol><h2 id="1-_预防">1. 预防</h2><ol><li>完善的过滤体系<br>不合法的输入，一概过滤</li><li>html encode<br>对html标签进行转码，页面仅仅显示转码后的内容。这仅仅适用于已经确定内容中不存在html的情况</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-_概念&quot;&gt;0. 概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;XSS&lt;br&gt;Cross Site Scripting, 跨站脚本攻击&lt;/li&gt;
&lt;li&gt;常用手段&lt;br&gt;攻击者通常会在有漏洞的程序中插入javascript, VBScript, ActiveX或Flash以欺
      
    
    </summary>
    
      <category term="Security" scheme="https://coolwcan.cn/categories/Security/"/>
    
    
      <category term="Security" scheme="https://coolwcan.cn/tags/Security/"/>
    
      <category term="Xss" scheme="https://coolwcan.cn/tags/Xss/"/>
    
  </entry>
  
  <entry>
    <title>DDoS</title>
    <link href="https://coolwcan.cn/Security/Security/DDoS/"/>
    <id>https://coolwcan.cn/Security/Security/DDoS/</id>
    <published>2019-03-12T05:48:38.585Z</published>
    <updated>2019-03-12T05:48:38.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-_DDoS攻击">一. DDoS攻击</h2><p>DDoS攻击(分布式拒绝服务攻击), 是拒绝服务(DoS)的一种，用分布式的客户端，向服务提供者发起大量看似合法的请求，消耗或长期占用大量资源，从而达到拒绝服务的目的。</p><h2 id="二-_攻击方式">二. 攻击方式</h2><h4 id="1-_消耗网络宽带资源：">1. 消耗网络宽带资源：</h4><p>互联网基础设施的数据包处理能力都是存在上限的，攻击者发送大量网络数据包，使正常请求无法得到正常. 有效的响应，造成服务拒绝。  </p><ol><li>直接攻击：使用大量受控主机直接向攻击目标发送大量数据包，达到服务拒绝的目的。常见的有ICMP/IGMP洪水攻击，与UDP攻击，不过攻击者容易被发现。</li><li>反射攻击：又称为DRDoS，攻击者伪装成受害人，欺骗路由器或服务器产生大量响应，进而攻击受害者；ACK应答，DNS响应数据，NTP及SNMP等协议的响应数据等都可以成为攻击方式<center><img src="/pics/ddos-1.jpg" alt=""></center></li><li>攻击链路：与其它攻击方式有所不同，其攻击的目标并不是作为互联网端点的服务器的宽带资源，而是骨干网上的链路的宽带资源<center><img src="/pics/ddos-2.jpg" alt=""></center></li></ol><h4 id="2-_消耗系统资源">2. 消耗系统资源</h4><p>终端设备与服务器进行通信时，会大量使用系统资源。DDoS通过人为增加连接资源进行消耗和占用，阻止正常连接的建立，从而达到拒绝服务的目的。攻击TCP连接：</p><ol><li>TCP的三次握手<center><img src="/pics/ddos-3.jpg" alt=""></center></li><li>SYN洪水攻击：是最经典的一种形式，通过短时间内产生大量的TCP半开连接，实现攻击</li><li>攻击SSL连接：安全套接层(SSL)协议密钥协商。加密和解密的过程中消耗大量的系统资源，这也达成了攻击的目标。攻击者只需要让服务器不停地去解密和验证，就能够产生大量消耗服务器的计算资源。</li></ol><h4 id="3-_消耗应用资源">3. 消耗应用资源</h4><p>消耗应用资源的DDoS正逐渐成为拒绝服务攻击的主要手段之一。而由于DNS和Web服务的广泛性和重要性，这两种服务也成为了消耗应用资源的分布式拒绝服务攻击的最主要的攻击目标。</p><ol><li>攻击DNS服务：在DNS解析的过程中，客户端发起一次查询请求，DNS服务器可能需要进行额外的多次查询才能给出应答，常见的DNS Query与DNS NXDomain两种攻击。而DNS NXDomain会消耗更多的DNS本地缓存，危害更大。</li><li>攻击Web服务：<ol><li>大量正常的HTTP请求</li><li>不完整的HTTP请求</li><li>慢速的HTTP长连接</li><li>构造恶意的HTTP请求</li></ol></li></ol><h2 id="三-_防范：">三. 防范：</h2><p>过滤网络，过滤出正常的请求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-_DDoS攻击&quot;&gt;一. DDoS攻击&lt;/h2&gt;&lt;p&gt;DDoS攻击(分布式拒绝服务攻击), 是拒绝服务(DoS)的一种，用分布式的客户端，向服务提供者发起大量看似合法的请求，消耗或长期占用大量资源，从而达到拒绝服务的目的。&lt;/p&gt;
&lt;h2 id=&quot;二-_攻击方式
      
    
    </summary>
    
      <category term="Security" scheme="https://coolwcan.cn/categories/Security/"/>
    
    
      <category term="Security" scheme="https://coolwcan.cn/tags/Security/"/>
    
      <category term="DDos" scheme="https://coolwcan.cn/tags/DDos/"/>
    
  </entry>
  
</feed>
