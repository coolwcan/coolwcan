<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coolwcan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coolwcan.cn/"/>
  <updated>2019-04-01T07:16:45.110Z</updated>
  <id>https://coolwcan.cn/</id>
  
  <author>
    <name>coolwcan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双括号初始化</title>
    <link href="https://coolwcan.cn/Java/Java/%E5%8F%8C%E6%8B%AC%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://coolwcan.cn/Java/Java/双括号初始化/</id>
    <published>2019-04-01T07:16:40.757Z</published>
    <updated>2019-04-01T07:16:45.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol><li>双括号初始化</li><li>在new出类的同时，使用双括号，并对该对象进行初始化</li></ol><h3 id="二-_详细">二. 详细</h3><ol><li><p>例子</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final Set&lt;String&gt; VALID_CODES = new HashSet&lt;String&gt;() &#123; &#123; </span><br><span class="line">    add(&quot;XZ13s&quot;);</span><br><span class="line">    add(&quot;AB21/X&quot;);</span><br><span class="line">    add(&quot;YYLEX&quot;);</span><br><span class="line">    add(&quot;AR2D&quot;);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>类似于</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; validCodes = new HashSet&lt;String&gt;();</span><br><span class="line">validCodes.add(&quot;XZ13s&quot;);</span><br><span class="line">validCodes.add(&quot;AB21/X&quot;);</span><br><span class="line">validCodes.add(&quot;YYLEX&quot;);</span><br><span class="line">validCodes.add(&quot;AR2D&quot;);</span><br></pre></td></tr></table></figure></li><li><p>解析</p><ol><li>第一层括弧，实际是定义了一个内部匿名类</li><li>第二层括弧，实际上是一个实例初始化块</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-_概念&quot;&gt;一. 概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;双括号初始化&lt;/li&gt;
&lt;li&gt;在new出类的同时，使用双括号，并对该对象进行初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二-_详细&quot;&gt;二. 详细&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;例子&lt;/p&gt;
 &lt;figure
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的注解</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
    <id>https://coolwcan.cn/Java/Java/Java中的注解/</id>
    <published>2019-04-01T07:16:17.516Z</published>
    <updated>2019-04-01T07:16:25.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-_概念">0. 概念</h2><ol><li>元数据<br>数据的数据</li><li>注解也是描述数据</li><li><p>java中常见的注解</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @Override，表明重写父类方法</span><br><span class="line">2. @Deprecated，表示方法是不被建议使用的</span><br><span class="line">3. @SuppressWarnings</span><br></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>增加代码的可读性</li><li>用来简化程序中的配置</li></ol></li></ol><h2 id="1-_详细">1. 详细</h2><ol><li><p>格式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(注解保存的类型)</span><br><span class="line">@Target(注解作用的对象)</span><br><span class="line">public @interface InterfaceName &#123;</span><br><span class="line">String value() default &quot;abc&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>@Documented</code><br> 用于表明注释，会被加入到 <code>javadoc</code> 中</li><li><code>@Inherited</code><br> 表明允许子类继承父类中的注解</li><li><p><code>@Target</code><br>  用于描述该注解用于什么地方</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. ElemenetType.CONSTRUCTOR      构造器声明</span><br><span class="line">2. ElemenetType.FIELD            域声明（包括 enum 实例）</span><br><span class="line">3. ElemenetType.LOCAL_VARIABLE   局部变量声明</span><br><span class="line">4. ElemenetType.METHOD           方法声明</span><br><span class="line">5. ElemenetType.PACKAGE          包声明</span><br><span class="line">6. ElemenetType.PARAMETER        参数声明</span><br><span class="line">7. ElemenetType.TYPE             类，接口（包括注解类型）或enum声明</span><br><span class="line">8. ElementType.ANNOTATION_TYPE   注解</span><br></pre></td></tr></table></figure></li><li><p><code>@Retention</code><br> 用于描述在什么时候保存该注解信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. RetentionPolicy.SOURCE   注解将被编译器丢弃</span><br><span class="line">2. RetentionPolicy.CLASS    注解在class文件中可用，但会被VM丢弃</span><br><span class="line">3. RetentionPolicy.RUNTIME  JVM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</span><br></pre></td></tr></table></figure></li></ol></li><li><p>获取注解信息  </p><p> 注解类：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">/*</span><br><span class="line"> * 定义注解 Test</span><br><span class="line"> * 注解中含有两个元素 id 和 description</span><br><span class="line"> * description 元素 有默认值 &quot;hello anntation&quot;</span><br><span class="line"> */</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">public int id();</span><br><span class="line">public String description() default &quot;hello annotation&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TestMain &#123;  </span><br><span class="line">@Test(id = 1, description = &quot;hello methodA&quot;)  </span><br><span class="line">public void methodA() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@Test(id = 2)  </span><br><span class="line">public void methodB() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@Test(id = 3, description = &quot;last method&quot;)  </span><br><span class="line">public void methodC() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">Method[] methods = TestMain.class.getDeclaredMethods();  </span><br><span class="line">for (Method method : methods) &#123;  </span><br><span class="line">boolean hasAnnotation = method.isAnnotationPresent(Test.class);  </span><br><span class="line">if (hasAnnotation) &#123;  </span><br><span class="line">Test annotation = method.getAnnotation(Test.class);  </span><br><span class="line">System.out.println(&quot;Test( method = &quot; + method.getName() + &quot; , id = &quot; + annotation.id() </span><br><span class="line">+ &quot; , description = &quot; + annotation.description() + &quot; )&quot;);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-_概念&quot;&gt;0. 概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;元数据&lt;br&gt;数据的数据&lt;/li&gt;
&lt;li&gt;注解也是描述数据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java中常见的注解&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="Annotation" scheme="https://coolwcan.cn/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Java中的enum类型</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E4%B8%AD%E7%9A%84enum%E7%B1%BB%E5%9E%8B/"/>
    <id>https://coolwcan.cn/Java/Java/Java中的enum类型/</id>
    <published>2019-04-01T07:15:45.814Z</published>
    <updated>2019-04-01T07:15:55.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-_概念">一. 概念</h3><ol><li>enum，全称为enumeration，在JDK 1.5中引入，存放在java.lang包中</li><li>枚举类的所有实例必须在类的第一行列出，否则这个枚举类不会产生对象</li><li>枚举类相对于常量接口和常量类的优势：<ol><li>枚举类不能被继承和扩展</li><li>枚举类的常量地址一样，所以可以用==，直接比较，无需用equal的方法，能够得到性能上的优化</li><li>类型统一</li><li>枚举类不能new出来</li></ol></li><li><code>enum</code> 的本质就是一个 <code>java.lang.Eunm&lt;E&gt;</code> 类的子类</li></ol><h3 id="二-_几种常量定义的方式">二. 几种常量定义的方式</h3><ol><li><p>常量接口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ConstInterfaceA &#123;  </span><br><span class="line">public static final String CONST_A = &quot;aa&quot;;  </span><br><span class="line">public static final String CONST_C = &quot;ac&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConstClassA &#123;  </span><br><span class="line">public static final String CONST_A = &quot;aa&quot;;  </span><br><span class="line">public static final String CONST_C = &quot;ac&quot;;  </span><br><span class="line"></span><br><span class="line">// 避免常量接口的继承</span><br><span class="line">private ConstClassA() &#123;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类</p><ol><li><p>普通形式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Weekday &#123;</span><br><span class="line">MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义属性名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum Entertainment &#123;</span><br><span class="line">SING(&quot;唱歌&quot;, &quot;sing&quot;), GAME(&quot;游戏&quot;, &quot;game&quot;), OTHER(&quot;其它&quot;, &quot;other&quot;);</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private String value;</span><br><span class="line"></span><br><span class="line">Entertainment(String name, String value) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注：</span><br><span class="line">1. 在括号中用多少个字段，就需要有多少个属性</span><br><span class="line">2. 并且一定需要一个带字段的构造函数</span><br><span class="line">3. 只需要 get 方法，没必要有 set 方法</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="三-_编译器对枚举类的处理">三. 编译器对枚举类的处理</h3><ol><li><p>枚举类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;    </span><br><span class="line">RED,BLUE,BLACK,YELLOW,GREEN    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的枚举类</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final enum com.simpletour.Color &#123;    </span><br><span class="line">  </span><br><span class="line">// 所有的枚举值都是类静态常量    </span><br><span class="line">public static final enum com.simpletour.Color RED;    </span><br><span class="line">public static final enum com.simpletour.Color BLUE;    </span><br><span class="line">public static final enum com.simpletour.Color BLACK;    </span><br><span class="line">public static final enum com.simpletour.Color YELLOW;    </span><br><span class="line">public static final enum com.simpletour.Color GREEN;    </span><br><span class="line"></span><br><span class="line">// 保存所有的Values值</span><br><span class="line">private static final synthetic com.simpletour.Color[] ENUM$VALUES;    </span><br><span class="line">  </span><br><span class="line">// 初始化过程，对枚举类的所有枚举值对象进行第一次初始化    </span><br><span class="line">static &#123;    </span><br><span class="line">new com.simpletour.Color    </span><br><span class="line">dup    </span><br><span class="line">ldc &lt;String &quot;RED&quot;&gt;                                                // 把枚举值字符串&quot;RED&quot;压入操作数栈    </span><br><span class="line">iconst_0                                                          // 把整型值0压入操作数栈    </span><br><span class="line">invokespecial com.simpletour.Color(java.lang.String, int)         // 调用Color类的私有构造器创建Color对象RED    </span><br><span class="line">putstatic com.simpletour.Color.RED : com.simpletour.Color         // 将枚举对象赋给Color的静态常量RED。    </span><br><span class="line">.........                                                         // 其它枚举对象与上同    </span><br><span class="line">return    </span><br><span class="line">&#125;;    </span><br><span class="line">  </span><br><span class="line">// 私有构造器，外部不可能动态创建一个枚举类对象</span><br><span class="line">private Color(java.lang.String arg0, int arg1)&#123;    </span><br><span class="line">// 调用父类Enum的受保护构造器创建一个枚举对象    </span><br><span class="line">invokespecial java.lang.Enum(java.lang.String, int);   </span><br><span class="line">&#125;;    </span><br><span class="line"> </span><br><span class="line">public static com.simpletour.Color[] values();    </span><br><span class="line">// 实现Enum类的抽象方法      </span><br><span class="line">public static com.simpletour.Color valueOf(java.lang.String arg0);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四-_通过Enum实现单例">四. 通过Enum实现单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">INSTANCE;// 唯一实例</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(&quot;使用enum实现单例模式&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Singleton sole = Singleton.INSTANCE;</span><br><span class="line">sole.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-_概念&quot;&gt;一. 概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;enum，全称为enumeration，在JDK 1.5中引入，存放在java.lang包中&lt;/li&gt;
&lt;li&gt;枚举类的所有实例必须在类的第一行列出，否则这个枚举类不会产生对象&lt;/li&gt;
&lt;li&gt;枚举类相对于常量
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="Enum" scheme="https://coolwcan.cn/tags/Enum/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://coolwcan.cn/Java/Java/Java异常处理/</id>
    <published>2019-04-01T07:15:11.721Z</published>
    <updated>2019-04-01T07:15:21.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_概念">0. 概念</h3><ul><li>Checked Exception<br>必须被显式捕获，是指所有继承自 <code>Exception</code> 并且不是 <code>RuntimeException</code> 的异常n。编译器会对此作检查，必须捕获或者抛出异常。用于以下语义环境:<ul><li>该异常发生后是可以被恢复的</li><li>程序依赖于不可靠的外部条件，该条件可能出错，如IO异常</li><li>该异常发生后并不会导致程序处理错误，进行一些处理后可以继续后续操作</li></ul></li><li>Unchecked Exception<br>可以不必捕获或抛出，继承自 <code>java.lang.RuntimeException</code> 类，虽然 <code>java.lang.RuntimeException</code> 也是继承自 <code>java.lang.Exception</code>。同时也说明一个事 <code>Unchecked Exception</code> 也是可以被捕获的。</li></ul><h3 id="1-_异常类的层级关系">1. 异常类的层级关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line">|--Error</span><br><span class="line">|--Exception</span><br><span class="line">      |-- IOException</span><br><span class="line">      |        |-- EOFException</span><br><span class="line">      |        |-- FileNotFoundException</span><br><span class="line">      |        |-- MalformedURLException</span><br><span class="line">      |        |-- UnknownHostException</span><br><span class="line">      |</span><br><span class="line">      |-- ClassNotFoundException</span><br><span class="line">      |-- CloneNotSupportedException</span><br><span class="line">      |-- RuntimeException</span><br><span class="line">               |-- ArithmeticException</span><br><span class="line">               |-- ClassCastException</span><br><span class="line">               |-- IllegalArgumentException</span><br><span class="line">               |-- IllegalStateException</span><br><span class="line">               |-- IndexOutOfBoundsException</span><br><span class="line">               |-- NoSuchElementException</span><br><span class="line">               |-- NullPointerException</span><br></pre></td></tr></table></figure><h3 id="2-_异常处理中的注意事项">2. 异常处理中的注意事项</h3><ul><li>不要忽略Checked Exception，一般有如下处理方式:<ul><li>处理异常，进行修复以让程序继续执行</li><li>重新抛出异常</li><li>将异常转换为用户可以理解的自定义异常再抛出，这时应该注意不要丢失原始异常信息</li><li>不要捕获异常</li></ul></li><li>不要捕获所有的异常，即捕获Exception，不能分别处理不同的异常</li><li>使用finally块释放资源，会有如下三种情况，会进入到finally块<ul><li>try块中代码正常执行完毕</li><li>在try块中抛出异常</li><li>在try块中执行return，break，continue</li></ul></li><li>异常不能影响对象的状态，因为异常，所以如果此时，不恢复状态的话，可能会使接下来的系统产生异常，有三个方法可以达到这个目的:<ul><li>将可能产生异常的代码和改变对象状态的代码分开，先执行可能产生异常的代码，如果产生异常，就不执行改变对象状态的代码</li><li>对不容易分离产生异常的代码和改变对象状态的代码的方法时，定义一个recover方法，在异常产生后调用recover方法修复被改变的类变量，恢复方法调用前的类状态</li><li>在方法中使用对象的拷贝，这样当异常发生后，被影响的只是拷贝，对象本身不会受到影响</li></ul></li><li>不要丢失异常</li><li>不要使用同时使用异常机制和返回值同时来进行异常处理<ul><li>不易理解，维护麻烦</li></ul></li><li>不要让try块过于庞大<ul><li>不易于阅读</li><li>使用try捕获异常是以程序执行效率为代价的，将不需要捕获异常的代码包含在try块中，影响了代码执行的效率</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_概念&quot;&gt;0. 概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Checked Exception&lt;br&gt;必须被显式捕获，是指所有继承自 &lt;code&gt;Exception&lt;/code&gt; 并且不是 &lt;code&gt;RuntimeException&lt;/code&gt; 的异常n。编译器会对此
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="Exception" scheme="https://coolwcan.cn/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Java-Stream</title>
    <link href="https://coolwcan.cn/Java/Java/Java-Stream/"/>
    <id>https://coolwcan.cn/Java/Java/Java-Stream/</id>
    <published>2019-04-01T07:13:34.574Z</published>
    <updated>2019-04-01T07:21:01.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_流的分类">0. 流的分类</h3><ol><li>按处理的数据单位进行分类<br>字节流、字符流。字节流主要是指 <code>InputStream</code> 和 <code>OutputStream</code> 及其子类；字符流，主要是指 <code>Reader</code> 和 <code>Writer</code> 及其子类。</li><li>按数据流的方向进行分类<br>输入流、输出流。输入流是指 <code>InputStream</code> 和 <code>Reader</code> 及其子类；输出流是指 <code>OutputStream</code> 和 <code>Writer</code> 及其子类。</li><li>按功能进行分类<br>节点流、处理流。节点流是直接从一个数据源读取数据。例如： <code>FileInputStream</code> 和 <code>FileOutputStream</code>；处理流，针对现有的一个流进行包装，从而提供针对该流更多的功能。例如： <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>；</li></ol><h3 id="1-_流的继承体系">1. 流的继承体系</h3><ul><li><code>InputStream</code> 与 <code>OutputStream</code><br> 数据的单位是<strong>单字节</strong>，其中深色为节点流，浅色为处理流</li></ul><center><img src="./pics/Java-InputStream.png" alt="InputStream"></center><br><center><img src="./pics/Java-OutputStream.png" alt="OutputStream"></center><pre><code>-<span class="ruby"> <span class="string">`FileInputStream / FileOutputStream`</span> 主要用于处理文件</span>-<span class="ruby"> <span class="string">`PipedInputStream / PipedOutputStream`</span> 管道，不能在同一个线程中使用，会造成死锁</span>-<span class="ruby"> <span class="string">`ByteArrayInputStream / ByteArrayOutputStream`</span> 字节数组，常常用于缓存数组，在其关掉流后，数据仍然存在。并且能够自动拓容</span>-<span class="ruby"> <span class="string">`ObjectInputStream / ObjectOutputStream`</span> 对于 <span class="constant">Java</span> 对象的序列化与反序列化，其中对象的 <span class="string">`transient`</span> 和 <span class="string">`static`</span> 类型成员变量不会被读取和写入</span>-<span class="ruby"> <span class="string">`FilterInputStream / FilterOutputStream`</span> 用于输入流和输出流提供包装</span>-<span class="ruby"> <span class="string">`DataInputStream / DataOutputStream`</span> 能够实现与机器无关方式众底层输入流中读取基本 <span class="constant">Java</span> 数据类型</span>-<span class="ruby"> <span class="string">`BufferedInputStream / BufferedOutputStream`</span> 默认缓存是<span class="number">8</span>M，能够减少磁盘访问次数，提高文件读取/写入性能。</span>-<span class="ruby"> <span class="string">`SequenceInputStream`</span> 用于将多个流进行合并</span>-<span class="ruby"> <span class="string">`PushbackInputStream`</span> 允许试探性地从流里取数据，然后再将读取的数据返还回去。</span></code></pre><ul><li><p><code>Reader</code> 和 <code>Writer</code><br> 数据的单位是<strong>2字节</strong>，深色为节点流，浅色为处理流</p><p> <img src="/pics/Java-Reader.png" alt="Reader"><br> <img src="/pics/Java-Writer.png" alt="Writer"></p><p>  <code>Reader</code>、<code>Writer</code> 与 <code>InputStream</code>、<code>OutputStream</code> 相对应，只是其处理的数据单位不同。</p></li></ul><h3 id="2-_处理流整理">2. 处理流整理</h3><ol><li>InputStream:<br><code>FilterInputStream</code>、<code>LineNumberInputStream</code>、<code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushbackInputStream</code>、<code>SequenceInputStream</code>、<code>ObjectInputStream</code></li><li>OutputStream<br><code>FilterOutputStream</code>、<code>DataOutputStream</code>、<code>BufferedOutputStream</code>、<code>PrintStream</code>、<code>ObjectOutputStream</code></li><li>Reader<br><code>BufferedReader</code>、<code>LineNumberReader</code>、<code>InputStreamReader</code>、<code>FilterReader</code>、<code>PushbackReader</code></li><li>Writer<br><code>BufferedWriter</code>、<code>OutputStreamWriter</code>、<code>FilterWriter</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_流的分类&quot;&gt;0. 流的分类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按处理的数据单位进行分类&lt;br&gt;字节流、字符流。字节流主要是指 &lt;code&gt;InputStream&lt;/code&gt; 和 &lt;code&gt;OutputStream&lt;/code&gt; 及其子类；字符流，主要是指 &lt;co
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="Stream" scheme="https://coolwcan.cn/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java引用</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E5%BC%95%E7%94%A8/"/>
    <id>https://coolwcan.cn/Java/Java/Java引用/</id>
    <published>2019-04-01T07:12:59.220Z</published>
    <updated>2019-04-01T07:20:48.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>当 <code>JVM</code> 的内存不足时，会发生 <code>GC</code>，而对象的 <code>GC</code> 依赖该对象是否存在引用。引用的分类如下:</p><ul><li><code>StrongReference</code><br>强引用，即使内存不足，<code>JVM</code> 也不会回收强引用的对象，只出报出 <code>OOM</code> 异常</li><li><code>SoftReference</code><br> 软引用，在内存充足的情况不会回收该对象；当因内存不足将要抛出 <code>OOM</code> 异常时，就会回收此类对象<ul><li>将 <code>SoftReference</code> 对象的 <code>referent</code> 域设置为 <code>null</code>，从而使该对象不再引用 <code>heap</code> 对象</li><li><code>SoftReference</code> 将引用的内存堆上的对象生命标记为 <code>finalizable</code></li><li>当内存堆上的对象 <code>finalize()</code> 方法被运行而且该对象占用的内存被释放</li></ul></li><li><code>WeakReference</code><br> 弱引用，在 <code>GC</code> 过程中，一旦被发现将会被删除<ul><li>将 <code>WeakReference</code> 对象的 <code>referent</code> 域设置成为 <code>null</code>，从而使该对象不再引用heap对象。</li><li><code>WeakReference</code> 引用过的内存堆上的对象生命标记为 <code>finalizable</code>。</li><li>当内存堆上的对象 <code>finalize()</code> 方法被运行而且该对象占用的内存被释放</li></ul></li><li><code>PhantomReference</code><br> 虚引用，与正常的对象行为一致， 仅仅是当该对象被清除时，通过 <code>ReferenceQueue</code> 得到其被清除的通知而已，通常用于清除资源。其清除过程：<ul><li><code>PhantomReference</code> 引用过的 <code>heap</code> 对象声明为 <code>finalizable</code></li><li>虚引用在堆对象释放之前就添加到了它的 <code>ReferenceQueue</code> 里面，这种情况使得我们可以在堆对象被回收之前采取操作</li></ul></li></ul><p><code>WeakReference</code>、<code>SoftReference</code>、<code>PhantomReference</code> 如果存在相关联的 <code>ReferenceQueue</code>，其引用的对象的内存被释放后，<code>Reference</code> 对象将被加入到 <code>ReferenceQueue</code> 里面。注意是 <code>Reference</code> 对象，而非被引用的对象，被引用的对象已经被删除。</p><h3 id="1-_利用_ReferenceQueue_实现_SoftHashMap">1. 利用 <code>ReferenceQueue</code> 实现 <code>SoftHashMap</code></h3><p><code>ReferenceQueue</code> 通常用于存储已经被 <code>GC</code> 掉的对象的引用对象(<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>)。在 <code>Java</code> 体系中存在一个 <code>WeakHashMap</code>，但是 <code>WeakHashMap</code> 是以 <code>key</code> 为基准去做的 <code>WeakReference</code>，当我们了解到 <code>WeakReference</code> 后，我觉得 <code>WeakReference</code> 并不是一个最优的方案，考虑到实际情况，一个以 <code>Value</code> 为基础的 <code>SoftReference</code> 将是一个更加符合实际情况的、有效的 <code>HashMap</code>。接下来，说一下思路:</p><ol><li>一个最佳实践，并不是当内存不足时，将 <code>HashMap</code> 中的所有数据都进行删除，而会根据 <code>LRU</code> 的思想，保留一定数量的最近经常使用的对象(强引用)</li><li>所有影响 <code>HashMap</code> 大小的操作，需要从 <code>ReferenceQueue</code> 检查并清除已经被GC的数据</li><li>用 <code>SoftReference</code> 去引用 <code>value</code></li></ol><p>网上有一个人专门针对该思路进行了整理: <a href="http://www.javaspecialists.eu/archive/Issue015.html，在" target="_blank" rel="noopener">http://www.javaspecialists.eu/archive/Issue015.html，在</a> <code>Shiro</code> 源码中找到了一个对应的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">public class SoftHashMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">    private static final int DEFAULT_RETENTION_SIZE = 100;</span><br><span class="line">    private final Map&lt;K, SoftValue&lt;V, K&gt;&gt; map;</span><br><span class="line">    private final int RETENTION_SIZE;</span><br><span class="line">    private final Queue&lt;V&gt; strongReferences;</span><br><span class="line">    private final ReentrantLock strongReferencesLock;</span><br><span class="line">    private final ReferenceQueue&lt;? super V&gt; queue;</span><br><span class="line"></span><br><span class="line">    public SoftHashMap() &#123;</span><br><span class="line">        this(DEFAULT_RETENTION_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(int retentionSize) &#123;</span><br><span class="line">        super();</span><br><span class="line">        RETENTION_SIZE = Math.max(0, retentionSize);</span><br><span class="line">        queue = new ReferenceQueue&lt;V&gt;();</span><br><span class="line">        strongReferencesLock = new ReentrantLock();</span><br><span class="line">        map = new ConcurrentHashMap&lt;K, SoftValue&lt;V, K&gt;&gt;();</span><br><span class="line">        strongReferences = new ConcurrentLinkedQueue&lt;V&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(Map&lt;K, V&gt; source) &#123;</span><br><span class="line">        this(DEFAULT_RETENTION_SIZE);</span><br><span class="line">        putAll(source);</span><br><span class="line">    &#125;</span><br><span class="line">    public SoftHashMap(Map&lt;K, V&gt; source, int retentionSize) &#123;</span><br><span class="line">        this(retentionSize);</span><br><span class="line">        putAll(source);</span><br><span class="line">    &#125;</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; value = map.get(key);</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        V result = value.get();</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            // 已经被GC掉了</span><br><span class="line">            // noinspection SuspiciousMethodCalls</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            addToStrongReferences(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    private void addToStrongReferences(V result) &#123;</span><br><span class="line">        strongReferencesLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            strongReferences.add(result);</span><br><span class="line">            trimStrongReferencesIfNecessary();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            strongReferencesLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void trimStrongReferencesIfNecessary() &#123;</span><br><span class="line">        while (strongReferences.size() &gt; RETENTION_SIZE) &#123;</span><br><span class="line">            strongReferences.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void processQueue() &#123;</span><br><span class="line">        SoftValue sv;</span><br><span class="line">        while ((sv = (SoftValue) queue.poll()) != null) &#123;</span><br><span class="line">            // noinspection SuspiciousMethodCalls</span><br><span class="line">            map.remove(sv.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        // noinspection SuspiciousMethodCalls</span><br><span class="line">        return values().contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        if (m == null || m.isEmpty()) &#123;</span><br><span class="line">            processQueue();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; entry : m.entrySet()) &#123;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        Collection&lt;K&gt; keys = map.keySet();</span><br><span class="line">        if (keys.isEmpty()) &#123;</span><br><span class="line">            // noinspection unchecked</span><br><span class="line">            return Collections.EMPTY_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        Collection&lt;V&gt; values = new ArrayList&lt;V&gt;(keys.size());</span><br><span class="line">        for (K key : keys) &#123;</span><br><span class="line">            V v = get(key);</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                values.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return values;</span><br><span class="line">    &#125;</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; sv = new SoftValue&lt;V, K&gt;(value, key, queue);</span><br><span class="line">        SoftValue&lt;V, K&gt; previous = map.put(key, sv);</span><br><span class="line">        addToStrongReferences(value);</span><br><span class="line">        return previous != null ? previous.get() : null;</span><br><span class="line">    &#125;</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        SoftValue&lt;V, K&gt; raw = map.remove(key);</span><br><span class="line">        return raw != null ? raw.get() : null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        strongReferencesLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            strongReferences.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            strongReferencesLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        processQueue();</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;</span><br><span class="line">    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">        Collection&lt;K&gt; keys = map.keySet();</span><br><span class="line">        if (keys.isEmpty()) &#123;</span><br><span class="line">            //noinspection unchecked</span><br><span class="line">            return Collections.EMPTY_SET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;K, V&gt; kvPairs = new HashMap&lt;K, V&gt;(keys.size());</span><br><span class="line">        for (K key : keys) &#123;</span><br><span class="line">            V v = get(key);</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                kvPairs.put(key, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return kvPairs.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SoftValue&lt;V, K&gt; extends SoftReference&lt;V&gt; &#123;</span><br><span class="line">        private final K key;</span><br><span class="line">        private SoftValue(V value, K key, ReferenceQueue&lt;? super V&gt; queue) &#123;</span><br><span class="line">            super(value, queue);</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-_ReferenceQueue_源码分析">2. <code>ReferenceQueue</code> 源码分析</h3><p><code>ReferenceQueue</code> 的入队方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; /* Called only by Reference class */</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        // Check that since getting the lock this reference hasn&apos;t already been</span><br><span class="line">        // enqueued (and even then removed)</span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        if ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        assert queue == this;</span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        r.next = (head == null) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很明确，利用头插法建立的链表。注意在 <code>Reference</code> 中维护了 <code>queue</code> 和 <code>next</code> 字段，当入队后，<code>queue</code>字段为 <code>ENQUEUED</code>。其出队的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Reference&lt;? extends T&gt; reallyPoll() &#123;</span><br><span class="line">    Reference&lt;? extends T&gt; r = head;</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        head = (r.next == r) ?</span><br><span class="line">            null :</span><br><span class="line">            r.next; // Unchecked due to the next field having a raw type in Reference</span><br><span class="line">        r.queue = NULL;</span><br><span class="line">        r.next = r;</span><br><span class="line">        queueLength--;</span><br><span class="line">        if (r instanceof FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队后 <code>Reference</code> 中的 <code>queue</code> 为 <code>NULL</code> 对象。</p><h3 id="3-_Reference_源码分析">3. <code>Reference</code> 源码分析</h3><center><img src="/pics/reference.png" alt=""></center><ul><li><code>PhantomReference</code>，注意其 <code>get</code> 一直都返回 <code>null</code></li><li><code>WeakReference</code> 与 <code>Reference</code> 一致</li><li><code>SoftReference</code> 会记录 <code>VM</code> 的 <code>GC</code> 的时间</li></ul><p>在 <code>Reference</code> 中，会存在四种状态:</p><ol><li>Active<ul><li><code>queue</code> 字段为传过来的 <code>ReferenceQueue</code> 或者为 <code>ReferenceQueue.NULL</code>；</li><li><code>next</code> 字段为 <code>null</code>;</li></ul></li><li>Pending<ul><li><code>queue</code> 引用的 <code>ReferenceQueue</code></li><li><code>next</code> 字段为 <code>ReferenceQueue</code> 的下一个 <code>Reference</code> 对象，或者自身</li></ul></li><li>Enqueued<ul><li><code>queue</code> 等于 <code>ReferenceQueue.ENQUEUED</code></li><li><code>next</code> 为 <code>ReferenceQueue</code> 的下一个 <code>Reference</code> 对象，或者自身</li></ul></li><li>Inactive<ul><li><code>queue</code> 为 <code>ReferenceQueue.NULL</code></li><li><code>next</code> 为<code>this</code></li></ul></li></ol><p>在 <code>Reference</code> 中存在一个静态块，创建了一个 <code>ReferenceHandler</code> 高优先级的线程。在一篇博客中有详细的解释: <a href="http://hongjiang.info/java-referencequeue/" target="_blank" rel="noopener">http://hongjiang.info/java-referencequeue/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;当 &lt;code&gt;JVM&lt;/code&gt; 的内存不足时，会发生 &lt;code&gt;GC&lt;/code&gt;，而对象的 &lt;code&gt;GC&lt;/code&gt; 依赖该对象是否存在引用。引用的分类如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Stron
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC-MCS队列锁</title>
    <link href="https://coolwcan.cn/Java/Java/JUC-MCS%E9%98%9F%E5%88%97%E9%94%81/"/>
    <id>https://coolwcan.cn/Java/Java/JUC-MCS队列锁/</id>
    <published>2019-04-01T07:12:00.848Z</published>
    <updated>2019-04-01T07:12:00.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>之前分析过 <code>CLH</code>，会发现其自旋检查状态时，会去检查一个非本地变量的状态。在 <code>SMP</code> 架构下没问题，而在 <code>NUMA</code> 结构下，去跨 <code>CPU</code> 模块去访问内存，会导致性能很低。而 <code>MCS</code> 队列锁将能够保证在 <code>NUMA</code> 架构下的性能。</p><h3 id="1-_源码">1. 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MCSLock implements Lock &#123;</span><br><span class="line">    private AtomicReference&lt;QNode&gt; tail = null;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line"></span><br><span class="line">    public MCSLock() &#123;</span><br><span class="line">        tail = new AtomicReference&lt;&gt;(null);</span><br><span class="line">        myNode = ThreadLocal.withInitial(QNode::new);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        QNode pred = tail.getAndSet(qnode);</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            qnode.locked = true;</span><br><span class="line">            pred.next = qnode;</span><br><span class="line">            while (qnode.locked);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        if (qnode.next == null) &#123;</span><br><span class="line">            if (tail.compareAndSet(qnode, null)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            while (qnode.next == null);</span><br><span class="line">        &#125;</span><br><span class="line">        qnode.next.locked = false;</span><br><span class="line">        qnode.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class QNode &#123;</span><br><span class="line">        private volatile boolean locked = false;</span><br><span class="line">        private volatile QNode next = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路与 <code>CLH</code> 出入不大，唯一的区别，在于监听时，一个是监听非本地变量，一个监听本地变量。<strong>特别注意一点，在自旋中，<code>while</code> 中的变量一定得 <code>volatile</code>，否则会测试不过</strong>。注意其中这一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (qnode.next == null) &#123;</span><br><span class="line">    if (tail.compareAndSet(qnode, null))</span><br><span class="line">        return;</span><br><span class="line">    while (qnode.next == null) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>qnode.next == null</code> 则表明 <code>qnode</code> 是尾结点，如果通过 <code>tail.compareAndSet(qnode, null)</code> 设置成功，则表明将 <code>qnode</code> 的确为 <code>tail</code>，但是在多线程的环境下，可能在 <code>qnode.next == null</code> 成立，而在 <code>tail.compareAndSet(qnode, null)</code> 设置之前，又有一个线程 <code>lock</code>，将会导致设置失败。我认为 <code>while (qnode.next == null) {}</code> 的存在有点问题，因为如果在 <code>tail.compareAndSet(qnode, null)</code> 比较之后，在执行 <code>while (qnode.next == null) {}</code> 之前时，另一个加锁的线程同时释放了锁，那么此处将会等待下一个线程来获取锁时，才能被释放，如果该过程后，再没有线程去获取锁，那么此处将一直释放不掉锁，但是此过程，能够保证接下来的执行能够很顺利，而且仅仅是影响释放，不影响其正常的功能。</p><h3 id="2-_优缺点">2. 优缺点</h3><ul><li>优点<br>能够适应 <code>NUMA</code> 的 <code>CPU</code> 架构</li><li>缺点<ol><li>释放锁也需要通过自旋</li><li>可能存在释放不掉锁的时候，会影响性能</li></ol></li></ul><h3 id="3-_MCS_与_CLH_的区别">3. <code>MCS</code> 与 <code>CLH</code> 的区别</h3><ul><li>从代码实现来看，CLH比MCS要简单得多。</li><li>从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。</li><li>从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。</li><li>CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</li></ul><p>在 <code>http://coderbee.net/index.php/concurrent/20131115/577</code> 这篇博客中，还写了关于 <code>自旋锁</code>、<code>Ticket Lock</code> 的例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;之前分析过 &lt;code&gt;CLH&lt;/code&gt;，会发现其自旋检查状态时，会去检查一个非本地变量的状态。在 &lt;code&gt;SMP&lt;/code&gt; 架构下没问题，而在 &lt;code&gt;NUMA&lt;/code&gt; 结构下，去跨 &lt;code&gt;CP
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC-CLH队列锁</title>
    <link href="https://coolwcan.cn/Java/Java/JUC-CLH%E9%98%9F%E5%88%97%E9%94%81/"/>
    <id>https://coolwcan.cn/Java/Java/JUC-CLH队列锁/</id>
    <published>2019-04-01T07:11:42.371Z</published>
    <updated>2019-04-01T07:11:42.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>Craig, Landin, and Hagersten (CLH) 锁，基于链表的自旋锁。通过队列 <code>FIFO</code> 的特性，保证了锁的公平性、无饥饿性。</p><h3 id="1-_源码">1. 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CLHLock implements Lock &#123;</span><br><span class="line">    private final AtomicReference&lt;QNode&gt; tail;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myPred;</span><br><span class="line">    private final ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line">    public CLHLock() &#123;</span><br><span class="line">        tail = new AtomicReference&lt;QNode&gt;(new QNode());</span><br><span class="line">        myNode = new ThreadLocal&lt;QNode&gt;() &#123;</span><br><span class="line">            protected QNode initialValue() &#123;</span><br><span class="line">                return new QNode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        myPred = new ThreadLocal&lt;QNode&gt;() &#123;</span><br><span class="line">            protected QNode initialValue() &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        qnode.locked = true;</span><br><span class="line">        QNode pred = tail.getAndSet(qnode);</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        while (pred.locked) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        QNode qnode = myNode.get();</span><br><span class="line">        qnode.locked = false;</span><br><span class="line">        myNode.set(myPred.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class QNode &#123;</span><br><span class="line">        volatile boolean locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有三个属性字段:</p><ol><li><code>tail</code><br>一个 <code>AtomicReference</code>，用于在多线程环境下，保证其 <code>set</code> 和 <code>get</code> 的原子性</li><li><code>myPred</code><br><code>ThreadLocal</code> 变量</li><li><code>myNode</code><br><code>ThreadLocal</code> 变量</li></ol><p>因为 <code>myPred</code> 和 <code>myNode</code> 是 <code>ThreadLocal</code> 对象，则说明是线程独享的，那么线程间共享的变量就只有 <code>tail</code> 对象了；其实 <code>lock</code> 与 <code>unlock</code> 排除其它因素去看，单独去看这一块的代码，还是很简单的。<code>lock</code>方法，是将 <code>myNode</code> 的状态置为 <code>true</code>，表明已经被锁了，然后把 <code>myNode</code> 设置成最新的尾部，然后通过自旋的方式去检查去最新的一个尾部的状态; <code>unlock</code> 方法，则是修改 <code>myNode</code> 存储节点的状态为 <code>false</code>，表示已经释放该锁。我觉得上面这段代码中，最重要的一个代码是: <code>tail.getAndSet(qnode)</code>，因为通过上面的分析，我们也了解到 <code>tail</code> 是唯一一个多个线程间共享的变量。<code>getAndSet</code> 是一个原子操作，我们知道其内部是通过 <code>CAS</code> 进行设置的，在此过程，可能会存在其它的线程已经修改了这个变量。但是其实这并不是影响锁的功能，如果在 <code>set</code> 的过程中已经有其它的线程去修改了，那么成功 <code>set</code> 的线程必然会去等待它的前一个节点，所以我们根本不需要去管其它，每一个线程只需要关注其其返回值就好。</p><h3 id="2-_优缺点">2. 优缺点</h3><ol><li>优点<ol><li>空间复杂度低</li><li>公平</li><li>无饥饿</li><li>高性能</li></ol></li><li>缺点<ol><li>在自旋的过程，会去检查另一个 <code>Node</code> 的状态，另一个节点并不是一个本地变量，如果在 <code>NUMA</code> 的 <code>CPU</code> 架构下，读取内存数据的性能不佳，会影响该锁的性能</li></ol></li></ol><h3 id="3-_MPP_和_NUMA_的_CPU_架构">3. <code>MPP</code> 和 <code>NUMA</code> 的 <code>CPU</code> 架构</h3><ul><li>SMP(Symmetric Multi-Processor)，即对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。SMP的优点是能够保证内存一致性，缺点是这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，可能会导致CPU资源的浪费。常用的PC机就属于这种。</li><li>NUMA(Non-Uniform Memory Access)非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问NUMA的由来。NUMA优点是可以较好地解决原来SMP系统的扩展问题，缺点是由于访问远地内存的延时远远超过本地内存，因此当CPU数量增加时，系统性能无法线性增加</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;Craig, Landin, and Hagersten (CLH) 锁，基于链表的自旋锁。通过队列 &lt;code&gt;FIFO&lt;/code&gt; 的特性，保证了锁的公平性、无饥饿性。&lt;/p&gt;
&lt;h3 id=&quot;1-_源码&quot;&gt;1. 源码
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JUC-CyclicBarrier</title>
    <link href="https://coolwcan.cn/Java/Java/JUC-CyclicBarrier/"/>
    <id>https://coolwcan.cn/Java/Java/JUC-CyclicBarrier/</id>
    <published>2019-04-01T07:11:28.446Z</published>
    <updated>2019-04-01T07:11:28.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_简介">0. 简介</h3><p>同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点，并且能够循环使用。主要适用于: 需要等待所有的子任务都完成后，才执行主任务。</p><h3 id="1-_源码分析">1. 源码分析</h3><ol><li><p>属性</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private final Condition trip = lock.newCondition();</span><br><span class="line">private final int parties;</span><br><span class="line">private int count;</span><br><span class="line">private final Runnable barrierCommand;</span><br><span class="line">private Generation generation = new Generation();</span><br></pre></td></tr></table></figure><p> <code>parties</code> 和 <code>count</code> 分别表示一共有多少线程参与和还有多少线程正处于等待状态，注意此处的 <code>parties</code> 为 <code>final</code> 则表明虽然是 <code>Cyclic</code> 但是其参与者的个数是不能修改的<br> <code>barrierCommand</code> 当所有的线程都执行完成后执行的任务<br> <code>generation</code> 这是 <code>CyclicBarrier</code> 提出的一个概念，因为 <code>CyclicBarrier</code> 可以循环使用，在内部每一个过程被称为一代，而且将重置的过程，称为 <code>Break</code>，并且会有一个变量，表明是否被重置，这个变量在 <code>Generation</code> 里( <code>CyclicBarrier</code>的内部类 ):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">// 是否已经被触发或者已经被手动重置</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dowait 方法<br>代码太多，并且也不是很难，就不帖代码了，大家需要注意的是，多个线程看到的是同一个 <code>Barrier</code>，在 <code>CyclicBarrier</code> 中提出一个这样的概念： <code>all-or-none breakage model</code>，即要么全部成功，要么全部失败，即当一个线程失败后，其它的线程也将抛出异常，因为它们看到的是同一个状态变量</p></li><li><p>reset 方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void reset() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        nextGeneration();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void breakBarrier() &#123;</span><br><span class="line">    generation.broken = true;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 主要是注意 <code>reset</code> 方法中的调用顺序，先是调用 <code>breakBarrier</code>, 再调用 <code>nextGeneration</code>，因为在 <code>dowait</code> 方法中，很多的是 <code>Generation g = generation</code>, 是引用过去的，先调用 <code>breakBarrier</code> 会激活上一代的进程</p></li></ol><h3 id="2-_demo">2. demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    private static class WorkThread extends Thread &#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private CyclicBarrier barrier;</span><br><span class="line">        public WorkThread(int id, CyclicBarrier barrier) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">            this.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;id = &quot; + id + &quot; start&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;id = &quot; + id + &quot; continue&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;</span><br><span class="line">        int nParties = 5;</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(nParties, () -&gt; System.out.println(&quot;All Finished!!!!&quot;));</span><br><span class="line">        for (int i = 0; i &lt; nParties; i++) &#123;</span><br><span class="line">            new WorkThread(i + 1, barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_简介&quot;&gt;0. 简介&lt;/h3&gt;&lt;p&gt;同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点，并且能够循环使用。主要适用于: 需要等待所有的子任务都完成后，才执行主任务。&lt;/p&gt;
&lt;h3 id=&quot;1-_源码分析&quot;&gt;1. 源码分析&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机小知识点</title>
    <link href="https://coolwcan.cn/Computer/Computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://coolwcan.cn/Computer/Computer/计算机小知识点/</id>
    <published>2019-04-01T07:06:34.484Z</published>
    <updated>2019-04-01T07:19:36.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可执行文件格式">可执行文件格式</h3><p>无论是Windows下的 <code>PE(Portable Executable)</code> 文件，还是Linux下的 <code>ELF(Executable Linkable Format)</code> 文件，都是<code>COFF(Common file format)</code> 文件格式的变种。可执行文件例如，Windows 下的 <code>*.exe</code>, Linux下的 <code>/bin/bash</code>。</p><h3 id="程序运行时的内存空间">程序运行时的内存空间</h3><p>主要分为BSS段、数据段、代码段、堆、栈</p><ul><li>BSS段<br><code>Block Started by Symbol</code>，用来存放程序中未初始化的全局变量的一块内存区域。通常这块区域，因为其数据未被初始化，即都为0，所以在文件中不占空间。</li><li>数据段<br><code>data segment</code>，用来存放程序中已初始化的全局变量的一块内存区域，数据段属于静态内存分配。</li><li>代码段<br><code>code segement/text segement</code>，用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读。</li><li>堆<br><code>heap</code>，用于存放进程运行中被动态分配的内存段，在32位的电脑上可以达到4G内存，可动态由低地址向高地址进行扩张。</li><li>栈<br><code>stack</code>，又称为堆栈，是用户存放程序临时创建的局部变量，一般也可以在函数调用时，通过栈来传递参数，并且将结果也以栈的形式进行传递。由高地址向低地址进行扩张。</li></ul><h3 id="PE_中的节"><code>PE</code> 中的节</h3><ul><li><code>.text</code> 节<br><code>.text</code> 节基本上相当于二进制可执行文件的.text部分，它包含了完成程序任务的机器指令; 该节标记为只读，如果发生写操作，会造成 <code>segmentation fault</code>。在进程最初被加载到内存中开始，该节的大小就被固定。</li><li><code>.data</code> 节<br>用于存储初始化过的变量，如： <code>int a =0;</code> 该节的大小在运行时固定的。</li><li><code>.bss</code> 节<br>  栈下节（below stack section ,即.bss）用来存储为初始化的变量，如：int a; 该节的大小在运行时固定的。</li><li>堆节<br><code>heap section</code>，用来存储动态分配的变量，位置从内存的低地址向高地址增长。内存的分配和释放通过malloc() 和 free() 函数控制。</li><li>栈节<br><code>stack section</code>， 用来跟踪函数调用（可能是递归的），在大多数系统上从内存的高地址向低地址增长。同时，栈这种增长方式，导致了缓冲区溢出的可能性。</li><li>环境/参数节<br><code>environment/arguments section</code>，用来存储系统环境变量的一份复制文件，该节是可写的，因此在格式串（<code>format string</code>）和缓冲区溢出（<code>buffer overflow</code>）攻击中都可以使用该节。另外，命令行参数也保持在该区域中。</li></ul><h3 id="CPU工作模式">CPU工作模式</h3><p>CPU有三种模式:</p><ol><li>实模模式<ol><li>直接使用物理地址，32位地址线只使用了低20位，所以最大寻址为1M</li><li>支持多任务，不支持任务的切换</li><li>有中间向量表</li></ol></li><li>保护模式<ol><li>虚拟内存，32位地址线都能使用，最大寻址为4GB</li><li>多任务，支持优先级</li></ol></li><li>虚拟86模式<br> 虚拟86模式 ＝ 实模式 + 保护模式</li></ol><p>处理器从8086升级到80386，工作模式也从实模式升级到保护模式，虚拟86模式是为了兼容8086。其整个演变过程如下：<br>实模式 –&gt; 保护模式 –&gt; 虚拟86模式，不能直接从模式转换到虚拟86模式</p><h3 id="大端与小端">大端与小端</h3><ol><li>大端模式: 是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中;</li><li>小端模式: 是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中;</li></ol><p>因为在计算机内部是按8位，即一个字节来处理的，所以如果一个长度为32位，那么就需要来判断是否是大端或者小端了。网络传输一般采用大端序，也被称之为网络字节序，或网络序。例如数据: <code>0x12345678</code>， 其大端(左)和小端(右)表示如下:<br><img src="/pics/computer-大端.jpg" alt="">  <img src="/pics/computer-小端.jpg" alt=""></p><h3 id="产生死锁的四个必要条件：">产生死锁的四个必要条件：</h3><ul><li>互斥条件， 一个资源每次只能被一个进程使用。</li><li>请求与保持条件，一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件，进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件，若干进程之间形成一种头尾相相接的循环等待资源条件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可执行文件格式&quot;&gt;可执行文件格式&lt;/h3&gt;&lt;p&gt;无论是Windows下的 &lt;code&gt;PE(Portable Executable)&lt;/code&gt; 文件，还是Linux下的 &lt;code&gt;ELF(Executable Linkable Format)&lt;/code&gt; 
      
    
    </summary>
    
      <category term="Computer" scheme="https://coolwcan.cn/categories/Computer/"/>
    
    
      <category term="Computer" scheme="https://coolwcan.cn/tags/Computer/"/>
    
  </entry>
  
  <entry>
    <title>Java小知识点</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://coolwcan.cn/Java/Java/Java小知识点/</id>
    <published>2019-04-01T06:45:38.151Z</published>
    <updated>2019-04-01T06:46:42.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_术语">1. 术语</h3><ul><li>JPA<br><code>Java Persistence API</code>， Java持久化API</li><li>JSR<br><code>Java Specification Requests</code>， Java 规范提案</li><li>JCP<br><code>Java Community Process</code></li><li>EJB<br>一个框架，将执行任务的类，放在服务器上</li><li>RMI<br><code>Remote Method Invocation</code>，远程方法调用</li><li>JNDI<br><code>Java Naming and Directory Interface</code>, Java命名和目录接口</li></ul><h3 id="2-_优化建议">2. 优化建议</h3><ul><li>在对大字符串进行 <code>spilt</code> 操作时，使用 <code>StringTokenizer</code> 的性能会更好</li><li>短路表达式，能提高效率</li><li>多使用 <code>native</code> 函数，如 <code>System.arraycopy</code></li></ul><h3 id="3-_String-format(format,_args)方法">3. String.format(format, args)方法</h3><p><code>%d</code> 包括了 <code>int, long, byte</code></p><h3 id="4-_String">4. String</h3><p>String 是不可变的，赋值会重新生成一个String对象。</p><p>1.直接定义字符串变量的时候赋值，如果表达式右边只有字符串常量，那么就是把变量存放在常量池里面。<br>2.new出来的字符串是存放在堆里<br>3.对字符串进行拼接操作，也就是做”+”运算的时候，分2中情况：</p><pre><code><span class="number">1.</span> 右边是纯字符串常量，那么存放在栈里面。<span class="number">2.</span> 表达式右边如果存在字符串引用，也就是字符串对象的句柄，那么就存放在堆里面。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa&quot;;</span><br><span class="line">String str2 = &quot;bbb&quot;;</span><br><span class="line">String str3 = &quot;aaabbb&quot;;</span><br><span class="line">String str4 = str1 + str2;</span><br><span class="line">String str5 = &quot;aaa&quot; + &quot;bbb&quot;;</span><br><span class="line">System.out.println(str3 == str4);          // false， 一个在常量池，另一个在栈上</span><br><span class="line">System.out.println(str3 == str4.intern()); // true，intern方法会将值放入常量池。两个字符串相加，会被转换成StringBuilder的append操作</span><br><span class="line">System.out.println(str3 == str5);          // true，字符串相加的时候，都是静态字符串的结果会添加到字符串池</span><br></pre></td></tr></table></figure><h3 id="5-_在引用传递中，只有对引用对象内部的修改才会影响原对象，如果直接将引用修改了，则对原对象没有影响。">5. 在引用传递中，只有对引用对象内部的修改才会影响原对象，如果直接将引用修改了，则对原对象没有影响。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void doSomething(Integer var) &#123;</span><br><span class="line">        var = new Integer(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer var1 = new Integer(1);</span><br><span class="line">        Integer var2 = var1;</span><br><span class="line">        doSomething(var2);</span><br><span class="line">        System.out.println(var1 == var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出 <code>true</code></p><h3 id="6-_带符号右移与无符号右移的区别">6. 带符号右移与无符号右移的区别</h3><ol><li><code>&gt;&gt;</code> , 有符号右移，正数，高位补0，负数，高位补1</li><li><code>&gt;&gt;&gt;</code> , 无符号右移，高位始终补0</li></ol><h3 id="7-_重载条件">7. 重载条件</h3><ol><li>参数的类型不同</li><li>参数的顺序不同</li><li>参数的个数不同</li></ol><h3 id="8-_Thread类中的run方法与start方法的区别">8. Thread类中的run方法与start方法的区别</h3><ol><li>start, 才会真正重新重新开启一个线程</li><li>run, 仅仅是执行runnble中的一个方法，并不会重新打开一个线程</li></ol><h3 id="9-_Java命名规范">9. Java命名规范</h3><ol><li>包的命名<br>全部小写, 由域名定义</li><li>类的命名<br>单词首字母大写</li><li>方法命名<br>首字母小写, 字母开头大写</li><li>常量命名<br>全部大写, 加下划线</li></ol><h3 id="10-_Java集合类中线程安全与不是线程安全的对象">10. Java集合类中线程安全与不是线程安全的对象</h3><p>前面是非线程安全，后面的是线程安全</p><ol><li>StringBuilder 和 StringBuffer</li><li>HashMap 和 HashTable</li><li>ArrayList 和 Vector</li></ol><h3 id="11-_Java中的参数类型">11. Java中的参数类型</h3><ol><li>继承关系</li></ol>&lt;center<img src="./pic/java-parameter-type.jpg" alt=""><ol start="2"><li><p>类型说明</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Type              : java语言中所有类型的公共父接口</span><br><span class="line">2. GenericArrayType  : 表示一种元素类型是参数化类型或者类型变量的数组类型，如: void method(ArrayList[] al)&#123;…&#125;</span><br><span class="line">3. ParameterizedType : 表示一种参数化的类型，比如Collection</span><br><span class="line">4. TypeVariable      : 是各种类型变量的公共父接口</span><br><span class="line">5. WildcardType      : 代表一种通配符类型表达式</span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><code>Type[] getActualTypeArguments()</code><br>这个函数仅仅是去掉最外层的&lt;&gt;后剩下的内容，就是返回值</li><li><code>Type getGenericComponentType()</code><br>这个方法仅仅脱去最右边的[]之后剩下的内容就作为这个方法的返回值</li></ul></li></ol><h3 id="12-_抽象类与接口的区别">12. 抽象类与接口的区别</h3><ol><li>语法上的区别<ol><li>抽象类里可以有构造方法，而接口内不能有构造方法。</li><li>抽象类中可以有普通成员变量，而接口中不能有普通成员变量。</li><li>抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法</li><li>抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法只能是<br>public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口内不能包含静态方法。</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定<br>义的变量只能是public  static类型，并且默认为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol></li><li>使用上的区别<ol><li>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约</li><li>抽象类在代码实现方面发挥作用</li></ol></li></ol><h3 id="13-_Java中的hashCode与equals">13. Java中的hashCode与equals</h3><p>在 <code>Object</code> 默认存在两个函数，<code>hashCode</code> 和 <code>equals</code>，这两个方法主要用于集合中比较两个对象是否相等，默认是比较对象的内存地址。<code>hashCode</code> 函数会根据当前对象的属性生成特定的哈希值。</p><ol><li>集合中如何比较两个对象？<ol><li>先比较HashCode值</li><li>如果HashCode相等，再调用equals方法，来判断</li></ol></li><li>为什么用HashCode，不直接用equals来比较？<br> 因为在集合中会存在一个table，来记录所有对象的HashCode，直接用HashCode来进行比较效率比较高，而使用equals比较，比较的操作比较多，较耗时</li></ol><h3 id="14-_ConcurrentHashMap与HashTable的区别">14. ConcurrentHashMap与HashTable的区别</h3><ul><li>并发控制的粒度不同。ConcurrentHashMap，对读操作，完全并发，对写操作，并发控制的粒度很细，支持行级锁。而HashTable，则是全表锁。</li><li>迭代器的一致性不同。ConcurrentHashMap是弱一致，而HashTable是强一致。ConcurrentHashMap的迭代弱一致，即在迭代过程，修改数据时，不同于HashTable的抛出异常的行为，它不会直接修改老数据，而是新创建一个数据，当遍历完成后，才将指针指向新的数据。这样即能够保证数据的正常遍历，又能够提高并发效率。但是HashTable具有强一致性，这种行为常被称为<code>fail-fast</code>(快速失败)迭代器，即当在遍历过程中，数据被修改，会产生异常。</li></ul><h3 id="15-_负载因子">15. 负载因子</h3><p>在HashMap中存在着一个称为“负载因子”的浮点数，“负载因子”表示的是，当达到当前容量的某一个比例时，就会扩容，该扩容的过程，被称为 <code>rehashing</code>。扩容后的容量，是当前容量的2倍。</p><h3 id="16-_内部类">16. 内部类</h3><p>内部类可以随意使用外部类的成员变量（包括私有）而不用生成外部类的对象，这是内部类的惟一优点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 静态内部类 : 只能访问外部的静态类变量</span><br><span class="line">2. 私有内部类 :只能由外部类控制，不能在外部创建</span><br><span class="line">3. 公共内部类 : 都可以访问</span><br><span class="line">4. 方法内部类 : 只能在方法内访问，方法内部类的方法形参必须使用 `final` 定义</span><br></pre></td></tr></table></figure><h3 id="17-_super_与_extends_的区别">17. super 与 extends 的区别</h3><p><code>super</code> 向下造型，指明下界，表明所有父类及本身，那么此时可以向集合中添加所有子类对象，从我的角度去看，此时如果 <code>List&lt;? super A &gt;</code>就相当于 <code>List&lt;Object&gt;</code>，此时可以向里面添加任意的对象，但是取出来的对象也是 <code>Object</code> 需要强制转换；<code>extends</code>，向上选型，指明上界，表明所有子类及本身，则此时可以从集合中获取对象。在 <code>Java</code> 中，<code>List&lt;Number&gt;</code> 可以存储 <code>Integer</code> 或者 <code>Double</code> 对象，但是 <code>List&lt;Integer&gt;</code> 却不能存储 <code>Double</code> 对象，而 <code>List&lt;? extends Number&gt;</code> 表明所有继承自 <code>Number</code> 的子类及 <code>Number</code> 类，此时向 <code>List&lt;? extends Number&gt;</code> 添加数据，就会引起类型安全的问题，因为不能确定具体是那个类型啊。在Java中有一个 <code>PECS</code> 原则，即如果是生产者(即只能从集合里取数据，而不能向集合添加数据)，则使用 <code>extends</code>，如果是消费者(即只能向集合添加数据，而不能从里面取数据)，则使用 <code>super</code>; 其根本原因是因为Java在泛型方面不支持协变与逆变。</p><h3 id="18-_线程池">18. 线程池</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</td></tr><tr><td>newFixedThreadPool</td><td>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</td></tr><tr><td>newScheduledThreadPool</td><td>创建一个定长线程池，支持定时及周期性任务执行。</td></tr><tr><td>newSingleThreadExecutor</td><td>创建一个单线程的线程池，保证所有任务按照指定顺序执行。</td></tr></tbody></table><h3 id="19-_对象锁与类锁">19. 对象锁与类锁</h3><p>都是针对 <code>synchronized</code> 关键字而言的，对象锁，指以一个类的实例，作为互斥的对象；而类锁，是以类所对应的类对象作为互斥的对象，例<code>XXX.class</code></p><h3 id="20-_java_与_javax_的区别">20. java 与 javax 的区别</h3><p><code>java</code> 和 <code>javax</code> 都是 <code>Java</code> 的 <code>API(Application Programming Interface)</code> 包, <code>java</code> 是核心包，<code>javax</code> 的 <code>x</code> 是 <code>extension</code> 的意思,也就是扩展包</p><h3 id="21-_Finalize方法">21. Finalize方法</h3><ol><li>finalize 方法，是针对 <code>GC</code> 的一个补充。</li><li>finalize 方法只会执行一次</li><li>finalize 函数的执行过程如下:<ul><li>当对象不可达时，没有重写了finalize方法，直接将其回收。</li><li>当对象不可达时，重写了finalize方法，则将其放入到 <code>F-Queue</code> 队列(由低优先级线程执行该队列中的finalize方法)</li><li>当执行finalize方法完后，再次判断对象是否可达，不可达，则进行回收，否则对象“复活”</li></ul></li><li><code>gc</code> 过程的状态组<ul><li>终结状态<br><code>F = {unreachable, finalizable, finalized}</code></li><li>可达状态空间<br><code>R = {reachable, finalizer-reachable, unfinalized}</code><br>各状态含义:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- unfinalized</span><br><span class="line">  新建对象会先进入此状态</span><br><span class="line">- finalizable</span><br><span class="line">  当对象不可达，重写finalize方法时，并且已经放入到F-Queue中，等待finaize方法被执行</span><br><span class="line">- finalized</span><br><span class="line">  表示在F-Queue队列中对该对象执行过finalize方法</span><br><span class="line">- reachable</span><br><span class="line">  表示GC Roots引用可达</span><br><span class="line">- finalizer-reachable(f-reachable)</span><br><span class="line">  表示不是reachable，但可通过某个finalizable对象可达。即在finalize函数中，引用到某一个对象，此时该对象就为这个状态</span><br><span class="line">- unreachable</span><br><span class="line">  对象不可达，等待被GC</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="22-_引起OOM的几种情况">22. 引起OOM的几种情况</h3><ul><li>堆溢出<br><code>Java.lang.OutOfMemoryError: Java heap space</code>，这种是由于 <code>java</code> 堆内存不够，一个原因是真不够，另一个原因是程序中有死循环； 可以通过调整JVM的最大堆（-Xmx）；</li><li>栈溢出<br><code>java.lang.StackOverflowError</code>，需要查看是否存在深度递归，或者通过调整JVM的 <code>-Xss</code> 调整堆栈</li><li>永久区溢出<br><code>java.lang.OutOfMemoryError: PermGen space</code>，可能是由于动态代理产生了大量的 <code>class</code>，或者超过了设置的最大的永久空间</li><li>GC溢出<br><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>，是由于JVM在GC时，对象过多，导致内存溢出，建议调整GC的策略。</li><li>创建线程的溢出<br><code>java.lang.OutOfMemoryError: unable to create new native thread</code>，超过了最大的创建线程的个数。</li><li>创建大数组的溢出<br><code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code>，分配的堆超过了堆的最大限制</li><li>swap 时的溢出<br><code>java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?</code>，是由于从native堆中分配内存失败，并且堆内存可能接近耗尽。可能是交换区的设置太小，或者存在另一个线程正在消耗内存。</li><li>读数据时的溢出<br><code>java.lang.OutOfMemoryErr java.io.FileInputStream.readBytes(Native Method)</code></li></ul><h3 id="23-_isInstance，instanceof和isAssignableFrom的区别">23. isInstance，instanceof和isAssignableFrom的区别</h3><ul><li>instanceof<br>运算符，<code>a instanceof A</code>, <code>a</code> 是一个实例对象，而<code>A</code>是一个类，用于检查对象 <code>a</code> 是否是类 <code>A</code> 实例化。如果对象为null，则返回false。 eg: <code>obj instanceof String</code></li><li>isInstantce<br>是Class类的方法，<code>A.isInstance(B)</code>, 判断类 <code>B</code> 是否是 <code>A</code> 的父类；eg: <code>Object.class.isInstance(String.class)</code></li><li>isAssignableFrom<br>是Class类的方法，<code>A.isAssignableFrom(B)</code>, 用于判断 <code>B</code> 是否是 <code>A</code> 的子类； eg: <code>Object.class.isAssignableFrom(ArrayList.class)</code></li></ul><h3 id="24-_解决Hash冲突的方法">24. 解决Hash冲突的方法</h3><ol><li>开放地址法<ol><li>线性探测法<br>当发生冲突后，从该槽位置向后循环遍历hash表，直到找到表的下一个空槽</li><li>伪随机探测<br>将线性探测的步长从常数改为随机数，即令 <code>hash = (hash + RN) % m</code>, <code>RN</code> 是一个随机数</li></ol></li><li>拉链法<br>在冲突点上，建立链表</li><li>再散列<br>当发生冲突时，使用第二个，第三个哈希函数计算地址，直至无冲突。</li></ol><h3 id="25-_Runnable和Callable有什么不同">25. Runnable和Callable有什么不同</h3><p>Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常</p><h3 id="26-_什么是线程安全">26. 什么是线程安全</h3><p>多线程环境下，在访问共享资源时，能够保证其业务逻辑的正确性</p><h3 id="27-_Java中如何停止线程">27. Java中如何停止线程</h3><p>JDK1.0中的stop(), resume(), suspend() 因为存在死锁威胁而被弃用了，一般是通过标记变量来控制线程的退出</p><h3 id="28-_线程异常时会怎样？">28. 线程异常时会怎样？</h3><p>分成两类：可捕捉异常和非捕捉异常， 在Thread中如果存在可捕捉异常必须捕捉否则编译不过。而非捕捉异常，是通过 <code>Thread.UncaughtExceptionHandler</code> 进行处理的</p><h3 id="25-_Map">25. Map</h3><table><thead><tr><th>类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为null</td><td>不允许为null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为null</td><td>不允许为null</td><td>AbstractMap</td><td>锁分段技术</td></tr><tr><td>TreeMap</td><td>不允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>TreeMap</td><td>允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_术语&quot;&gt;1. 术语&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JPA&lt;br&gt;&lt;code&gt;Java Persistence API&lt;/code&gt;， Java持久化API&lt;/li&gt;
&lt;li&gt;JSR&lt;br&gt;&lt;code&gt;Java Specification Requests&lt;/co
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>J2ee小知识点</title>
    <link href="https://coolwcan.cn/J2ee/J2ee/J2ee%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://coolwcan.cn/J2ee/J2ee/J2ee小知识点/</id>
    <published>2019-04-01T06:42:10.516Z</published>
    <updated>2019-04-01T06:48:02.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器和拦截器的区别">过滤器和拦截器的区别</h3><ul><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li></ul><h3 id="war包是否exploded的区别">war包是否exploded的区别</h3><ul><li>war<br>IDE，直接将项目打包成war包，再布置到容器中</li><li>war exploded<br>不生成war，直接生成war的解压目录，再布置到容器中</li></ul><h3 id="web-xml中的classpath的区别">web.xml中的classpath的区别</h3><ul><li>classpath  : 就是代表 <code>/WEB-INF /classes/</code> 这个路径</li><li>classpath* : 不仅仅包含 <code>/WEB-INF/classes</code> 这个路径，而且还包含所有jar下的路径</li></ul><h3 id="URL和URI区别">URL和URI区别</h3><ul><li><code>URI</code>，<code>Uniform Resource Identifier</code>，统一资源标识符</li><li><code>URL</code>，<code>Uniform Resource Locator</code>，统一资源定位器</li><li><code>URN</code>，<code>Uniform Resource Name</code>, 统一资源命名</li></ul><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/getMoney</span><br><span class="line">URI: /getMoney</span><br><span class="line">URL: http://localhost:8080/getMoney</span><br></pre></td></tr></table></figure><h3 id="Eclipse_与_IDEA_中Tomcat如何工作？">Eclipse 与 IDEA 中Tomcat如何工作？</h3><p>在了解之前，我需要明白Tomcat的核心组件:</p><ol><li>Web容器， 处理静态页面</li><li>catalina，一个Servlet容器，处理Servlet</li><li>jsp容器，把jsp翻译成一般的Servlet</li></ol><p>而一般我们在Eclipse与IDEA中启动项目，其一般将tomcat拷贝多份，通过配置 <code>catalina.base</code> 从而指定不同的Tomcat的启动环境，而Tomcat是通过 <code>wtp.deploy</code> 指定部署目录，而IDEA是通过JMX去管理部署</p><h3 id="Tomcat如何做到Class隔离与共享">Tomcat如何做到Class隔离与共享</h3><p>要隔离，肯定得利用 ClassLoader。Tomcat并不是使用双亲委托模型，而是采取子优先的原则。每一个app之间是一种并行的关系，每一个app负责去加载内部类，从而达到app之间的隔离。而一些常用的jar包，比如 <code>javax.servlet.Servlet</code>，则不会由每一个app自己去加载，而是容器在启动时已经加载完成，如果与容器的版本号不一致，会导致提示 <code>jar not loaded</code>。</p><h3 id="黏性Session和非黏性Session">黏性Session和非黏性Session</h3><ul><li>黏性Session<br>此模式下同一会话中的请求都被派送到同一个tomcat实例上，这样我们就无须在多台服务器之间实现session共享了，这是其好处，不好的地方就是不能实现failureover了，一但用户访问的机器挂掉，那么其session就会丢失。</li><li>非黏性Session<br>又名复制Session，此模式下同一会话中的请求可以被分配到不同的tomcat实例上进行处理，此时就需要在不同服务器之间同步、复制session，这样一来即使一台服务器挂掉了，请求在其它服务器上照样可以访问到session信息，其缺点在于Session复制需要系统资源和网络开销</li></ul><h3 id="Servlet_中的_Filter_与_Spring_中的_Interceptor_区别"><code>Servlet</code> 中的 <code>Filter</code> 与 <code>Spring</code> 中的 <code>Interceptor</code> 区别</h3><ol><li><code>Interceptor</code> 是基于 <code>java</code> 的反射机制的，而 <code>Filter</code> 是基于函数回调</li><li><code>Filter</code> 依赖于 <code>Servlet</code> 容器，而 <code>Interceptor</code> 不依赖于 <code>Servlet</code> 容器</li><li><code>Interceptor</code> 可以访问应用的上下文，而 <code>Filter</code> 不能</li><li>在一次请求中，<code>Interceptor</code> 可以多次被调用，而 <code>Filter</code> 只能在容器初始化时被调用一次</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤器和拦截器的区别&quot;&gt;过滤器和拦截器的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;拦截器是基于java的反射机制的，而过滤器是基于函数回调。&lt;/li&gt;
&lt;li&gt;拦截器不依赖与servlet容器，过滤器依赖与servlet容器。&lt;/li&gt;
&lt;li&gt;拦截器只能对action请求
      
    
    </summary>
    
      <category term="J2ee" scheme="https://coolwcan.cn/categories/J2ee/"/>
    
    
      <category term="J2ee" scheme="https://coolwcan.cn/tags/J2ee/"/>
    
  </entry>
  
  <entry>
    <title>网络小知识</title>
    <link href="https://coolwcan.cn/Network/Network/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://coolwcan.cn/Network/Network/网络小知识/</id>
    <published>2019-04-01T06:29:17.340Z</published>
    <updated>2019-04-01T06:36:52.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GET与POST的区别">GET与POST的区别</h3><ul><li>GET请求能够被缓存</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>以GET请求的URL能够保存为浏览器书签</li><li>GET请求有长度限制</li><li>GET参数通过URL传递，而POST放在Request Body中，所以GET更不安全</li><li>GET只接受ASCII字符，而POST无限制</li><li>GET请求只能进行url编码，而POST支持多种编码方式</li><li>GET产生一个TCP数据包，而POST产生两个数据包；GET请求直接将header与data一并发送出去，服务器响应200,而POST，浏览器先发送header，服务器响应100后，再发送data，服务器再响应200</li></ul><h3 id="Etag">Etag</h3><ol><li><p>机制<br><br>一种缓存机制，利用 Header 中的 If-Match 或者说 If-None-Match 这个条件判断请求的资源是否被修改。其基本流程如下: 当用户第一次请求资源时，在 Header 中将包含一个 Etag 域，当用户下次再次发起请求时，会在 Header 的 If-None-Match字段上，填上上次的 Etag 值，当服务器判断 If-None-Match 为false，即匹配，将返回304，而不是200，让用户使用上次缓存的页面，从而达到减少网络通信量的目的，否则下载最近的页面。</p></li><li><p>解决了什么样的问题<br><br>主要解决 Last-Modifies 无法解决的一些问题，比如修改频率在秒以下，那么 Last-Modifies-Since 将不能监测，而 Etag 可以根据 Inode, MTime和Size灵活组装，可以避免这个问题</p></li><li><p>Etag的问题<br><br>当使用集群时，因为不同的机器其 Inode 肯定不一样，所以 Etag 每次将不一样，这样就达不到缓存的目的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GET与POST的区别&quot;&gt;GET与POST的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;GET请求能够被缓存&lt;/li&gt;
&lt;li&gt;GET在浏览器回退时是无害的，而POST会再次提交请求&lt;/li&gt;
&lt;li&gt;以GET请求的URL能够保存为浏览器书签&lt;/li&gt;
&lt;li&gt;GET请求有长
      
    
    </summary>
    
      <category term="Network" scheme="https://coolwcan.cn/categories/Network/"/>
    
    
      <category term="Network" scheme="https://coolwcan.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ实现无阻塞消息重试</title>
    <link href="https://coolwcan.cn/RabbitMQ/J2ee/RabbitMQ%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%98%BB%E5%A1%9E%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95/"/>
    <id>https://coolwcan.cn/RabbitMQ/J2ee/RabbitMQ实现无阻塞消息重试/</id>
    <published>2019-03-28T15:03:06.654Z</published>
    <updated>2019-03-28T15:05:18.178Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-_问题">1. 问题</h4><p>在处理接受到的消息时，如果发生了异常，然后该消息将一直重试。一直重试这个操作倒没有问题，但是这个重试的操作，是一个阻塞的过程，导致没办法去处理队列中其它的消息，这个现象是致命的。</p><h4 id="2-_调研及分析">2. 调研及分析</h4><p>经过调研，发现有三个技术方案涉及到消息重试，分别是:</p><ol><li>利用Spring retry实现可定制化的重试；</li><li>实现 <code>MessageRecoverer</code></li><li>死信队列</li></ol><p>其实方案一与方案二，可以算作一类，即配置 Interceptor，相关联的类是 <code>StatefulRetryOperationsInterceptorFactoryBean</code> 和 <code>StatelessRetryOperationsInterceptorFactoryBean</code>，但是它们有一个问题，的确它们能够实现定制化的重试，但是其并没有解决阻塞这个问题。Spring retry 是可以定制重试的次数及每次重试的间隔，而 <code>MessageRecover</code> 则是在重试结束后，给你一个机会去处理这个消息。而死信队列，它能够实现消息的转发，并且会在消息头上加上 <code>x-death</code> 信息，能够保存消息原来的 exchange 与 queue，然后我们觉得利用这个可以实现非阻塞。</p><h4 id="3-_死信机制">3. 死信机制</h4><p>会有三种情况会触发死信机制:</p><ol><li>消息被拒绝（basic.reject/ basic.nack）并且requeue=false</li><li>消息TTL过期（参考：RabbitMQ之TTL（Time-To-Live 过期时间））</li><li>队列达到最大长度</li></ol><p>当触发死信机制后，会通过配置的 exchange 发送到指定的队列</p><h4 id="4-_解决方案的思路">4. 解决方案的思路</h4><ol><li>在处理消息时，不能抛出业务异常，因为MQ是一个消息中间件，业务上的异常，其本身是没有处理的能力的</li><li>把消息配置成手动确认的模式</li><li>关闭重试功能，利用Spring retry，配置成 <code>org.springframework.retry.policy.NeverRetryPolicy</code>，即永不重试</li><li>创建死信队列的exchange(dlx), 创建死信队列 (dlq), 创建超时队列的exchange (timeout_exchange), 创建超时队列 (timeout_queue)</li><li><p>在超时队列上也设置死信机制:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;timeout_queue&quot;&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;kk.timeout&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>当然`timeout_exchange`就是如下的配置了:`kk.timeout` 指明的是当消息超时，将消息发送到dlq时用的key<span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:direct-exchange name=&quot;timeout_exchange&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding queue=&quot;timeout_queue&quot; key=&quot;timeout.queue&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:direct-exchange&gt;</span><br></pre></td></tr></table></figure></span>所以发送到 `timeout_queue` 的key必须为 `timeout.queue`</code></pre><ol start="6"><li><p>在需要重试机制的队列上配置如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;yourQueue&quot;&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;dlx&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个配置，表明当处理该队列的消息出现异常时，将会把这个消息通过dlx发送出去，当然你也可以通过配置 `x-dead-letter-routing-<span class="variable">key</span>` 指明把这个消息发送出去时的route-<span class="variable">key</span>，如果不指定的话，则会用原来的route-<span class="variable">key</span></code></pre><ol start="7"><li>然后配置一个Listener 去消费 <code>dlq</code> 中的消息，根据消息头的 <code>x-death</code> 去计算其失败的次数，可以根据失败的次数，计算出下次重试的时间，然后在其消息头上设置 <code>expiration</code> 字段，然后将其通过 <code>timeout_exchange</code> 发送到 <code>timeout_queue</code>，当消息过期后，又将返回到 <code>dlq</code> 此时再根据 <code>x-death</code> 信息，判断是否应该发送到 <code>timeout_queue</code> 还是发送到原来的队列里面。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-_问题&quot;&gt;1. 问题&lt;/h4&gt;&lt;p&gt;在处理接受到的消息时，如果发生了异常，然后该消息将一直重试。一直重试这个操作倒没有问题，但是这个重试的操作，是一个阻塞的过程，导致没办法去处理队列中其它的消息，这个现象是致命的。&lt;/p&gt;
&lt;h4 id=&quot;2-_调研及分析&quot;&gt;
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://coolwcan.cn/categories/RabbitMQ/"/>
    
    
  </entry>
  
  <entry>
    <title>Java JDK8 New Features</title>
    <link href="https://coolwcan.cn/Java/Java/JDK8%20New%20Features/"/>
    <id>https://coolwcan.cn/Java/Java/JDK8 New Features/</id>
    <published>2019-03-20T11:29:15.015Z</published>
    <updated>2019-03-20T11:29:30.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_default_:_接口能增加默认方法，又称为扩展方法">1. default : 接口能增加默认方法，又称为扩展方法</h3><p>增加该接口主要是主为了在不影响之前的接口的前提下，为接口增加方法，如List接口中stream方法，例如：</p><pre><code><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>{        <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    <span class="keyword">default</span> <span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{        <span class="function"><span class="keyword">return</span> Math.<span class="title">sqrt</span><span class="params">(a)</span></span>;    }}</code></pre><h3 id="2-_Lambda表达式">2. Lambda表达式</h3><ol><li><p>格式</p><ul><li>(Type1 param1, Type2 param2, …) -&gt; Statement1, Statement2, …, StatementN</li><li>(param1, param2, …) -&gt; Statement1, Statement2, …, StatementN</li></ul></li><li><p>注</p><ul><li>返回最后一个表达式的结果</li><li>lambda函数可以访问外部本地局部的变量，但是不能改变其值</li><li>lambda函数即可访问也可以修改静态变量</li><li>lambda函数不能直接访问默认函数</li></ul></li></ol><h3 id="3-_增加的注解">3. 增加的注解</h3><p>@FunctionInterface : 函数接口，将lambda表达式映射到一个单方法的接口上</p><ul><li><p>格式</p><pre><code><span class="annotation">@FunctionalInterface</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">T</span>, <span class="title">F</span>&gt; </span>{    <span class="function">T <span class="title">convert</span><span class="params">(F f)</span></span>;}</code></pre></li><li><p>使用</p><pre><code>Converter&lt;<span class="keyword">String</span>, Integer&gt; converter = (from) -&gt; <span class="keyword">String</span>.valueOf(from);<span class="keyword">String</span> <span class="built_in">str</span> = converter.convert(<span class="number">123</span>);System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</code></pre></li></ul><h3 id="4-_增加的操作符">4. 增加的操作符</h3><p>::  操作符，用来对方式和构造函数的引用</p><ul><li><p>针对方法的引用</p><pre><code>Converter&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; converter = <span class="built_in">Integer</span><span class="tag">::valueOf</span>;<span class="built_in">Integer</span> converted = converter<span class="built_in">.</span>convert(<span class="string">"123"</span>);System<span class="built_in">.</span>out<span class="built_in">.</span>println(converted);                <span class="comment">// 123</span></code></pre></li><li><p>针对构造函数的引用</p><pre><code><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{    <span class="built_in">String</span> firstName;    <span class="built_in">String</span> lastName;    Person() {}    Person(<span class="built_in">String</span> firstName, <span class="built_in">String</span> lastName) {        <span class="keyword">this</span>.firstName = firstName;        <span class="keyword">this</span>.lastName = lastName;    }}<span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>{    P create(<span class="built_in">String</span> firstName, <span class="built_in">String</span> lastName);}PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</code></pre></li></ul><h3 id="5-_特殊接口">5. 特殊接口</h3><ol><li><p>Predicate接口，用于与、或、非组成复杂的逻辑</p><pre><code>Predicate&lt;<span class="built_in">String</span>&gt; predicate = (s) <span class="subst">-&gt; </span>s<span class="built_in">.</span>length() &gt; <span class="number">0</span>;Predicate&lt;<span class="built_in">Boolean</span>&gt; nonNull = Objects<span class="tag">::nonNull</span>;predicate<span class="built_in">.</span>negative<span class="built_in">.</span>test(<span class="string">"abc"</span>);</code></pre></li><li><p>Consumer<t>接口，所对应的是一个传入一个类型T的实例对象，返回的类型为void的函数</t></p><pre><code>Consumer&lt;Person&gt; greeter = <span class="function"><span class="params">(p)</span> -&gt;</span> System.out.println(<span class="string">"Hello, "</span> + p.firstName);greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</code></pre></li><li><p>Supplier<t>接口，所对应的是一个不用传入任何的类型，返回一个类型T的实例对象，而且每次获取的对象都不一样的函数</t></p><pre><code>Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;personSupplier.<span class="keyword">get</span>(); <span class="comment">// new Person</span></code></pre></li><li><p>Function&lt;F，T&gt;接口，所对应的是一个传入一个类型F的实例对象，返回一个类型为T的实例对象</p><pre><code><span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; toInteger = <span class="built_in">Integer</span><span class="type-annotation">::</span>valueOf;System.out.println((toInteger.apply(<span class="string">"123456"</span>) instanceof <span class="built_in">Integer</span>));</code></pre></li></ol><h3 id="6-_stream操作">6. stream操作</h3><ol><li><p>过滤</p><ul><li><p>Filter</p><pre><code>Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).filter(n -&gt; n &gt; <span class="number">3</span>).forEach(System.out::println);</code></pre></li><li><p>distinct</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="keyword">distinct</span>().forEach(<span class="type">System</span>.<span class="keyword">out</span>::println);</code></pre></li></ul></li><li><p>遍历</p><ul><li><p>forEach, 用于有序列化流的遍历</p><pre><code>Stream.<span class="keyword">of</span>(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).forEach(System.<span class="keyword">out</span>::println);</code></pre></li><li><p>forEachOrdered, 用于并发流时，合成一个有序的集合后，再进行遍历</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.forEachOrdered(<span class="type">System</span>.out::println);</code></pre><p>  如果将forEachOrdered改成forEach，得到的结果，将不会是有序的，但是如果加上collect操作后，得到结果又是正确的，可以测试下面几个语句：</p><pre><code><span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.forEach(<span class="type">System</span>.out::println);<span class="type">System</span>.out.println(<span class="string">"========================="</span>);<span class="type">Stream</span>.<span class="keyword">of</span>(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>).parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.collect(<span class="type">Collectors</span>.toList<span class="literal">()</span>).stream<span class="literal">()</span>.forEach(<span class="type">System</span>.out::println);</code></pre></li><li><p>peek，与forEach类似，它不同与forEach的是，它在执行完成后，还会返回流，而forEach，则是流的终止操作</p><pre><code><span class="tag">Stream</span><span class="class">.of</span>("<span class="tag">A</span>", "<span class="tag">B</span>", "<span class="tag">C</span>")<span class="class">.peek</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span><span class="class">.map</span>(<span class="tag">String</span><span class="pseudo">::toLowerCase)</span><span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>map</p><pre><code>Stream<span class="built_in">.</span>of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)<span class="built_in">.</span><span class="built_in">map</span>(<span class="built_in">String</span><span class="tag">::toLowerCase</span>)<span class="built_in">.</span>forEach(System<span class="built_in">.</span>out<span class="tag">::println</span>);</code></pre></li><li><p>mapToInt</p><pre><code><span class="tag">Stream</span><span class="class">.of</span>("1", "2", "3")<span class="class">.mapToInt</span>(<span class="tag">Integer</span><span class="pseudo">::valueOf)</span><span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>mapToLong</p><pre><code>Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).mapToLong(<span class="keyword">Long</span>::valueOf).<span class="keyword">forEach</span>(System.out::println);</code></pre></li><li><p>mapToDouble</p><pre><code>Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).mapToDouble(<span class="keyword">Double</span>::valueOf).<span class="keyword">forEach</span>(System.out::println);</code></pre></li><li><p>flatMap</p><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(    Arrays.asList(<span class="number">1</span>),    Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),    Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));inputStream.flatMap(Collection::stream).forEach(System.out::println);</code></pre></li><li><p>flatMapToInt</p><pre><code>Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(    Arrays.asList(<span class="number">1</span>),    Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),    Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));inputStream.flatMapToLong(<span class="built_in">array</span> -&gt; <span class="built_in">array</span>.stream().mapToLong(Long::valueOf)).forEach(System.out::println);</code></pre></li><li><p>flatMapToLong， 同上</p></li><li>flatMapToDouble， 同上</li><li><p>reduce, 处理每一个元素，并得到最终的结果</p><pre><code><span class="type">System</span>.<span class="keyword">out</span>.println(<span class="type">Stream</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce(<span class="number">0</span>, (<span class="literal">result</span>, num) -&gt; <span class="literal">result</span> + num));</code></pre></li></ul></li><li><p>排序</p><ul><li><p>sorted</p><ul><li><p>不带函数参数的</p><pre><code>Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>).sorted().forEach(System.out::println);</code></pre></li><li><p>自定义比较函数</p><pre><code>Person a = <span class="keyword">new</span> Person(<span class="string">"A"</span>, <span class="number">12</span>);Person b = <span class="keyword">new</span> Person(<span class="string">"B"</span>, <span class="number">8</span>);Person c = <span class="keyword">new</span> Person(<span class="string">"C"</span>, <span class="number">15</span>);Arrays.asList<span class="function"><span class="params">(a, b, c)</span>.<span class="title">stream</span><span class="params">()</span>.<span class="title">sorted</span><span class="params">((x, y) -&gt; x.getAge() - y.getAge())</span>.<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></code></pre><p>  结果为：</p><pre><code>Person{name=<span class="string">'B'</span>, age=<span class="number">8</span>}Person{name=<span class="string">'A'</span>, age=<span class="number">12</span>}Person{name=<span class="string">'C'</span>, age=<span class="number">15</span>}</code></pre></li></ul></li><li><p>max</p><pre><code>System.out.println<span class="function"><span class="params">(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().max((x, y) -&gt; x - y).get())</span>;</span></code></pre></li><li><p>min</p><pre><code>System.out.println<span class="function"><span class="params">(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().min((x, y) -&gt; x - y).get())</span>;</span></code></pre></li></ul></li><li><p>匹配</p><ul><li><p>全部匹配</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().allMatch(n -&gt; n &gt; <span class="number">0</span>));</code></pre></li><li><p>部分匹配</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().anyMatch(n -&gt; n &gt; <span class="number">5</span>));</code></pre></li><li><p>不匹配, noneMatch</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().noneMatch(n -&gt; n &lt; <span class="number">0</span>));</code></pre></li></ul></li><li><p>计数</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>).stream().count());</code></pre></li><li><p>并行流</p><ul><li><p>parallelStream</p><pre><code>System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).parallelStream().isParallel());</code></pre></li><li><p>parallel</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>isParallel</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>sequential</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.parallel</span>()<span class="class">.sequential</span>()<span class="class">.isParallel</span>());</code></pre></li><li><p>unordered</p><pre><code>long start = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">Arrays</span>.asList(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>).stream<span class="literal">()</span>.parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.map(i -&gt; i + <span class="number">1</span>).forEach(<span class="type">System</span>.out::println);long <span class="keyword">end</span> = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">System</span>.out.println(<span class="string">"A : "</span> + (<span class="keyword">end</span> - start));long start2 = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">Arrays</span>.asList(<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>).stream<span class="literal">()</span>.parallel<span class="literal">()</span>.sorted<span class="literal">()</span>.unordered<span class="literal">()</span>.map(i -&gt; i+<span class="number">1</span>).forEach(<span class="type">System</span>.out::println);long end2 = <span class="type">System</span>.currentTimeMillis<span class="literal">()</span>;<span class="type">System</span>.out.println(<span class="string">"B : "</span> + (end2 - start2));</code></pre></li></ul></li><li><p>流个数控制</p><ul><li><p>skip</p><pre><code>Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().skip(<span class="number">2</span>).forEach(System.out::println);</code></pre></li><li><p>limit</p><pre><code>Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().limit(<span class="number">2</span>).forEach(System.out::println);</code></pre></li><li><p>findAny</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.findAny</span>()<span class="class">.get</span>());</code></pre></li><li><p>findFirst</p><pre><code><span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.findFirst</span>()<span class="class">.get</span>());</code></pre></li></ul></li><li><p>迭代器</p><ul><li><p>spliterator, 用于并行流，forEachRemaining，能够保证并行流的顺序性</p><p>  Arrays.asList(“A”, “B”, “C”, “D”, “E”).stream().spliterator().forEachRemaining(System.out::println);</p></li><li><p>iterator</p><p>  Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + “ “));</p></li></ul></li><li><p>流的聚合</p><ul><li><p>collect</p><pre><code><span class="tag">Arrays</span><span class="class">.asList</span>(1, 2, 3, 4, 5)<span class="class">.stream</span>()<span class="class">.map</span>(<span class="tag">n</span> <span class="tag">-</span>&gt; <span class="tag">n</span>+1)<span class="class">.collect</span>(<span class="tag">Collectors</span><span class="class">.toList</span>())<span class="class">.stream</span>()<span class="class">.forEach</span>(<span class="tag">System</span><span class="class">.out</span><span class="pseudo">::println)</span>;</code></pre></li><li><p>toArray</p><pre><code>Object[] t = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).stream().<span class="built_in">map</span>(n -&gt; n + <span class="number">1</span>).toArray();Arrays.asList(t).stream().forEach(System.out::println);</code></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_default_:_接口能增加默认方法，又称为扩展方法&quot;&gt;1. default : 接口能增加默认方法，又称为扩展方法&lt;/h3&gt;&lt;p&gt;增加该接口主要是主为了在不影响之前的接口的前提下，为接口增加方法，如List接口中stream方法，例如：&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="jdk8" scheme="https://coolwcan.cn/tags/jdk8/"/>
    
  </entry>
  
  <entry>
    <title>Java-Arrays中的asList函数</title>
    <link href="https://coolwcan.cn/Java/Java/Java-Arrays%E4%B8%AD%E7%9A%84asList%E5%87%BD%E6%95%B0/"/>
    <id>https://coolwcan.cn/Java/Java/Java-Arrays中的asList函数/</id>
    <published>2019-03-20T11:24:23.559Z</published>
    <updated>2019-03-20T11:24:57.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_问题">1. 问题</h3><ul><li><p>代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] dd = new int[]&#123;3, 2, 1&#125;;</span><br><span class="line">Arrays.asList(dd).stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>结果<br>  <code>[I@41629346]</code></p></li></ul><h3 id="2-_分析">2. 分析</h3><p>其 <code>Arrays.asList</code> 的源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按通常的理解而言，此处的 <code>T</code> 指向的是 <code>int</code>，而基础类型是不能泛化的，但是 <code>int[]</code> 该类型可以。所以为了解决问题，只需要传入其包装类型就好。具体深入其中会发现， 此处的 <code>ArrayList</code> 非彼 <code>ArrayList</code>，其是一个内部类，继承自 <code>AbstractList</code>，其 <code>add</code>、<code>set</code> 方法并没重写，所以通过该方法返回的 <code>List</code> 并不能修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_问题&quot;&gt;1. 问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java自动装箱与拆箱</title>
    <link href="https://coolwcan.cn/Java/Java/Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <id>https://coolwcan.cn/Java/Java/Java自动装箱与拆箱/</id>
    <published>2019-03-20T09:55:42.194Z</published>
    <updated>2019-03-20T11:19:49.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_自动装箱与拆箱">1. 自动装箱与拆箱</h3><ul><li>自动装箱，就是将基础类型自动转换成相应的包装类型</li><li>自动拆箱，就是将包装类型自动转换成相应的基础类型</li></ul><h3 id="2-_8种包装类型，什么情况下可以直接使用”=”">2. 8种包装类型，什么情况下可以直接使用”=”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Short           -128 ~ 127</span><br><span class="line">Integer         -128 ~ 127</span><br><span class="line">Long            -128 ~ 127</span><br><span class="line">Character          0 ~ 127</span><br><span class="line">Byte            -128 ~ 127</span><br><span class="line">Float              都不能</span><br><span class="line">Double             都不能</span><br><span class="line">Boolean       如果使用Boolean.FALSE或者Boolean.TRUE就可以</span><br></pre></td></tr></table></figure><h3 id="3-_什么情况下，会触发自动装箱与拆箱?">3. 什么情况下，会触发自动装箱与拆箱?</h3><ul><li>进行运算操作，比如对Short或者Integer，进行算术运算</li><li>装箱会调用 <code>valueof</code> 方法, 拆箱会调用 <code>intValue</code> 方法</li></ul><h3 id="4-_注意点">4. 注意点</h3><ul><li>Long与Integer比较时, 总是false</li><li>基础类型可以直接使用<code>=</code>比较，此时是比较的是值</li><li>包装类型使用<code>=</code>比较时，此时是比较的内存地址</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_自动装箱与拆箱&quot;&gt;1. 自动装箱与拆箱&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自动装箱，就是将基础类型自动转换成相应的包装类型&lt;/li&gt;
&lt;li&gt;自动拆箱，就是将包装类型自动转换成相应的基础类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-_8种包装类型，什么情况下可以直
      
    
    </summary>
    
      <category term="Java" scheme="https://coolwcan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java应用高并发优化漫谈</title>
    <link href="https://coolwcan.cn/J2ee/J2ee/Java%E5%BA%94%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96%E6%BC%AB%E8%B0%88/"/>
    <id>https://coolwcan.cn/J2ee/J2ee/Java应用高并发优化漫谈/</id>
    <published>2019-03-15T07:09:28.545Z</published>
    <updated>2019-03-15T07:11:40.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景">一、背景</h3><p>现在<code>QBus</code>每天有<strong>1.1～1.2</strong>亿次访问量，其中消息发送和删除的请求有<strong>9~10</strong>千万次，由两台4核8G的机器提供服务，消息拉取接口有<strong>1～2千万</strong>左右的访问量，同样也是由两台4核8G的机器提供服务。以下就是我们在提高服务整体性能上所做出的优化。</p><h3 id="二、优化思路">二、优化思路</h3><p>在谈优化思路前，首先需要搞清楚一个<code>QBus</code>请求是如何从各个服务器走到<code>qbus-server</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk ==&gt; 域名解析 ==&gt; http协议 ==&gt; kong(nginx) ==&gt; qbus-server</span><br></pre></td></tr></table></figure><p>以下是针对每个环节提供的一些优化点，大家可以深入了解一下:</p><ul><li><p>SDK<br><br>TCP的keepalive，复用连接，使用连接池</p></li><li><p>域名解析如何优化呢？<br><br>CDN，选择就近资源</p></li><li><p>HTTP协议优化如何优化呢？<br><br>现在比较流行的是<code>HTTP/1.1</code>，但是可以的话，用<code>HTTP/2</code>，性能将提高很多</p></li><li><p>kong优化？<br><br>操作系统优化和nginx的优化</p></li><li><p><code>qbus-server</code>如何优化？<br><br>操作系统优化、jvm优化、tomcat优化、代码优化</p></li></ul><p>主要叙述的是<code>qbus-server</code>的优化，以下将会从这几个方面讲解一下<code>qbus-server</code>中的优化:</p><ul><li>操作系统优化</li><li>JVM优化</li><li>Tomcat优化</li><li>代码优化</li></ul><h3 id="三、内核及网络优化">三、内核及网络优化</h3><p>以下主要基于腾讯云上的Centos7的内核、网络优化。大家可以根据各自的情况进行相应的调整。</p><p>调整步骤:</p><ul><li>用<code>root</code>权限编辑<code>/etc/sysctl.conf</code>文件</li><li>执行<code>sysctl -p</code>使配置生效</li></ul><p>特别注意在修改线上文件前，请先备份。注释的为默认值配置</p><h4 id="3-1_关闭无用的资源">3.1 关闭无用的资源</h4><ul><li><p>关闭<code>ipv6</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br></pre></td></tr></table></figure></li><li><p>数据转发<br><br>可以实现数据转发，通常用于将一张网卡的数据转发到另一张网发上</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.ip_forward = 0</span><br></pre></td></tr></table></figure></li><li><p>不处理无源地址的网络包</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"></span><br><span class="line"># net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2_安全方面优化">3.2 安全方面优化</h4><ul><li><p><code>开启防欺骗攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure></li><li><p><code>避免ping flood攻击</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br></pre></td></tr></table></figure></li><li><p>开启防SYN洪水攻击，当出现SYN等待队列溢出时，启用cookies来处理</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3_TCP优化">3.3 TCP优化</h4><ul><li><p><code>keepalive</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效，默认是7200s</span><br><span class="line"># net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line"></span><br><span class="line"># keepalive探针，当对方不给予回应时，发送的探针的次数</span><br><span class="line"># net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"></span><br><span class="line"># keepalive探针的间隔，单位秒</span><br><span class="line"># net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`H</span>TTP<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`分</span>别有什么作用？<span class="escape">`H</span>TTP/<span class="number">1.0</span><span class="escape">`协</span>议，每一个HTTP请求开始，都将打开一个TCP连接，请求结束，都将会关闭TCP连接。从<span class="escape">`H</span>TTP/<span class="number">1.1</span><span class="escape">`开</span>始，提供了<span class="escape">`k</span>eepalive<span class="escape">`功</span>能，指的是同时请求同一个服务的同一台机器时，请求结束后，并不会立即关闭TCP连接，而是保留一段时间，在保留时间段内的请求，会复用TCP连接，过期后，才会真正结束TCP连接。TCP的<span class="escape">`k</span>eepalive<span class="escape">`指</span>的是<span class="escape">`T</span>CP<span class="escape">`协</span>议层面上的一个检测机制，当某一个TCP连接没有数据传输后，会存在着一个定时器用于确定一个<span class="escape">`T</span>CP<span class="escape">`连</span>接是否依然存活，以决定是否关闭当前连接。<span class="label">从上面的解释大家也能看出他们的区别，它们是两个不同层面上的协议，但是它们会共同影响`TCP`连接的生命周期。从时间上，`TCP`的`keepalive`和`HTTP`的`keepalive`会了出现如下几种情况:</span><span class="number">1</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间一样<span class="number">2</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间大<span class="number">3</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间小因为<span class="escape">`H</span>TTP<span class="escape">`是</span>比<span class="escape">`T</span>CP<span class="escape">`更</span>高层的协议，当<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`的</span>时间一样，或者比<span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`小</span>，其逻辑会是正常的，因为HTTP先关，再关TCP嘛。但是如果<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`大</span>，则有可能会出现，<span class="escape">`H</span>TTP<span class="escape">`的</span>连接依然在复用，但是<span class="escape">`T</span>CP<span class="escape">`已</span>经关闭。</code></pre><ul><li><p><code>TIME_WAIT</code>状态的重用及回收</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 启TCP时间戳，用来计算往返时间RTT（Round-Trip Time）和防止序列号回绕，用于支持tcp_tw_reuse和tcp_tw_recycle</span><br><span class="line"># net.ipv4.tcp_timestamps = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的状态的重用</span><br><span class="line"># net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的快速回收，在对外网提供服务时，需要关闭</span><br><span class="line"># net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`T</span>IME-WAIT<span class="escape">`会</span>保持两个周期(<span class="escape">`M</span>S<span class="escape">`)</span>，而一个<span class="escape">`M</span>S<span class="escape">`是</span>一个IP报文最大的存活时间，而两个周期在于客户端发出<span class="escape">`A</span>CK<span class="escape">`到</span>达服务器的过程和数据报来到客户端的过程。只有在两个<span class="escape">`M</span>S<span class="escape">`内</span>没有任何数据，才能让客户端确定再没有任何的数据来自服务器，才能关闭<span class="escape">`S</span>ocket<span class="escape">`。</span><span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>快速回收，是一种基于时间序列的快速回收机制，并不会让<span class="escape">`T</span>IME_WAIT<span class="escape">`状</span>态持续两个周期，而是保持一个重传时间，能够快速释放资源。<span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>重用，当满足特定条件的<span class="escape">`S</span>ocket<span class="escape">`，</span>可以用于接受新的连接，而不用先关闭再连接。</code></pre><ul><li><p><code>TCP</code>内存</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 内核分配给TCP连接的内存，单位是page：</span><br><span class="line">#  第一个数字表示TCP使用的page少于此值时，内核不进行任何处理（干预），</span><br><span class="line">#  第二个数字表示TCP使用的page超过此值时，内核进入“memory pressure”压力模式，</span><br><span class="line">#  第三个数字表示TCP使用的page超过些值时，报“Out of socket memory”错误，TCP 连接将被拒绝</span><br><span class="line"># net.ipv4.tcp_mem = 7658911021191 1531782</span><br><span class="line">net.ipv4.tcp_mem = 88557 118079 177114</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的读缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_rmem = 4096873806291456</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 6291456</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的写缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_wmem = 4096163844194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重试次数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP连接时，SYN 重发的最大次数</span><br><span class="line"># net.ipv4.tcp_syn_retries = 6</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line"># TCP连接时重发ACK的最大次数</span><br><span class="line"># net.ipv4.tcp_synack_retries = 5</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line"># 孤儿sockets废弃前重试的次数</span><br><span class="line"># net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure></li></ul><pre><code><span class="escape">`孤</span>儿sockets<span class="escape">`指</span>的是已经从进程上下文中删除了，可是还有一些清理工作没有完成的<span class="escape">`s</span>ocket<span class="escape">`。</span></code></pre><ul><li><p>端口范围</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口范围，提高服务能力</span><br><span class="line"># net.ipv4.ip_local_port_range = 32768 60999</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure></li><li><p>Other</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 设置FIN_WAIT2的等待时间，单位秒，默认为60</span><br><span class="line"># net.ipv4.tcp_fin_timeout = 60</span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br><span class="line"></span><br><span class="line"># 设置TIME_WAIT的最大个数，大于这个阀值后会被删除</span><br><span class="line"># net.ipv4.tcp_max_tw_buckets = 131072</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line"># 表示SYN队列的长度，默认为1024，可以容纳更多等待连接</span><br><span class="line"># net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 100000</span><br><span class="line"></span><br><span class="line"># 用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制</span><br><span class="line"># net.core.somaxconn = 128</span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line"></span><br><span class="line"># 即不属于任何进程的tcp socket最大数量. 超过这个数量的socket会被reset, 并同时告警</span><br><span class="line"># net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">net.ipv4.tcp_max_orphans = 100000</span><br><span class="line"></span><br><span class="line"># 当网卡接受数据包的速率, 比kernel处理来的快时, cache这些数据包的队列长度，默认是1000</span><br><span class="line"># net.core.netdev_max_backlog = 1000</span><br><span class="line">net.core.netdev_max_backlog = 32768</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4_其它">3.4 其它</h4><ul><li><p>日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 用于调试内核</span><br><span class="line"># kernel.sysrq = 1</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line"></span><br><span class="line"># 用于在core dump文件中，增加进程ID</span><br><span class="line"># kernel.core_uses_pid = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br></pre></td></tr></table></figure></li><li><p>内核队列</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 控制一个消息的大小，bytes</span><br><span class="line"># kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"></span><br><span class="line"># 限制一个队列的最大消息个数</span><br><span class="line"># kernel.msgmax = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、JVM优化">四、JVM优化</h3><p>JVM优化主要针对两个方面，<strong>内存</strong>和<strong>GC</strong>，以确保服务的质量和服务所占内存处于一个稳定状态。首先先介绍一下JVM的内存分布和现有<code>GC</code>算法</p><h4 id="4-1_JVM内存">4.1 JVM内存</h4><p>JVM中的内存主要有如下几个部分组成:</p><ul><li><p>程序计数器<br><br>用于指明当前线程需要执行的字节码行；<strong>线程私有</strong>；如果是Java方法，则记录虚拟机字节码指令地址，如果为<code>native</code>方法，则为<code>Undefined</code></p></li><li><p>虚拟机栈<br><br>每一个方法执行时，都将创建一个栈帧，用于记录局部变量、操作栈、动态链接、方法出口等，当方法被调用时，栈帧入栈，执行完成后，出栈。<strong>线程私有</strong>。</p></li><li><p>本地方法栈<br><br>与虚拟机栈类似，唯一的区别就是：虚拟机栈保存Java方法栈帧，而本地方法栈保存native方法栈帧。<strong>线程私有</strong>。</p></li><li><p>堆区<br><br>GC的主要区域，由<strong>所有线程共享</strong>，在虚拟机启动时创建，用于存储对象实例。</p></li><li><p>方法区<br><br>各个线程共享的区域，用于存储已经被虚拟机加载的类信息、final常量、静态变量、编译器即时编译的代码等。</p></li><li><p>直接内存<br><br>不受JVM管理的内存。</p></li></ul><p>而我们所做的优化主要针对堆区，而堆又分成：<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>、<code>Old</code>，其中<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>被统称为年轻代，<code>Old</code>是老年代。</p><h4 id="4-2_GC算法">4.2 <code>GC</code>算法</h4><p><code>GC</code>主要用于回收堆内存，而堆主要包含两个部分:</p><ul><li>年轻代</li><li>老年代</li></ul><p>针对年轻代的<code>GC</code>称为<code>Minor GC</code>，针对老年代的<code>GC</code>称为<code>Full GC</code>。</p><p>由于年轻代具有生命周期短的特点，通常采用 <strong>停止-复制</strong>的算法，其主要的算法有:</p><ul><li><p>Serial<br><br>新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。</p></li><li><p>ParNew<br><br>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。</p></li><li><p>Parallel Scavenge<br><br>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</p></li></ul><p>针对老年代对象具有数量多，对象大的特点，通常采用 <strong>标记-整理</strong>的算法，其算法有:</p><ul><li><p>Serial Old<br><br>老年代收集器，单线程收集器，使用标记整理的策略，单线程GC，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>Parallel Old<br><br>老年代，多线程收集器，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p></li><li><p>CMS<br><br>Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</p><ol><li>初始标记， 仅仅标记一下GC Roots能直接关联到的对象</li><li>并发标记， 进行GC Roots Tracing的过程</li><li>重新标记， 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li><p>并发清除， 标记某一个对象不可用</p><p>初始标记与重新标记仍然需要停止其它工作线程。其主要的2个过程，都采用并发的操作，能够保证与工作线程一起运行。但是该算法对CPU资源很敏感，CPU越多，越快；无法处理浮动垃圾，即在一次GC过程中，可能又会出现一些垃圾，需要下次GC去处理，因为它没有停止工作线程；会产生大量内存碎片，没有整理。</p></li></ol></li><li><p>G1<br><br>基于“标记-整理”算法实现的收集器，不会产生空间碎片。G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p></li></ul><h4 id="4-3_JVM优化">4.3 JVM优化</h4><p>为了避免<code>GC</code>带来的停顿影响服务质量，在内存和GC优化过程中会有如下经验:</p><ul><li>年轻代使用<code>ParNew</code>算法，老年代使用<code>CMS</code>算法，能够减少系统由于GC带来的停顿，当然也可以直接用<code>G1</code>算法，<code>QBus</code>线上使用的就是<code>ParNew</code>和<code>CMS</code>的组合</li><li>最大堆和最小堆设置成一样，能够避免扩容引起的<code>Full GC</code></li><li>最大堆的大小，不能超过整个物理机内存的50%</li><li>年轻代的大小，最好占整个堆的 <code>3/8</code></li><li><code>Eden</code>和<code>Survivor</code>的比例是<code>8</code></li><li><code>-XX:+DisableExplicitGC</code>，这个参数慎用，<code>DirectBuffer</code>的内存释放依赖<code>System.gc()</code>，会导致内存泄露。</li></ul><p>除了内存与<code>GC</code>优化外，以下几个方面也是需要优化的:</p><ul><li>打印<code>GC</code>日志</li><li>出现内存问题时，导出内存到文件</li></ul><p>如下是线上的一台<code>QBus</code>机器的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-server </span><br><span class="line">                  -XX:+PrintGCDetails </span><br><span class="line">                  -XX:+PrintGCDateStamps </span><br><span class="line">                  -Xloggc:/data/logs/qbus-server/jvm-gc/gc.log </span><br><span class="line">                  -XX:ErrorFile=/data/logs/qbus-server/jvm-error/error.log </span><br><span class="line">                  -Xms4096M </span><br><span class="line">                  -Xmx4096M </span><br><span class="line">                  -Xss228k </span><br><span class="line">                  -Xmn1536M </span><br><span class="line">                  -XX:SurvivorRatio=8 </span><br><span class="line">                  -XX:+UseParNewGC </span><br><span class="line">                  -XX:+UseConcMarkSweepGC </span><br><span class="line">                  -XX:+AggressiveOpts </span><br><span class="line">                  -XX:MaxTenuringThreshold=15 </span><br><span class="line">                  -XX:+CMSParallelRemarkEnabled  </span><br><span class="line">                  -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure><h3 id="五、Tomcat优化">五、Tomcat优化</h3><p>Tomcat的优化主要从如下几个方面进行优化:</p><ul><li>网络模型</li><li>连接池</li><li>线程池</li><li>超时时间</li><li>TCP参数</li></ul><p>下面将从这几个方面谈优化。</p><h4 id="5-1_网络模型">5.1 网络模型</h4><p>Tomcat8.5版本中，<code>Connector</code>的<code>protocol</code>支持三个模式:</p><ul><li><p><code>org.apache.coyote.http11.Http11NioProtocol</code><br><br>同步非阻塞，用Java的NIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11Nio2Protocol</code><br><br>异步非阻塞，用Java的AIO实现</p></li><li><p><code>org.apache.coyote.http11.Http11AprProtocol</code><br><br>异步非阻塞，通过<code>JNI</code>的方式调用核心链接库来处理文档读取和网络传输。该协议会用到如下几个库:</p><ol><li>Apache Portable Run-time libraries(Apache可移植运行库，APR)</li><li>JNI wrappers for APR used by Tomcat (libtcnative)</li><li><p>OpenSSL</p><p><code>APR</code>库，是一个跨平台库，提供与平台无关的API，能够保证同一个API，在不同平台下运行，其结果总是一致的。而<code>libtcnative</code>则会调用<code>APR</code>库进行文档和网络传输的处理。而<code>Tomcat</code>则会通过<code>JNI</code>调用<code>libtcnative</code>库。</p></li></ol></li></ul><p><code>org.apache.coyote.http11.Http11AprProtocol</code>是<code>Tomcat</code>上运行高并发的首选，接下来将介绍如何安装APR库。</p><hr><p>首先创建<code>tomcat-native-install.sh</code>脚本，并添加执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">base=`pwd`</span><br><span class="line">#tomcat的安装目录</span><br><span class="line">tomcat_base=$1</span><br><span class="line">#希望编译好的lib放到什么地方</span><br><span class="line">lib_base=$2</span><br><span class="line">    </span><br><span class="line">function install_openssl() &#123;</span><br><span class="line">    openssl=openssl-1.1.0f</span><br><span class="line">    wget https://www.openssl.org/source/$&#123;openssl&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;openssl&#125;.tar.gz</span><br><span class="line">    cd $&#123;openssl&#125; </span><br><span class="line">    ./config --prefix=$&#123;base&#125;/ssl no-shared -fPIC</span><br><span class="line">    make &amp;&amp; make install_sw</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;openssl&#125; $&#123;openssl&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_apr() &#123;</span><br><span class="line">    apr=apr-1.6.3</span><br><span class="line">    wget http://archive.apache.org/dist/apr/$&#123;apr&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;apr&#125;.tar.gz</span><br><span class="line">    cd $&#123;apr&#125;</span><br><span class="line">    ./configure --prefix=$&#123;base&#125;/apr</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;apr&#125; $&#123;apr&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_tomcat_native() &#123;</span><br><span class="line">    base_dir=`pwd`</span><br><span class="line">    cd $&#123;tomcat_base&#125;/bin</span><br><span class="line">    pwd</span><br><span class="line">    tar -xf tomcat-native.tar.gz</span><br><span class="line">    cd `ls $&#123;tomcat_base&#125;/bin | grep src`/native</span><br><span class="line">    ./configure --with-apr=$&#123;base&#125;/apr --with-ssl=$&#123;base&#125;/ssl --with-java-home=$JAVA_HOME --prefix=$lib_base</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd $base_dir</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">install_openssl</span><br><span class="line">install_apr</span><br><span class="line">install_tomcat_native</span><br><span class="line">    </span><br><span class="line">rm -rf $&#123;base&#125;/apr</span><br><span class="line">rm -rf $&#123;base&#125;/ssl</span><br><span class="line">    </span><br><span class="line">lib=$&#123;lib_base&#125;/lib</span><br><span class="line">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&apos;$&#123;lib&#125; &gt;&gt; ~/.profile</span><br><span class="line">source ~/.profile</span><br><span class="line">    </span><br><span class="line">echo 编译 Tomcat目录/conf/server.xml，将其中的 Connector 的 protocol 改成 org.apache.coyote.http11.Http11AprProtocol 和</span><br><span class="line">echo org.apache.coyote.ajp.AjpAprProtocol</span><br></pre></td></tr></table></figure><p>然后再用<code>root</code>执行<code>./tomcat-native-install.sh Tomcat的安装目录 APR库的安装位置</code>进行安装，在传参时，需要注意如下两点:</p><ol><li>传入给shell的参数需要全路径</li><li>传给shell的路径参数，最后不需要加上<code>/</code></li></ol><p>例如： <code>./tomcat-native-install.sh /usr/local/services/tomcat /usr/local/services/tomcat-apr/tomcat-native</code></p><p>安装完成后，还需要修改如下配置：</p><ol><li>修改<code>Tomcat目录/conf/server.xml</code>将其中的<code>Connector</code>的<code>protocol</code>改成<code>org.apache.coyote.http11.Http11AprProtocol</code> 和<code>org.apache.coyote.ajp.AjpAprProtocol</code></li><li>修改<code>Tomcat目录/bin/catalina.sh</code>中添加<code>JAVA_OPTS=&quot;$JAVA_OPTS -Djava.library.path=上面APR的安装目录/lib&quot;</code></li></ol><p>重启服务，即可生效。在<code>logs/catalina.out</code>，能看到如下输出，则能确定<code>APR</code>库生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">07-Mar-2019 11:46:15.871 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8080&quot;]</span><br><span class="line">07-Mar-2019 11:46:15.875 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]</span><br></pre></td></tr></table></figure><h4 id="5-2_连接池优化">5.2 连接池优化</h4><ul><li><p><code>acceptorThreadCount</code><br><br>在<code>Tomcat</code>中会由专门的<code>accept</code>线程用于接收请求，并将请求转交给工作线程。通常<code>accept</code>线程个数与CPU核数一致，默认值为1</p></li><li><p><code>acceptCount</code><br><br>当已经没有任何可用的工作线程为新的请求提供服务时，会将请求进行缓存。<code>acceptCount</code>则用于指定缓存队列的大小。当请求无法再放入缓存队列后，请求将会被拒绝。通常用户可能会在nginx层面上看到如下的异常:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure></li><li><p><code>maxConnections</code><br><br>用于设置<code>Tomcat</code>的最大连接数，这仅仅是Tomcat层面上的限制，超过最大连接数后，操作系统层面，仍然会接收请求，只是请求请求将会进入到缓存队列，当缓存队列满后，请求会被阻塞。可以设置为-1，关闭此限制。</p></li></ul><h4 id="5-3_线程池优化">5.3 线程池优化</h4><p>线程池的优化主要有两个方面:</p><ul><li>线程命名</li><li>线程个数</li></ul><p>线程命名是为在排查问题时，通过<code>jstack</code>命令查询，能够区分出哪些是<code>Tomcat</code>线程。而线程个数能够保证服务的稳定运行。<code>QBus</code>服务线上的配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Executor name=&quot;tomcatThreadPool&quot;</span><br><span class="line">              namePrefix=&quot;tomcatThreadPool-&quot;</span><br><span class="line">              maxThreads=&quot;500&quot;</span><br><span class="line">              maxIdleTime=&quot;10000&quot;</span><br><span class="line">              minSpareThreads=&quot;300&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 用于指明线程名字前缀</li><li><code>minSpareThreads</code> 初始化线程个数</li><li><code>maxThreads</code> 线程池的最大线程个数</li><li><code>maxIdleTime</code> 当某一个线程多久未使用，将会被回收，单位毫秒</li></ul><p>通常可以将线程个数的最大个数设置为500，或者更多，然后上线后，通过<code>jstack tomcat线程ID | grep Tomcat线程前缀名 | grep run | wc -l</code>查看线上稳定运行的线程个数，然后再去调整<code>minSpareThreads</code>。</p><p>请注意在Tomcat中的<code>TPS</code>是由<code>maxConnections</code>、<code>acceptCount</code>与<code>maxThreads</code>共同决定的。</p><h4 id="5-4_超时优化">5.4 超时优化</h4><p>Tomcat总体上有如下几个超时设置:</p><ul><li><p><code>connectionTimeout</code><br><br>当客户端与服务器已经建立连接后，等待客户端传输请求头时，最多等待<code>connectionTimeout</code>毫秒</p></li><li><p><code>keepAliveTimeout</code><br><br>针对<code>HTTP/1.1</code>协议，用于设置服务器最大保持连接的时间</p></li><li><p><code>disableUploadTimeout</code>和<code>connectionUploadTimeout</code><br><br>  当<code>disableUploadTimeout</code>为<code>false</code>时，<code>connectionUploadTimeout</code>才会生效。<code>connectionUploadTimeout</code>用于设置服务器等待客户传输请求体的最大等待时间。</p></li></ul><p>注意<code>connectionTimeout</code>和<code>connectionUploadTimeout</code>，这两个参数分别设置了传输请求头与请求体的最大等待时间。<code>QBus</code>的线上配置是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot;</span><br><span class="line">                executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">                protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">                URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">                enableLookups=&quot;false&quot;</span><br><span class="line">                connectionTimeout=&quot;30000&quot;</span><br><span class="line">                keepAliveTimeout=&quot;30000&quot;</span><br><span class="line">                disableUploadTimeout=&quot;false&quot;</span><br><span class="line">                connectionUploadTimeout=&quot;600000&quot;</span><br><span class="line">                acceptCount=&quot;500&quot;</span><br><span class="line">                useSendfile=&quot;false&quot;</span><br><span class="line">                compression=&quot;off&quot;</span><br><span class="line">                redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="5-5_TCP参数">5.5 TCP参数</h4><ul><li><p><code>tcpNoDelay</code><br><br>用于开启或者关闭<code>Nagle</code>算法。<code>Nagle</code>算法，会将小的<code>TCP</code>包合并成一个大的包再进行发送，避免过多的小报文的TCP头的资源消耗。通常在交互性比较强的应用中会关闭<code>Nagle</code>算法，默认是开启的。</p></li><li><p><code>connectionLinger</code><br><br>与<code>TCP</code>的<code>SO_LINGER</code>的选项一致，用于控制<code>TCP</code>的<code>close</code>行为。<code>SO_LINGER</code>通常有三个取值：</p><ol><li>-1，会将<code>socket</code>发送缓存区中的数据发送完成后，才关闭<code>socket</code></li><li>0，通过发送RST分组(而不是用正常的FIN|ACK|FIN|ACK四个分组)来关闭该连接，并放弃发送缓存区中的数据。</li><li>大于0，关闭时，进程将进入睡眠状态，内核通过定时器在超时前尽量发送数据，如果发送完成，则正常关闭，否则超时后，直接通过<code>RST</code>进行关闭，丢弃发送缓存区中的数据。</li></ol></li><li><p><code>deferAccept</code><br><br>与<code>TCP</code>中的<code>TCP_DEFER_ACCEPT</code>选项一致。在解释<code>TCP_DEFER_ACCEPT</code>参数前，先解释一下<code>TCP</code>的三次握手:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Client -&gt; Server：客户端给服务器发送SYN包</span><br><span class="line">2. Client &lt;- Server: 服务器在收到SYN包后，将返给客户SYN + ACK，Server端的连接为SYN_RECV状态</span><br><span class="line">3. Client -&gt; Server: 客户端收到SYN+ACK包后，向服务器发送ACK包，Client和Server端的连接均为ESTABLISHED</span><br></pre></td></tr></table></figure><p>  通常服务器在接受到最后的一个<code>ACK</code>包后，将进入<code>ESTABLISH</code>状态。此过程会出现一个问题，当服务器已经打开了连接，但是如果客户端一直不发数据的话，会占用服务器的资源。而<code>TCP_DEFER_ACCEPT</code>选项开启后，在接受到最后一个<code>ACK</code>后，并不会进入<code>ESTABLISH</code>状态，也并不会真正建立连接，而是保持在<code>SYN_RECV</code>状态，只是标记当前<code>socket</code>，当客户端的数据真正到来时，才建立连接。通常是需要开启<code>延迟ACK</code>，将<code>ACK</code>与数据一起发送，才能建立连接。</p></li><li><p><code>useSendfile</code><br><br>用于开启或者关闭<strong>零拷贝机制</strong>，该机制，通过减少数据在用户态和内核态的拷贝，从而提高性能。</p></li></ul><h4 id="5-6_Tomcat的注意点">5.6 Tomcat的注意点</h4><ul><li><code>Spring</code>项目，尽量不要将项目调整成<code>root</code>目录，否则有可能你会遇到某一个<code>bean</code>会被初始化两次的问题</li><li>一个<code>Tomcat</code>尽量只有一个项目</li></ul><h3 id="六、代码层面上的优化">六、代码层面上的优化</h3><p>代码方面，主要引入了内存级别的缓存层，将配置信息放入缓存，避免对数据库的读操作。多个进程间的缓存同步有两个机制进行保证:</p><ul><li>同步通过<code>QBus</code>本身进行同步</li><li>当从缓存中读取不到数据时，再读数据库，此时一定需要注意，避免出现<code>Dog Pipe Effect</code>现象</li></ul><p>加入缓存后，整个消息的发送时延多<code>40ms</code>降低到<code>10～15ms</code>之间。</p><h3 id="七、总结">七、总结</h3><p>以上就是<code>QBus</code>已经做过的优化，在孙哥(孙国峻)和我们沟通后，新版本的<code>QBus</code>中，我们将做如下的优化:</p><ol><li>减少对数据库的依赖，引入redis</li><li>模块分离，将<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>与页面逻辑进行模块分离</li><li>针对<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>接口，通过<code>netty</code>进行网络接连，这样可以自定义其<code>TCP</code>参数、连接池、线程池、网络模型等，而且除了能提高性能，同样也能给出详细的日志，比如metric信息、异常信息等，能更好地把控服务</li><li>优化日志，不直接写kafka，写文件，再同步到kafka，以便快速解决问题</li></ol><p>优化是一个长期过程，而要反复迭代，并且会很受到业务功能的影响，比如<code>QBus</code>的拉消息接口，其功能决定了这是一个慢操作，而发送消息、删除消息，就必须要保证尽可能快，所以相对而言，拉消息更消耗内存，而发送消息、删除消息接口更消耗CPU，所以优化时，也需要分开处理。欢迎大家补充指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、背景&quot;&gt;一、背景&lt;/h3&gt;&lt;p&gt;现在&lt;code&gt;QBus&lt;/code&gt;每天有&lt;strong&gt;1.1～1.2&lt;/strong&gt;亿次访问量，其中消息发送和删除的请求有&lt;strong&gt;9~10&lt;/strong&gt;千万次，由两台4核8G的机器提供服务，消息拉取接口有&lt;s
      
    
    </summary>
    
      <category term="J2ee" scheme="https://coolwcan.cn/categories/J2ee/"/>
    
    
      <category term="Java" scheme="https://coolwcan.cn/tags/Java/"/>
    
      <category term="高并发" scheme="https://coolwcan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper/"/>
    <id>https://coolwcan.cn/Zookeeper/Zookeeper/Zookeeper/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-_Zookeeper介绍">0. Zookeeper介绍</h3><p>Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务。其维护了一个类似Linux文件系统，但比它更简单，支持分布式的文件系统，能够保证对于节点的操作具有原子性，并且能够保证集群中所有服务器都具有相同的数据。有如下优点:</p><ol><li>原子性<br>更新只能成功或者失败，没有中间状态</li><li>顺序性<br>包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面</li><li>最终一致性(单系统镜像)<br>Client不论连接到哪个Server，都能看到完全一致的数据</li><li>等待无关<br>慢的或者失效的Client不得干预快速的Client的请求，使得每个Client都能有效的等待</li><li>可靠性<br>具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受</li><li>实时性<br>Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</li></ol><p>主要使用Zookeeper完成命名服务、配置管理、同步、组服务。使用的 <strong>ZAB(ZooKeeper Atomic Broadcast)协议</strong> 作为其数据一致性的算法。其最大的特性就是数据复制，具有如下的优势:</p><ol><li>容错<br>一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作</li><li>提高系统的扩展能力<br>把负载分布到多个节点上，或者增加节点来提高系统的负载能力</li><li>提高性能<br>让客户端本地访问就近的节点，提高用户访问速度</li></ol><h3 id="1-_基本概念">1. 基本概念</h3><ul><li>事务<br>Client发出的每一个操作数据的请求，都会包装成一个事务，用 ZXID 唯一标识事务。</li><li>ZXID<br>是64位的数字，高32位代表Leader周期的 epoch 编号，而低32位是一个简单递增的计数器。ZAB 使用 epoch 来区分不同的 Leader 周期</li><li><p>Znode<br>对于文件系统中的每一个层次，称为一个节点。节点能够存储数据，和一些额外的数据:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid: 创建时的事务</span><br><span class="line">   ctime: 创建时间</span><br><span class="line">   mZxid: 修改时的事务</span><br><span class="line">   mtime: 修改时间</span><br><span class="line">   pZxid: 子节点最后一次修改的事务</span><br><span class="line">   cversion: 子节点的修改版本号记录，子节点每修改一次，增加1</span><br><span class="line">   dataVersion： 当前节点的数据的修改记录，每修改一次，增加1</span><br><span class="line">   aclVersion: 用于控制节点的权限</span><br><span class="line">   ephemeralOwner: 如果是临时节点，则记录session id，否则为0</span><br><span class="line">   dataLength: 数据长度</span><br><span class="line">   numChildren: 子节点的个数</span><br></pre></td></tr></table></figure><p>  节点分为四类：<code>PERSISTENT</code>， <code>PERSISTENT_SEQUENTIAL</code>， <code>EPHEMERAL</code>， <code>EPHEMERAL_SEQUENTIAL</code>， 临时指的是Session关闭时，节点将会删除，持久是指是否可以持久化，顺序指的是创建的节点会根据创建时间进行编号，后创建的编号越大，编号一般都跟在名字后面。</p></li><li>Watch<br>客户端能够针对节点添加监听器，当节点改变后，会触发watch，然后会清除watch，即watch是一次性的，而且watch能够保证事件的顺序性。watch分为两类，数据监听器和子节点监听器。</li><li>Session<br>客户端和服务端建立连接后，会话随之建立，生成一个全局唯一的会话ID(Session ID)，服务器与客户端建立TCP长连接。</li><li>ACL<br>Access Controller List，用于控制对于节点的访问，类似于unix中的<code>allow/disallow</code></li></ul><h3 id="2-_常量">2. 常量</h3><ol><li>当节点的类型为<code>PERSISTENT_SEQUENTIAL</code>, <code>EPHEMERAL_SEQUENTIAL</code>，序号从<strong>0000000001 ~ 2147483647</strong>，格式为<code>%10d</code></li><li>节点数据不能超过 1M</li><li>最多接受来自服务器的数据大小为 4M</li><li>默认的session的过期时间，2 ~ 20 个 tickTime</li></ol><h3 id="3-_常见的使用场景">3. 常见的使用场景</h3><ol><li>命名服务<br>Zookeeper 提供了一套简单的文件系统，当在同一个路径下再次创建节点时，会出错，就能保证每一个路径的唯一性。而命名服务，需要保证每一个名字的唯一性，可以通过文件系统路径的唯一性去保证。</li><li>配置管理<br>将一些小的配置放到 Zookeeper 上，因为每个 Zookeeper 服务器所看到的数据都是一致的，并且能够一致更新，从而达到动态配置的目的。</li><li><p>同步<br>利用 Zookeeper 实现分布式锁。其实现锁有以下几种方式:</p><ol><li>利用节点名称的唯一性来实现共享锁<br>在同一个路径下去同时去创建节点，谁创建成功，则获得锁，使用完后，再删除节点；否则就监听该节点，当删除时，再次去尝试创建。利用 Zookeeper 操作的原子性。如果该节点下的 watcher 很多的话，当释放锁时，会有很多线程同时去创建锁，效率不高。</li><li>利用临时顺序节点实现共享锁的一般做法<br>首先创建一个节点(例如 /distribute_lock)，所有客户端在它下面创建临时顺序 (EPHEMERAL_SEQUENTIAL) 节点，例如(/distribute_lock/guid-lock-)，同时在这个节点上注册上子节点变更通知的 Watcher，客户端调用 getChildren(“/distribute_lock”)，如果发现自己创建的节点的序号最小，则获得锁，否则就等待锁被释放，然后每一次变更都比较一下，自己的序号是否为最小。如果子节点很多的话，会有很多无用的 watch 事件。</li><li>利用临时顺序节点实现共享锁的改进实现<br>与方法二类似，只是在 watch 时，只关注节点顺序比自己小 1 的节点的事件。</li></ol></li><li>组服务<br>主要体现在于 Zookeeper 对集群的管理，而对集群的管理，主要需要解决如下两个问题:<ol><li>动态观察是否有服务器退出和加入集群<br>在一个约定目录下，创建临时节点，并且监听该目录的变化，如果掉线，则节点会被删除，那么同时，其它服务器会收到其宕机的消息。</li><li>选举master<br>同样在一个约定目录下，创建临时有序节点，每次选取编号最小的机器作为master就好。</li></ol></li><li>队列管理<ol><li>Barrier: 当一个队列的成员都聚齐时，这个队列才可用，否则一直等待<br>在约定目录下创建临时目录节点，监听目录节点数是否和我们要求的数目一致</li><li>队列按照 FIFO 方式进行入队和出队的操作<br>在约定上当下创建临时顺序目录节点，出队按编号最小的原则出队</li></ol></li></ol><h3 id="4-_ZAB协议">4. ZAB协议</h3><p>ZAB协议是作为Zookeeper一致性复制的核心。除了保证数据一致性之外，还需要满足以下的两个安全属性:</p><ol><li>全序<br>Total Order, 如果消息a 在消息b 之前发送，则所有 Server 应该看到相同的结果</li><li>因果顺序<br>Causal Order, 如果消息a 在消息b 之前发生，并被一起发送，则a始终在b之前被执行</li></ol><p>在ZAB协议中使用了TCP协议和Leader机制。通过TCP协议保证了消息的全序特性，利用Leader机制保证了因果顺序。因为所有的操作数据的操作都将通过TCP协议发给Leader，而Leader只有一个。整个ZAB协议分成四个阶段: 选举(election)、发现(discovery)、同步(sync)、广播(Broadcast)。通常根据状态分为崩溃恢复模式和消息广播模式。ZAB协议中存在三种状态: Looking(处于选举状态)、Following(当前节点是跟随者)、Leading(当前节点是 Leader， 负责协调事务)。</p><h4 id="4-1_崩溃恢复模式">4.1 崩溃恢复模式</h4><ol><li><p>选举<br>必须确保选出的 Leader 具有最高的 ZXID 。选举流程如下:</p><ol><li>每个 Follower 都向其他节点发送选自身成为 Leader 的投票请求，并带上自己最新的 ZXID；</li><li>Follower 接受到的 ZXID 如果比自身的大时则投票，并记录，否则拒绝投票；</li><li>每个 Follower 中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该 Follower 选为 Leader；</li></ol></li><li><p>发现<br>当选出最新的 Leader 后，Leader 将生成新的 epoch，让 Follower 接受最新的 acceptedEpoch。并且接收 Follower 发过来的 FOLLOWERINFO (含有当前节点的最新的 ZXID)，发现大多数节点接收的最新提议。</p></li><li><p>同步<br>Leader 利用前一阶段获得的最新提交记录，与 Follower 同步数据。同步策略如下:</p><ol><li>SNAP<br>如果 Follower 数据太老， Leader 将发送快照 SNAP 指令给 Follower 同步数据</li><li>DIFF<br>Leader 发送从 Follower 的 LastZXID 到 Leader 的 LastZXID 的 DIFF 指令给 Follower，以同步数据。</li><li>TRUNC<br>当 Follower 的 LastZXID 比 Leader 的 LastZXID 大时，Leader 发送从 Leader 的 LastZXID 到 Follower 的 LastZXID 的 Trunc 指令，让 Follower 丢弃该段数据</li></ol><p>SNAP 与 DIFF 指令用于保证集群中的 Follower 节点与已经 Committed 数据一致， TRUNC 用于抛弃已经被处理但是没有 Committed 的数据。当集群中大多数 Follower 同步成功后，再会真正成为 Leader。</p></li><li><p>ZAB崩溃恢复的策略:</p><ol><li>ZAB协议需要确保那些已经在 Leader 服务器上提交的事务最终被所有服务器都提交<br>假设一个事务在 Leader 服务器上被提交了，并且已经得到了过半 Follower 服务器的 Ack 反馈，此时 Leader 已经提交，但是在它将 Commit 消息发送给所有 Follower 机器之前，Leader 服务器挂了，恢复过程中则需要恢复该操作日志</li><li>ZAB 协议将丢弃那些只在 Leader 服务器上被提出的事务。<br>假设初始的 Leader 服务器 Server 在提出一个事务之后，还没有给 Follower 发送请求，希望得到 Ack 之前，挂了,则要丢弃该事务</li></ol></li></ol><h4 id="4-2_消息广播模式">4.2 消息广播模式</h4><ol><li>Leader 服务器会为事务请求生成一个全局唯一递增的事务ID（即ZXID），保证每个消息的因果关系的顺序。</li><li>Leader 服务器会为该事务生成对应的 Proposal，进行广播。</li><li>Leader 服务器会为每一个 Follower 服务器都各自分配一个单独的队列，将需要广播的事务 Proposal 依次放入这些队列中去，并根据 FIFO 策略进行消息发送。</li><li>每一个 Follower 服务器在接收到这个事务 Proposal 之后，首先以日志形式写入本地磁盘，并且成功写入后反馈给 Leader 服务器一个 Ack 响应</li><li>当 Leader 服务器接收超过半数的 Follower 的 Ack 响应，Leader 自身也会完成对事务的提交。同时就会广播一个 Commit 消息给所有的Follower 服务器以通知进行事务提交。每一个 Follower 服务器在接收到 Commit 消息后，也会完成对事务的提交。</li></ol><p>消息广播过程中使用了 TCP 协议进行通讯所有保证了接受和发送事务的顺序性。</p><h3 id="5-_常见问题">5. 常见问题</h3><ul><li><p>为什么要限制ZooKeeper中ZNode的大小？<br>ZooKeeper 是一套高吞吐量的系统，为了提高系统的读取速度，ZooKeeper 不允许从文件中读取需要的数据，而是直接从内存中查找。换句话说，ZooKeeper 集群中每一台服务器都包含全量的数据，并且这些数据都会加载到内存中。同时 ZNode 的数据不支持 Append 操作，全部都是Replace。所以从上面分析可以看出，如果 ZNode 过大，那么读写某一个 ZNode 将造成不确定的延时; 同时 ZNode 过大，将过快地耗尽ZooKeeper 服务器的内存。</p></li><li><p>ZAB 与 Paxos 的关系与区别<br>ZAB 与 Paxos 算法一样都是一致性算法，而 ZAB 同时解决了全序与因果顺序的问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-_Zookeeper介绍&quot;&gt;0. Zookeeper介绍&lt;/h3&gt;&lt;p&gt;Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务。其维护了一个类似Linux文件系统，但比它更简单，支持分布式的文件系统，能够保证对于节点的操作具有原子性，并且能够保证集
      
    
    </summary>
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://coolwcan.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://coolwcan.cn/Tools/Tools/Vim/"/>
    <id>https://coolwcan.cn/Tools/Tools/Vim/</id>
    <published>2019-03-12T05:48:38.589Z</published>
    <updated>2019-03-12T05:48:38.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-_Vim复制数据到剪切板">1. Vim复制数据到剪切板</h3><ol><li>安装vim-gui-commom<br><code>sudo apt-get install vim-gui-common</code></li><li><p>使用命令<br>在普通模式下，输入三个字符 <code>&quot;+y</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;，表示使用的是寄存器</span><br><span class="line">2. +，表示系统的剪切板</span><br><span class="line">3. y，复制</span><br></pre></td></tr></table></figure><p>可以通过 <code>:reg</code> 命令，查看所有的寄存器数据</p></li></ol><h3 id="2-_Vim的插件管理工具—-Bundle">2. Vim的插件管理工具—-Bundle</h3><p>安装过程如下:</p><ol><li>从github上down下Vundle，地址：<a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="noopener">https://github.com/gmarik/Vundle.vim</a></li><li>放在vimfiles文件的bundle目录下</li><li><p>在_vimrc文件中，加入</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">filetype off</span><br><span class="line"> </span><br><span class="line">set rtp+=D:\Tools\Vim\vimfiles\bundle\Vundle.vim  #你下载的vundle的位置，目录名为Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line"> </span><br><span class="line">Plugin &apos;gmarik/Vundle.vim&apos;  &quot;Vundle插件</span><br><span class="line">...其它插件</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure></li></ol><p>安装插件时，在vundle中的格式如下:</p><ol><li>代码在github上,使用github帐号/项目名，例如: <code>Bundle &#39;tpope/vim-fugitive&#39;</code> 可以直接通过加上<code>https://github.com/tpope/vim-fugitive</code>进行访问</li><li>“代码在vimscript上，使用插件名称，插件名字可以在<code>http://vim-scripts.org/vim/scripts.html</code>页面中查找，例如: <code>Bundle &#39;vimwiki&#39;</code></li></ol><p>常用的命令如下:</p><ol><li>BundleInstall， 安装所有的在文件中配置了的插件</li><li>BundleSearch，搜索某个插件</li><li>BundleClean, 删除之前下载过，但是现在不使用的插件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-_Vim复制数据到剪切板&quot;&gt;1. Vim复制数据到剪切板&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装vim-gui-commom&lt;br&gt;&lt;code&gt;sudo apt-get install vim-gui-common&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用命令&lt;br
      
    
    </summary>
    
      <category term="Tools" scheme="https://coolwcan.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://coolwcan.cn/tags/Tools/"/>
    
      <category term="Vim" scheme="https://coolwcan.cn/tags/Vim/"/>
    
  </entry>
  
</feed>
