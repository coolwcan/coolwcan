<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java应用高并发优化漫谈 | coolwcan</title>
  <meta name="author" content="coolwcan">
  
  <meta name="description" content="一、背景现在QBus每天有1.1～1.2亿次访问量，其中消息发送和删除的请求有9~10千万次，由两台4核8G的机器提供服务，消息拉取接口有1～2千万左右的访问量，同样也是由两台4核8G的机器提供服务。以下就是我们在提高服务整体性能上所做出的优化。
二、优化思路在谈优化思路前，首先需要搞清楚一个QBu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java应用高并发优化漫谈"/>
  <meta property="og:site_name" content="coolwcan"/>

  
    <meta property="og:image" content=""/>
  

  <link href="//images/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="coolwcan" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
  <script>
	$(function() {
		$(".search").keydown(function(e){
			if (e.keyCode==13) {
                // var path = "/search.xml";
                // searchFunc(path, 'local-search-input', 'local-search-result');
			}
		});
	})

    'use strict';
	var search_id = 'local-search-input'
    var content_id = 'local-search-result'
    $.ajax({
        url: '/search.xml',
        dataType: "xml",
        success: function( xmlResponse ) {
            // get the contents from search data
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                $resultContent.style.display = 'none'
                var str='<ul class=\"entry search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length <= 0) {
                    return;
                }
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var data_title = data.title.trim().toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title !== '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            if( index_title < 0){
                                isMatch = false;
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        str += "<li><a href='"+ data_url +"' class='search-result-title' target='_blank'>"+ "> " + data_title +"</a>";
                    }
                })
                $resultContent.innerHTML = str;
                if (str && str.length > 0) {
                    $resultContent.style.display = 'block'
                }
            })
        }
    })


  </script>
</head>


<body>
  <header><div>
    <nav class="animated">
        <ul>
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/about">About</a></li>
            
            <li><a href="/atom.xml">RSS</a></li>
        </ul>
    </nav>
</div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header class="article-info clearfix">
	<h1 itemprop="name">
		Java应用高并发优化漫谈
	</h1>
</header>
    <div class="entry">
        <h3 id="一、背景">一、背景</h3><p>现在<code>QBus</code>每天有<strong>1.1～1.2</strong>亿次访问量，其中消息发送和删除的请求有<strong>9~10</strong>千万次，由两台4核8G的机器提供服务，消息拉取接口有<strong>1～2千万</strong>左右的访问量，同样也是由两台4核8G的机器提供服务。以下就是我们在提高服务整体性能上所做出的优化。</p>
<h3 id="二、优化思路">二、优化思路</h3><p>在谈优化思路前，首先需要搞清楚一个<code>QBus</code>请求是如何从各个服务器走到<code>qbus-server</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk ==&gt; 域名解析 ==&gt; http协议 ==&gt; kong(nginx) ==&gt; qbus-server</span><br></pre></td></tr></table></figure>
<p>以下是针对每个环节提供的一些优化点，大家可以深入了解一下:</p>
<ul>
<li><p>SDK<br><br>TCP的keepalive，复用连接，使用连接池</p>
</li>
<li><p>域名解析如何优化呢？<br><br>CDN，选择就近资源</p>
</li>
<li><p>HTTP协议优化如何优化呢？<br><br>现在比较流行的是<code>HTTP/1.1</code>，但是可以的话，用<code>HTTP/2</code>，性能将提高很多</p>
</li>
<li><p>kong优化？<br><br>操作系统优化和nginx的优化</p>
</li>
<li><p><code>qbus-server</code>如何优化？<br><br>操作系统优化、jvm优化、tomcat优化、代码优化</p>
</li>
</ul>
<p>主要叙述的是<code>qbus-server</code>的优化，以下将会从这几个方面讲解一下<code>qbus-server</code>中的优化:</p>
<ul>
<li>操作系统优化</li>
<li>JVM优化</li>
<li>Tomcat优化</li>
<li>代码优化</li>
</ul>
<h3 id="三、内核及网络优化">三、内核及网络优化</h3><p>以下主要基于腾讯云上的Centos7的内核、网络优化。大家可以根据各自的情况进行相应的调整。</p>
<p>调整步骤:</p>
<ul>
<li>用<code>root</code>权限编辑<code>/etc/sysctl.conf</code>文件</li>
<li>执行<code>sysctl -p</code>使配置生效</li>
</ul>
<p>特别注意在修改线上文件前，请先备份。注释的为默认值配置</p>
<h4 id="3-1_关闭无用的资源">3.1 关闭无用的资源</h4><ul>
<li><p>关闭<code>ipv6</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据转发<br><br>可以实现数据转发，通常用于将一张网卡的数据转发到另一张网发上</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.ip_forward = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>不处理无源地址的网络包</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"></span><br><span class="line"># net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2_安全方面优化">3.2 安全方面优化</h4><ul>
<li><p><code>开启防欺骗攻击</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>避免ping flood攻击</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启防SYN洪水攻击，当出现SYN等待队列溢出时，启用cookies来处理</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3_TCP优化">3.3 TCP优化</h4><ul>
<li><p><code>keepalive</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效，默认是7200s</span><br><span class="line"># net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line"></span><br><span class="line"># keepalive探针，当对方不给予回应时，发送的探针的次数</span><br><span class="line"># net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"></span><br><span class="line"># keepalive探针的间隔，单位秒</span><br><span class="line"># net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><span class="escape">`H</span>TTP<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`分</span>别有什么作用？

<span class="escape">`H</span>TTP/<span class="number">1.0</span><span class="escape">`协</span>议，每一个HTTP请求开始，都将打开一个TCP连接，请求结束，都将会关闭TCP连接。从<span class="escape">`H</span>TTP/<span class="number">1.1</span><span class="escape">`开</span>始，提供了<span class="escape">`k</span>eepalive<span class="escape">`功</span>能，指的是同时请求同一个服务的同一台机器时，请求结束后，并不会立即关闭TCP连接，而是保留一段时间，在保留时间段内的请求，会复用TCP连接，过期后，才会真正结束TCP连接。

TCP的<span class="escape">`k</span>eepalive<span class="escape">`指</span>的是<span class="escape">`T</span>CP<span class="escape">`协</span>议层面上的一个检测机制，当某一个TCP连接没有数据传输后，会存在着一个定时器用于确定一个<span class="escape">`T</span>CP<span class="escape">`连</span>接是否依然存活，以决定是否关闭当前连接。

<span class="label">从上面的解释大家也能看出他们的区别，它们是两个不同层面上的协议，但是它们会共同影响`TCP`连接的生命周期。从时间上，`TCP`的`keepalive`和`HTTP`的`keepalive`会了出现如下几种情况:</span>
<span class="number">1</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间一样
<span class="number">2</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间大
<span class="number">3</span>. <span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`时</span>间小

因为<span class="escape">`H</span>TTP<span class="escape">`是</span>比<span class="escape">`T</span>CP<span class="escape">`更</span>高层的协议，当<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`和</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`的</span>时间一样，或者比<span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`小</span>，其逻辑会是正常的，因为HTTP先关，再关TCP嘛。但是如果<span class="escape">`H</span>TTP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`比</span><span class="escape">`T</span>CP<span class="escape">`的</span><span class="escape">`k</span>eepalive<span class="escape">`大</span>，则有可能会出现，<span class="escape">`H</span>TTP<span class="escape">`的</span>连接依然在复用，但是<span class="escape">`T</span>CP<span class="escape">`已</span>经关闭。
</code></pre><ul>
<li><p><code>TIME_WAIT</code>状态的重用及回收</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 启TCP时间戳，用来计算往返时间RTT（Round-Trip Time）和防止序列号回绕，用于支持tcp_tw_reuse和tcp_tw_recycle</span><br><span class="line"># net.ipv4.tcp_timestamps = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的状态的重用</span><br><span class="line"># net.ipv4.tcp_tw_reuse = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line"># TCP中的TIME_WAIT的快速回收，在对外网提供服务时，需要关闭</span><br><span class="line"># net.ipv4.tcp_tw_recycle = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><span class="escape">`T</span>IME-WAIT<span class="escape">`会</span>保持两个周期(<span class="escape">`M</span>S<span class="escape">`)</span>，而一个<span class="escape">`M</span>S<span class="escape">`是</span>一个IP报文最大的存活时间，而两个周期在于客户端发出<span class="escape">`A</span>CK<span class="escape">`到</span>达服务器的过程和数据报来到客户端的过程。只有在两个<span class="escape">`M</span>S<span class="escape">`内</span>没有任何数据，才能让客户端确定再没有任何的数据来自服务器，才能关闭<span class="escape">`S</span>ocket<span class="escape">`。</span>

<span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>快速回收，是一种基于时间序列的快速回收机制，并不会让<span class="escape">`T</span>IME_WAIT<span class="escape">`状</span>态持续两个周期，而是保持一个重传时间，能够快速释放资源。

<span class="escape">`T</span>IME_WAIT<span class="escape">`的</span>重用，当满足特定条件的<span class="escape">`S</span>ocket<span class="escape">`，</span>可以用于接受新的连接，而不用先关闭再连接。
</code></pre><ul>
<li><p><code>TCP</code>内存</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 内核分配给TCP连接的内存，单位是page：</span><br><span class="line">#  第一个数字表示TCP使用的page少于此值时，内核不进行任何处理（干预），</span><br><span class="line">#  第二个数字表示TCP使用的page超过此值时，内核进入“memory pressure”压力模式，</span><br><span class="line">#  第三个数字表示TCP使用的page超过些值时，报“Out of socket memory”错误，TCP 连接将被拒绝</span><br><span class="line"># net.ipv4.tcp_mem = 765891	1021191 1531782</span><br><span class="line">net.ipv4.tcp_mem = 88557 118079 177114</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的读缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_rmem = 4096	87380	6291456</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 6291456</span><br><span class="line"></span><br><span class="line"># 为每个TCP连接分配的写缓冲区内存大小，单位是byte</span><br><span class="line">#  第一个数字表示，为TCP连接分配的最小内存，</span><br><span class="line">#  第二个数字表示，为TCP连接分配的缺省内存，</span><br><span class="line">#  第三个数字表示，为TCP连接分配的最大内存</span><br><span class="line"># net.ipv4.tcp_wmem = 4096	16384	4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>重试次数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># TCP连接时，SYN 重发的最大次数</span><br><span class="line"># net.ipv4.tcp_syn_retries = 6</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line"># TCP连接时重发ACK的最大次数</span><br><span class="line"># net.ipv4.tcp_synack_retries = 5</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line"># 孤儿sockets废弃前重试的次数</span><br><span class="line"># net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><span class="escape">`孤</span>儿sockets<span class="escape">`指</span>的是已经从进程上下文中删除了，可是还有一些清理工作没有完成的<span class="escape">`s</span>ocket<span class="escape">`。</span>
</code></pre><ul>
<li><p>端口范围</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置端口范围，提高服务能力</span><br><span class="line"># net.ipv4.ip_local_port_range = 32768 60999</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br></pre></td></tr></table></figure>
</li>
<li><p>Other</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 设置FIN_WAIT2的等待时间，单位秒，默认为60</span><br><span class="line"># net.ipv4.tcp_fin_timeout = 60</span><br><span class="line">net.ipv4.tcp_fin_timeout = 2</span><br><span class="line"></span><br><span class="line"># 设置TIME_WAIT的最大个数，大于这个阀值后会被删除</span><br><span class="line"># net.ipv4.tcp_max_tw_buckets = 131072</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line"># 表示SYN队列的长度，默认为1024，可以容纳更多等待连接</span><br><span class="line"># net.ipv4.tcp_max_syn_backlog = 1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 100000</span><br><span class="line"></span><br><span class="line"># 用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制</span><br><span class="line"># net.core.somaxconn = 128</span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line"></span><br><span class="line"># 即不属于任何进程的tcp socket最大数量. 超过这个数量的socket会被reset, 并同时告警</span><br><span class="line"># net.ipv4.tcp_max_orphans = 131072</span><br><span class="line">net.ipv4.tcp_max_orphans = 100000</span><br><span class="line"></span><br><span class="line"># 当网卡接受数据包的速率, 比kernel处理来的快时, cache这些数据包的队列长度，默认是1000</span><br><span class="line"># net.core.netdev_max_backlog = 1000</span><br><span class="line">net.core.netdev_max_backlog = 32768</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4_其它">3.4 其它</h4><ul>
<li><p>日志</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 用于调试内核</span><br><span class="line"># kernel.sysrq = 1</span><br><span class="line">kernel.sysrq = 1</span><br><span class="line"></span><br><span class="line"># 用于在core dump文件中，增加进程ID</span><br><span class="line"># kernel.core_uses_pid = 1</span><br><span class="line">kernel.core_uses_pid = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>内核队列</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 控制一个消息的大小，bytes</span><br><span class="line"># kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"></span><br><span class="line"># 限制一个队列的最大消息个数</span><br><span class="line"># kernel.msgmax = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四、JVM优化">四、JVM优化</h3><p>JVM优化主要针对两个方面，<strong>内存</strong>和<strong>GC</strong>，以确保服务的质量和服务所占内存处于一个稳定状态。首先先介绍一下JVM的内存分布和现有<code>GC</code>算法</p>
<h4 id="4-1_JVM内存">4.1 JVM内存</h4><p>JVM中的内存主要有如下几个部分组成:</p>
<ul>
<li><p>程序计数器<br><br>用于指明当前线程需要执行的字节码行；<strong>线程私有</strong>；如果是Java方法，则记录虚拟机字节码指令地址，如果为<code>native</code>方法，则为<code>Undefined</code></p>
</li>
<li><p>虚拟机栈<br><br>每一个方法执行时，都将创建一个栈帧，用于记录局部变量、操作栈、动态链接、方法出口等，当方法被调用时，栈帧入栈，执行完成后，出栈。<strong>线程私有</strong>。</p>
</li>
<li><p>本地方法栈<br><br>与虚拟机栈类似，唯一的区别就是：虚拟机栈保存Java方法栈帧，而本地方法栈保存native方法栈帧。<strong>线程私有</strong>。</p>
</li>
<li><p>堆区<br><br>GC的主要区域，由<strong>所有线程共享</strong>，在虚拟机启动时创建，用于存储对象实例。</p>
</li>
<li><p>方法区<br><br>各个线程共享的区域，用于存储已经被虚拟机加载的类信息、final常量、静态变量、编译器即时编译的代码等。</p>
</li>
<li><p>直接内存<br><br>不受JVM管理的内存。</p>
</li>
</ul>
<p>而我们所做的优化主要针对堆区，而堆又分成：<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>、<code>Old</code>，其中<code>Eden</code>、<code>Survivor1(From Space)</code>、<code>Survivor2(To Space)</code>被统称为年轻代，<code>Old</code>是老年代。</p>
<h4 id="4-2_GC算法">4.2 <code>GC</code>算法</h4><p><code>GC</code>主要用于回收堆内存，而堆主要包含两个部分:</p>
<ul>
<li>年轻代</li>
<li>老年代</li>
</ul>
<p>针对年轻代的<code>GC</code>称为<code>Minor GC</code>，针对老年代的<code>GC</code>称为<code>Full GC</code>。</p>
<p>由于年轻代具有生命周期短的特点，通常采用 <strong>停止-复制</strong>的算法，其主要的算法有:</p>
<ul>
<li><p>Serial<br><br>新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。</p>
</li>
<li><p>ParNew<br><br>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。</p>
</li>
<li><p>Parallel Scavenge<br><br>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</p>
</li>
</ul>
<p>针对老年代对象具有数量多，对象大的特点，通常采用 <strong>标记-整理</strong>的算法，其算法有:</p>
<ul>
<li><p>Serial Old<br><br>老年代收集器，单线程收集器，使用标记整理的策略，单线程GC，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p>
</li>
<li><p>Parallel Old<br><br>老年代，多线程收集器，暂停其它工作线程，清除废弃的对象，将幸存的对象放在一起，避免内存碎片。</p>
</li>
<li><p>CMS<br><br>Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</p>
<ol>
<li>初始标记， 仅仅标记一下GC Roots能直接关联到的对象</li>
<li>并发标记， 进行GC Roots Tracing的过程</li>
<li>重新标记， 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li>
<li><p>并发清除， 标记某一个对象不可用</p>
<p>初始标记与重新标记仍然需要停止其它工作线程。其主要的2个过程，都采用并发的操作，能够保证与工作线程一起运行。但是该算法对CPU资源很敏感，CPU越多，越快；无法处理浮动垃圾，即在一次GC过程中，可能又会出现一些垃圾，需要下次GC去处理，因为它没有停止工作线程；会产生大量内存碎片，没有整理。</p>
</li>
</ol>
</li>
<li><p>G1<br><br>基于“标记-整理”算法实现的收集器，不会产生空间碎片。G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。</p>
</li>
</ul>
<h4 id="4-3_JVM优化">4.3 JVM优化</h4><p>为了避免<code>GC</code>带来的停顿影响服务质量，在内存和GC优化过程中会有如下经验:</p>
<ul>
<li>年轻代使用<code>ParNew</code>算法，老年代使用<code>CMS</code>算法，能够减少系统由于GC带来的停顿，当然也可以直接用<code>G1</code>算法，<code>QBus</code>线上使用的就是<code>ParNew</code>和<code>CMS</code>的组合</li>
<li>最大堆和最小堆设置成一样，能够避免扩容引起的<code>Full GC</code></li>
<li>最大堆的大小，不能超过整个物理机内存的50%</li>
<li>年轻代的大小，最好占整个堆的 <code>3/8</code></li>
<li><code>Eden</code>和<code>Survivor</code>的比例是<code>8</code></li>
<li><code>-XX:+DisableExplicitGC</code>，这个参数慎用，<code>DirectBuffer</code>的内存释放依赖<code>System.gc()</code>，会导致内存泄露。</li>
</ul>
<p>除了内存与<code>GC</code>优化外，以下几个方面也是需要优化的:</p>
<ul>
<li>打印<code>GC</code>日志</li>
<li>出现内存问题时，导出内存到文件</li>
</ul>
<p>如下是线上的一台<code>QBus</code>机器的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-server </span><br><span class="line">                  -XX:+PrintGCDetails </span><br><span class="line">                  -XX:+PrintGCDateStamps </span><br><span class="line">                  -Xloggc:/data/logs/qbus-server/jvm-gc/gc.log </span><br><span class="line">                  -XX:ErrorFile=/data/logs/qbus-server/jvm-error/error.log </span><br><span class="line">                  -Xms4096M </span><br><span class="line">                  -Xmx4096M </span><br><span class="line">                  -Xss228k </span><br><span class="line">                  -Xmn1536M </span><br><span class="line">                  -XX:SurvivorRatio=8 </span><br><span class="line">                  -XX:+UseParNewGC </span><br><span class="line">                  -XX:+UseConcMarkSweepGC </span><br><span class="line">                  -XX:+AggressiveOpts </span><br><span class="line">                  -XX:MaxTenuringThreshold=15 </span><br><span class="line">                  -XX:+CMSParallelRemarkEnabled  </span><br><span class="line">                  -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure>
<h3 id="五、Tomcat优化">五、Tomcat优化</h3><p>Tomcat的优化主要从如下几个方面进行优化:</p>
<ul>
<li>网络模型</li>
<li>连接池</li>
<li>线程池</li>
<li>超时时间</li>
<li>TCP参数</li>
</ul>
<p>下面将从这几个方面谈优化。</p>
<h4 id="5-1_网络模型">5.1 网络模型</h4><p>Tomcat8.5版本中，<code>Connector</code>的<code>protocol</code>支持三个模式:</p>
<ul>
<li><p><code>org.apache.coyote.http11.Http11NioProtocol</code><br><br>同步非阻塞，用Java的NIO实现</p>
</li>
<li><p><code>org.apache.coyote.http11.Http11Nio2Protocol</code><br><br>异步非阻塞，用Java的AIO实现</p>
</li>
<li><p><code>org.apache.coyote.http11.Http11AprProtocol</code><br><br>异步非阻塞，通过<code>JNI</code>的方式调用核心链接库来处理文档读取和网络传输。该协议会用到如下几个库:</p>
<ol>
<li>Apache Portable Run-time libraries(Apache可移植运行库，APR)</li>
<li>JNI wrappers for APR used by Tomcat (libtcnative)</li>
<li><p>OpenSSL</p>
<p><code>APR</code>库，是一个跨平台库，提供与平台无关的API，能够保证同一个API，在不同平台下运行，其结果总是一致的。而<code>libtcnative</code>则会调用<code>APR</code>库进行文档和网络传输的处理。而<code>Tomcat</code>则会通过<code>JNI</code>调用<code>libtcnative</code>库。</p>
</li>
</ol>
</li>
</ul>
<p><code>org.apache.coyote.http11.Http11AprProtocol</code>是<code>Tomcat</code>上运行高并发的首选，接下来将介绍如何安装APR库。</p>
<hr>
<p>首先创建<code>tomcat-native-install.sh</code>脚本，并添加执行权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">base=`pwd`</span><br><span class="line">#tomcat的安装目录</span><br><span class="line">tomcat_base=$1</span><br><span class="line">#希望编译好的lib放到什么地方</span><br><span class="line">lib_base=$2</span><br><span class="line">    </span><br><span class="line">function install_openssl() &#123;</span><br><span class="line">    openssl=openssl-1.1.0f</span><br><span class="line">    wget https://www.openssl.org/source/$&#123;openssl&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;openssl&#125;.tar.gz</span><br><span class="line">    cd $&#123;openssl&#125; </span><br><span class="line">    ./config --prefix=$&#123;base&#125;/ssl no-shared -fPIC</span><br><span class="line">    make &amp;&amp; make install_sw</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;openssl&#125; $&#123;openssl&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_apr() &#123;</span><br><span class="line">    apr=apr-1.6.3</span><br><span class="line">    wget http://archive.apache.org/dist/apr/$&#123;apr&#125;.tar.gz</span><br><span class="line">    tar -xf $&#123;apr&#125;.tar.gz</span><br><span class="line">    cd $&#123;apr&#125;</span><br><span class="line">    ./configure --prefix=$&#123;base&#125;/apr</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd ..</span><br><span class="line">    rm -rf $&#123;apr&#125; $&#123;apr&#125;.tar.gz</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function install_tomcat_native() &#123;</span><br><span class="line">    base_dir=`pwd`</span><br><span class="line">    cd $&#123;tomcat_base&#125;/bin</span><br><span class="line">    pwd</span><br><span class="line">    tar -xf tomcat-native.tar.gz</span><br><span class="line">    cd `ls $&#123;tomcat_base&#125;/bin | grep src`/native</span><br><span class="line">    ./configure --with-apr=$&#123;base&#125;/apr --with-ssl=$&#123;base&#125;/ssl --with-java-home=$JAVA_HOME --prefix=$lib_base</span><br><span class="line">    make &amp;&amp; make install</span><br><span class="line">    cd $base_dir</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">install_openssl</span><br><span class="line">install_apr</span><br><span class="line">install_tomcat_native</span><br><span class="line">    </span><br><span class="line">rm -rf $&#123;base&#125;/apr</span><br><span class="line">rm -rf $&#123;base&#125;/ssl</span><br><span class="line">    </span><br><span class="line">lib=$&#123;lib_base&#125;/lib</span><br><span class="line">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&apos;$&#123;lib&#125; &gt;&gt; ~/.profile</span><br><span class="line">source ~/.profile</span><br><span class="line">    </span><br><span class="line">echo 编译 Tomcat目录/conf/server.xml，将其中的 Connector 的 protocol 改成 org.apache.coyote.http11.Http11AprProtocol 和</span><br><span class="line">echo org.apache.coyote.ajp.AjpAprProtocol</span><br></pre></td></tr></table></figure>
<p>然后再用<code>root</code>执行<code>./tomcat-native-install.sh Tomcat的安装目录 APR库的安装位置</code>进行安装，在传参时，需要注意如下两点:</p>
<ol>
<li>传入给shell的参数需要全路径</li>
<li>传给shell的路径参数，最后不需要加上<code>/</code></li>
</ol>
<p>例如： <code>./tomcat-native-install.sh /usr/local/services/tomcat /usr/local/services/tomcat-apr/tomcat-native</code></p>
<p>安装完成后，还需要修改如下配置：</p>
<ol>
<li>修改<code>Tomcat目录/conf/server.xml</code>将其中的<code>Connector</code>的<code>protocol</code>改成<code>org.apache.coyote.http11.Http11AprProtocol</code> 和<code>org.apache.coyote.ajp.AjpAprProtocol</code></li>
<li>修改<code>Tomcat目录/bin/catalina.sh</code>中添加<code>JAVA_OPTS=&quot;$JAVA_OPTS -Djava.library.path=上面APR的安装目录/lib&quot;</code></li>
</ol>
<p>重启服务，即可生效。在<code>logs/catalina.out</code>，能看到如下输出，则能确定<code>APR</code>库生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">07-Mar-2019 11:46:15.871 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-apr-8080&quot;]</span><br><span class="line">07-Mar-2019 11:46:15.875 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;ajp-apr-8009&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="5-2_连接池优化">5.2 连接池优化</h4><ul>
<li><p><code>acceptorThreadCount</code><br><br>在<code>Tomcat</code>中会由专门的<code>accept</code>线程用于接收请求，并将请求转交给工作线程。通常<code>accept</code>线程个数与CPU核数一致，默认值为1</p>
</li>
<li><p><code>acceptCount</code><br><br>当已经没有任何可用的工作线程为新的请求提供服务时，会将请求进行缓存。<code>acceptCount</code>则用于指定缓存队列的大小。当请求无法再放入缓存队列后，请求将会被拒绝。通常用户可能会在nginx层面上看到如下的异常:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>maxConnections</code><br><br>用于设置<code>Tomcat</code>的最大连接数，这仅仅是Tomcat层面上的限制，超过最大连接数后，操作系统层面，仍然会接收请求，只是请求请求将会进入到缓存队列，当缓存队列满后，请求会被阻塞。可以设置为-1，关闭此限制。</p>
</li>
</ul>
<h4 id="5-3_线程池优化">5.3 线程池优化</h4><p>线程池的优化主要有两个方面:</p>
<ul>
<li>线程命名</li>
<li>线程个数</li>
</ul>
<p>线程命名是为在排查问题时，通过<code>jstack</code>命令查询，能够区分出哪些是<code>Tomcat</code>线程。而线程个数能够保证服务的稳定运行。<code>QBus</code>服务线上的配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Executor name=&quot;tomcatThreadPool&quot;</span><br><span class="line">              namePrefix=&quot;tomcatThreadPool-&quot;</span><br><span class="line">              maxThreads=&quot;500&quot;</span><br><span class="line">              maxIdleTime=&quot;10000&quot;</span><br><span class="line">              minSpareThreads=&quot;300&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> 用于指明线程名字前缀</li>
<li><code>minSpareThreads</code> 初始化线程个数</li>
<li><code>maxThreads</code> 线程池的最大线程个数</li>
<li><code>maxIdleTime</code> 当某一个线程多久未使用，将会被回收，单位毫秒</li>
</ul>
<p>通常可以将线程个数的最大个数设置为500，或者更多，然后上线后，通过<code>jstack tomcat线程ID | grep Tomcat线程前缀名 | grep run | wc -l</code>查看线上稳定运行的线程个数，然后再去调整<code>minSpareThreads</code>。</p>
<p>请注意在Tomcat中的<code>TPS</code>是由<code>maxConnections</code>、<code>acceptCount</code>与<code>maxThreads</code>共同决定的。</p>
<h4 id="5-4_超时优化">5.4 超时优化</h4><p>Tomcat总体上有如下几个超时设置:</p>
<ul>
<li><p><code>connectionTimeout</code><br><br>当客户端与服务器已经建立连接后，等待客户端传输请求头时，最多等待<code>connectionTimeout</code>毫秒</p>
</li>
<li><p><code>keepAliveTimeout</code><br><br>针对<code>HTTP/1.1</code>协议，用于设置服务器最大保持连接的时间</p>
</li>
<li><p><code>disableUploadTimeout</code>和<code>connectionUploadTimeout</code><br><br>  当<code>disableUploadTimeout</code>为<code>false</code>时，<code>connectionUploadTimeout</code>才会生效。<code>connectionUploadTimeout</code>用于设置服务器等待客户传输请求体的最大等待时间。</p>
</li>
</ul>
<p>注意<code>connectionTimeout</code>和<code>connectionUploadTimeout</code>，这两个参数分别设置了传输请求头与请求体的最大等待时间。<code>QBus</code>的线上配置是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot;</span><br><span class="line">                executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">                protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">                URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">                enableLookups=&quot;false&quot;</span><br><span class="line">                connectionTimeout=&quot;30000&quot;</span><br><span class="line">                keepAliveTimeout=&quot;30000&quot;</span><br><span class="line">                disableUploadTimeout=&quot;false&quot;</span><br><span class="line">                connectionUploadTimeout=&quot;600000&quot;</span><br><span class="line">                acceptCount=&quot;500&quot;</span><br><span class="line">                useSendfile=&quot;false&quot;</span><br><span class="line">                compression=&quot;off&quot;</span><br><span class="line">                redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-5_TCP参数">5.5 TCP参数</h4><ul>
<li><p><code>tcpNoDelay</code><br><br>用于开启或者关闭<code>Nagle</code>算法。<code>Nagle</code>算法，会将小的<code>TCP</code>包合并成一个大的包再进行发送，避免过多的小报文的TCP头的资源消耗。通常在交互性比较强的应用中会关闭<code>Nagle</code>算法，默认是开启的。</p>
</li>
<li><p><code>connectionLinger</code><br><br>与<code>TCP</code>的<code>SO_LINGER</code>的选项一致，用于控制<code>TCP</code>的<code>close</code>行为。<code>SO_LINGER</code>通常有三个取值：</p>
<ol>
<li>-1，会将<code>socket</code>发送缓存区中的数据发送完成后，才关闭<code>socket</code></li>
<li>0，通过发送RST分组(而不是用正常的FIN|ACK|FIN|ACK四个分组)来关闭该连接，并放弃发送缓存区中的数据。</li>
<li>大于0，关闭时，进程将进入睡眠状态，内核通过定时器在超时前尽量发送数据，如果发送完成，则正常关闭，否则超时后，直接通过<code>RST</code>进行关闭，丢弃发送缓存区中的数据。</li>
</ol>
</li>
<li><p><code>deferAccept</code><br><br>与<code>TCP</code>中的<code>TCP_DEFER_ACCEPT</code>选项一致。在解释<code>TCP_DEFER_ACCEPT</code>参数前，先解释一下<code>TCP</code>的三次握手:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Client -&gt; Server：客户端给服务器发送SYN包</span><br><span class="line">2. Client &lt;- Server: 服务器在收到SYN包后，将返给客户SYN + ACK，Server端的连接为SYN_RECV状态</span><br><span class="line">3. Client -&gt; Server: 客户端收到SYN+ACK包后，向服务器发送ACK包，Client和Server端的连接均为ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>  通常服务器在接受到最后的一个<code>ACK</code>包后，将进入<code>ESTABLISH</code>状态。此过程会出现一个问题，当服务器已经打开了连接，但是如果客户端一直不发数据的话，会占用服务器的资源。而<code>TCP_DEFER_ACCEPT</code>选项开启后，在接受到最后一个<code>ACK</code>后，并不会进入<code>ESTABLISH</code>状态，也并不会真正建立连接，而是保持在<code>SYN_RECV</code>状态，只是标记当前<code>socket</code>，当客户端的数据真正到来时，才建立连接。通常是需要开启<code>延迟ACK</code>，将<code>ACK</code>与数据一起发送，才能建立连接。</p>
</li>
<li><p><code>useSendfile</code><br><br>用于开启或者关闭<strong>零拷贝机制</strong>，该机制，通过减少数据在用户态和内核态的拷贝，从而提高性能。</p>
</li>
</ul>
<h4 id="5-6_Tomcat的注意点">5.6 Tomcat的注意点</h4><ul>
<li><code>Spring</code>项目，尽量不要将项目调整成<code>root</code>目录，否则有可能你会遇到某一个<code>bean</code>会被初始化两次的问题</li>
<li>一个<code>Tomcat</code>尽量只有一个项目</li>
</ul>
<h3 id="六、代码层面上的优化">六、代码层面上的优化</h3><p>代码方面，主要引入了内存级别的缓存层，将配置信息放入缓存，避免对数据库的读操作。多个进程间的缓存同步有两个机制进行保证:</p>
<ul>
<li>同步通过<code>QBus</code>本身进行同步</li>
<li>当从缓存中读取不到数据时，再读数据库，此时一定需要注意，避免出现<code>Dog Pipe Effect</code>现象</li>
</ul>
<p>加入缓存后，整个消息的发送时延多<code>40ms</code>降低到<code>10～15ms</code>之间。</p>
<h3 id="七、总结">七、总结</h3><p>以上就是<code>QBus</code>已经做过的优化，在孙哥(孙国峻)和我们沟通后，新版本的<code>QBus</code>中，我们将做如下的优化:</p>
<ol>
<li>减少对数据库的依赖，引入redis</li>
<li>模块分离，将<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>与页面逻辑进行模块分离</li>
<li>针对<code>send</code>、<code>publish</code>、<code>ack</code>、<code>pull</code>接口，通过<code>netty</code>进行网络接连，这样可以自定义其<code>TCP</code>参数、连接池、线程池、网络模型等，而且除了能提高性能，同样也能给出详细的日志，比如metric信息、异常信息等，能更好地把控服务</li>
<li>优化日志，不直接写kafka，写文件，再同步到kafka，以便快速解决问题</li>
</ol>
<p>优化是一个长期过程，而要反复迭代，并且会很受到业务功能的影响，比如<code>QBus</code>的拉消息接口，其功能决定了这是一个慢操作，而发送消息、删除消息，就必须要保证尽可能快，所以相对而言，拉消息更消耗内存，而发送消息、删除消息接口更消耗CPU，所以优化时，也需要分开处理。欢迎大家补充指正。</p>

    </div>
    <footer>
        
	
	<div class="categories">
	<a href="/categories/J2ee/">J2ee</a>
	</div>

        
  
  <div class="tags">
    <a href="/tags/Java/">Java</a>, <a href="/tags/高并发/">高并发</a>
  </div>

        <div class="clearfix"></div>
    </footer>
  </div>
</article>

 <nav id="pagination" >
    
    
    <a href="/Zookeeper/Zookeeper/Zookeeper-02-Session/" class="alignright next" title="Zookeeper-02-Session">Zookeeper-02-Session</a>
    
    <div class="clearfix"></div>
</nav>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="widget author-meta">
    <div class="author-avatar">
        <img src="/images/author.jpg">
    </div>
    <div class="author-name">coolwcan</div>
    <div class="author-work">Java Developer</div>
    <div class="author-location">
        <i class="icon-location"></i>
        <span>四川成都</span>
    </div>
    <div class="social-font">
        
        <a href="https://github.com/coolwcan" target="_blank" title="github"></a>
        
        
        <a href="mailto:coolwcan@163.com" target="_blank" class="icon-email" title="email"></a>
        
    </div>
</div>


  <div class="widget search" style="margin-bottom: 30px">
    <input id="local-search-input" class="search" type="search" placeholder="搜索">
    <div id="local-search-result" style="display: none;" class="entry"></div>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    
        <li><a href="/categories/Algorithm/">Algorithm</a><small>4</small></li>
    
  
    
        <li><a href="/categories/C-C/">C/C++</a><small>21</small></li>
    
  
    
        <li><a href="/categories/Coding/">Coding</a><small>2</small></li>
    
  
    
        <li><a href="/categories/Computer/">Computer</a><small>8</small></li>
    
  
    
        <li><a href="/categories/Database/">Database</a><small>6</small></li>
    
  
    
        <li><a href="/categories/DevOps/">DevOps</a><small>1</small></li>
    
  
    
        <li><a href="/categories/Distributed/">Distributed</a><small>2</small></li>
    
  
    
        <li><a href="/categories/Erlang/">Erlang</a><small>7</small></li>
    
  
    
        <li><a href="/categories/J2ee/">J2ee</a><small>8</small></li>
    
  
    
        <li><a href="/categories/Java/">Java</a><small>6</small></li>
    
  
    
        <li><a href="/categories/Life/">Life</a><small>1</small></li>
    
  
    
        <li><a href="/categories/Network/">Network</a><small>4</small></li>
    
  
    
        <li><a href="/categories/Security/">Security</a><small>3</small></li>
    
  
    
        <li><a href="/categories/Shiro/">Shiro</a><small>6</small></li>
    
  
    
        <li><a href="/categories/Tools/">Tools</a><small>8</small></li>
    
  
    
        <li><a href="/categories/Web/">Web</a><small>1</small></li>
    
  
    
        <li><a href="/categories/Zookeeper/">Zookeeper</a><small>3</small></li>
    
  
    
        <li><a href="/categories/配置中心/">配置中心</a><small>1</small></li>
    
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/ACK/" style="font-size: 10px;">ACK</a> <a href="/tags/Archlinux/" style="font-size: 10px;">Archlinux</a> <a href="/tags/Arrays/" style="font-size: 10px;">Arrays</a> <a href="/tags/Base64/" style="font-size: 10px;">Base64</a> <a href="/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/tags/CRC/" style="font-size: 10px;">CRC</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Centos/" style="font-size: 10px;">Centos</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/Class/" style="font-size: 10px;">Class</a> <a href="/tags/Coding/" style="font-size: 10px;">Coding</a> <a href="/tags/Collection/" style="font-size: 11.43px;">Collection</a> <a href="/tags/Compile/" style="font-size: 10px;">Compile</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Computer/" style="font-size: 11.43px;">Computer</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/DDos/" style="font-size: 10px;">DDos</a> <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/Deployment/" style="font-size: 10px;">Deployment</a> <a href="/tags/DevOps/" style="font-size: 10px;">DevOps</a> <a href="/tags/Distributed/" style="font-size: 10px;">Distributed</a> <a href="/tags/Efficiency/" style="font-size: 10px;">Efficiency</a> <a href="/tags/Erlang/" style="font-size: 15.71px;">Erlang</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/Generic/" style="font-size: 10px;">Generic</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Intellij-Idea/" style="font-size: 10px;">Intellij Idea</a> <a href="/tags/J2ee/" style="font-size: 17.14px;">J2ee</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 17.14px;">Java</a> <a href="/tags/JavaBean/" style="font-size: 10px;">JavaBean</a> <a href="/tags/Life/" style="font-size: 10px;">Life</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MAC/" style="font-size: 10px;">MAC</a> <a href="/tags/Memorty/" style="font-size: 10px;">Memorty</a> <a href="/tags/Memory/" style="font-size: 15.71px;">Memory</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/NAT/" style="font-size: 10px;">NAT</a> <a href="/tags/Network/" style="font-size: 14.29px;">Network</a> <a href="/tags/Object-oriented/" style="font-size: 10px;">Object-oriented</a> <a href="/tags/Optimize/" style="font-size: 11.43px;">Optimize</a> <a href="/tags/REST/" style="font-size: 10px;">REST</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Release/" style="font-size: 10px;">Release</a> <a href="/tags/SEQ/" style="font-size: 10px;">SEQ</a> <a href="/tags/SPI/" style="font-size: 10px;">SPI</a> <a href="/tags/SSL-TLS/" style="font-size: 11.43px;">SSL/TLS</a> <a href="/tags/SSO/" style="font-size: 10px;">SSO</a> <a href="/tags/Security/" style="font-size: 12.86px;">Security</a> <a href="/tags/Session/" style="font-size: 11.43px;">Session</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Shiro/" style="font-size: 15.71px;">Shiro</a> <a href="/tags/Sort/" style="font-size: 10px;">Sort</a> <a href="/tags/Source-codes-analysis/" style="font-size: 17.14px;">Source codes analysis</a> <a href="/tags/Spring-MVC/" style="font-size: 11.43px;">Spring MVC</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Tools/" style="font-size: 18.57px;">Tools</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Xss/" style="font-size: 10px;">Xss</a> <a href="/tags/Zookeeper/" style="font-size: 12.86px;">Zookeeper</a> <a href="/tags/ets/" style="font-size: 10px;">ets</a> <a href="/tags/热更新/" style="font-size: 10px;">热更新</a> <a href="/tags/高并发/" style="font-size: 10px;">高并发</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/latest.js">
</script>
</body>
</html>
